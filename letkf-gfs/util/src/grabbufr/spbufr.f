      SUBROUTINE ADDATE(IDATE,JH,JDATE)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    ADDATE
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE UPDATES AN EIGHT (YYMMDDHH) OR TEN
C   (YYYYMMDDHH) DIGIT INTEGER DATE BY A SPECIFIED NUMBER OF HOURS.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1996-12-11  J. WOOLLEN -- NEW DATE ARITHMETIC ROUTINE ADDED
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    CALL ADDATE (IDATE, JH, JDATE)
C   INPUT ARGUMENT LIST:
C     IDATE    - INTEGER: EIGHT- OR TEN-DIGIT DATE
C     JH       - INTEGER: NUMBER OF HOURS (+ OR -) BY WHICH IDATE
C                SHOULD BE UPDATED
C
C   OUTPUT ARGUMENT LIST:
C     JDATE    - INTEGER: EIGHT- OR TEN-DIGIT UPDATED DATE
C
C REMARKS:
C    THIS ROUTINE CALLS:        None
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs (W3LIB routine W3MOVDAT is
C                               much better).
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      DIMENSION   MON(12)

      DATA MON/31,28,31,30,31,30,31,31,30,31,30,31/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IY = IDATE/1000000
      IM = MOD(IDATE/10000  ,100)
      ID = MOD(IDATE/100    ,100)
      IH = MOD(IDATE        ,100)
      IH = IH+JH

      IF(MOD(IY,4)  .NE.0) MON(2) = 28
      IF(MOD(IY,4)  .EQ.0) MON(2) = 29
      IF(MOD(IY,400).EQ.0) MON(2) = 29

1     IF(IH.LT.0) THEN
         IH = IH+24
         ID = ID-1
         IF(ID.EQ.0) THEN
            IM = IM-1
            IF(IM.EQ.0) THEN
               IM = 12
               IY = IY-1
               IF(IY.LT.0) IY = 99
            ENDIF
            ID = MON(IM)
         ENDIF
         GOTO 1
      ELSEIF(IH.GE.24) THEN
         IH = IH-24
         ID = ID+1
         IF(ID.GT.MON(IM)) THEN
            ID = 1
            IM = IM+1
            IF(IM.GT.12) THEN
               IM = 1
               IY = IY+1
               IF(IY.EQ.100) IY = 00
            ENDIF
         ENDIF
         GOTO 1
      ENDIF

      JDATE = IY*1000000 + IM*10000 + ID*100 + IH

      RETURN
      END
      FUNCTION ADN30(IDN,L30)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    ADN30
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION CONVERTS A DESCRIPTOR FROM ITS BIT-WISE
C   (INTEGER) REPRESENTATION TO ITS FIVE OR SIX CHARACTER ASCII
C   REPRESENTATION.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    ADN30 (IDN, L30)
C   INPUT ARGUMENT LIST:
C     IDN      - INTEGER: BIT-WISE REPRESENTATION OF DESCRIPTOR (FXY)
C                VALUE
C     L30      - INTEGER: LENGTH OF ADN30 (NUMBER OF CHARACTERS, 5 OR
C                6)
C
C   OUTPUT ARGUMENT LIST:
C     ADN30    - CHARACTER*(*): CHARACTER FORM OF DESCRIPTOR (FXY
C                VALUE)
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT
C    THIS ROUTINE IS CALLED BY: DXINIT   NUMTAB   SEQSDX   UFBQCD
C                               UPDS3    WRITDX   XMSGINI
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)

      CHARACTER*(*) ADN30
      CHARACTER*128 BORT_STR

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      IF(LEN(ADN30).LT.L30         ) GOTO 900
      IF(IDN.LT.0 .OR. IDN.GT.65535) GOTO 901
      IF(L30.EQ.5) THEN
         WRITE(ADN30,'(I5)') IDN
      ELSEIF(L30.EQ.6) THEN
         IDF = ISHFT(IDN,-14)
         IDX = ISHFT(ISHFT(IDN,NBITW-14),-(NBITW-6))
         IDY = ISHFT(ISHFT(IDN,NBITW- 8),-(NBITW-8))
         WRITE(ADN30,'(I1,I2,I3)') IDF,IDX,IDY
      ELSE
         GOTO 902
      ENDIF

      DO I=1,L30
      IF(ADN30(I:I).EQ.' ') ADN30(I:I) = '0'
      ENDDO

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: ADN30 - FUNCTION RETURN STRING TOO SHORT')
901   CALL BORT('BUFRLIB: ADN30 - INTEGER REPRESENTATION OF '//
     . 'DESCRIPTOR OUT OF 16-BIT RANGE')
902   WRITE(BORT_STR,'("BUFRLIB: ADN30 - CHARACTER LENGTH (",I4,") '//
     . 'MUST BE EITHER 5 OR 6")') L30
      CALL BORT(BORT_STR)
      END
      SUBROUTINE BFRINI

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    BFRINI
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE IS CALLED ONLY ONE TIME (DURING THE FIRST
C   CALL TO BUFR ARCHIVE LIBRARY SUBROUTINE OPENBF) IN ORDER TO
C   INITIALIZE SOME GLOBAL VARIABLES AND ARRAYS WITHIN SEVERAL COMMON
C   BLOCKS.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1995-06-28  J. WOOLLEN -- INCREASED THE SIZE OF INTERNAL BUFR TABLE
C                           ARRAYS IN ORDER TO HANDLE BIGGER FILES
C 1998-07-08  J. WOOLLEN -- MODIFIED TO MAKE Y2K COMPLIANT
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); INITIALIZES
C                           VARIABLE JSR AS ZERO IN NEW COMMON BLOCK
C                           /BUFRSR/ (WAS IN VERIFICATION VERSION);
C                           UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION
C
C USAGE:    CALL BFRINI
C
C REMARKS:
C    THIS ROUTINE CALLS:        IFXY     IPKM
C    THIS ROUTINE IS CALLED BY: OPENBF
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)
      PARAMETER (MAXTBA=50)
      PARAMETER (MAXTBB=250)
      PARAMETER (MAXTBD=250)
      PARAMETER (MXMSGL=20000)

      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /MAXCMP/ MAXCMB,MAXROW,MAXCOL,NCMSGS,NCSUBS,NCBYTS
      COMMON /PADESC/ IBCT,IPD1,IPD2,IPD3,IPD4
      COMMON /REPTAB/ IDNR(5,2),TYPS(5,2),REPS(5,2),LENS(5)
      COMMON /STBFR / IOLUN(NFILES),IOMSG(NFILES)
      COMMON /TABABD/ NTBA(0:NFILES),NTBB(0:NFILES),NTBD(0:NFILES),
     .                MTAB(MAXTBA,NFILES),IDNA(MAXTBA,NFILES,2),
     .                IDNB(MAXTBB,NFILES),IDND(MAXTBD,NFILES),
     .                TABA(MAXTBA,NFILES),TABB(MAXTBB,NFILES),
     .                TABD(MAXTBD,NFILES)
      COMMON /DXTAB / MAXDX,IDXV,NXSTR(10),LDXA(10),LDXB(10),LDXD(10),
     .                LD30(10),DXSTR(10)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)
      COMMON /BUFRMG/ MSGLEN,MSGTXT(MXMSGL/4)
      COMMON /MRGCOM/ NRPL,NMRG,NAMB,NTOT
      COMMON /DATELN/ LENDAT
      COMMON /ACMODE/ IAC
      COMMON /BUFRSR/ JUNN,JILL,JIMM,JBIT,JBYT,JMSG,JSUB,KSUB,JNOD,JDAT,
     .                JSR(NFILES),JBAY(MXMSGL/4)

      CHARACTER*600 TABD
      CHARACTER*128 TABB
      CHARACTER*128 TABA
      CHARACTER*56  DXSTR
      CHARACTER*10  TAG
      CHARACTER*6   ADSN(5,2),DNDX(25,10)
      CHARACTER*3   TYPX(5,2),TYPS,TYP
      CHARACTER*1   REPX(5,2),REPS
      DIMENSION     NDNDX(10),NLDXA(10),NLDXB(10),NLDXD(10),NLD30(10)
      DIMENSION     LENX(5)

      DATA ADSN   / '101000','360001','360002','360003','360004' ,
     .              '101255','031002','031001','031001','031000' /
      DATA TYPX   /    'REP',   'DRP',   'DRP',   'DRS' ,  'DRB' ,
     .                 'SEQ',   'RPC',   'RPC',   'RPS' ,  'SEQ' /
      DATA REPX   /      '"',     '(',     '{',     '[' ,    '<' ,
     .                   '"',     ')',     '}',     ']' ,    '>' /
      DATA LENX   /       0 ,     16 ,      8 ,      8  ,     1  /

      DATA (DNDX(I,1),I=1,25)/
     .'102000','031001','000001','000002',
     .'110000','031001','000010','000011','000012','000013','000015',
     .                  '000016','000017','000018','000019','000020',
     .'107000','031001','000010','000011','000012','000013','101000',
     .                  '031001','000030'/

      DATA (DNDX(I,2),I=1,15)/
     .'103000','031001','000001','000002','000003',
     .'101000','031001','300004',
     .'105000','031001','300003','205064','101000','031001','000030'/

      DATA NDNDX /  25 ,  15 , 8*0 /
      DATA NLDXA /  35 ,  67 , 8*0 /
      DATA NLDXB /  80 , 112 , 8*0 /
      DATA NLDXD /  38 ,  70 , 8*0 /
      DATA NLD30 /   5 ,   6 , 8*0 /

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  INITIALIZE /BITBUF/
C  -------------------

      MAXBYT = 10000

C  INITIALIZE /MAXCMP/
C  -------------------

      MAXCMB = MAXBYT
      MAXROW = 0
      MAXCOL = 0
      NCMSGS = 0
      NCSUBS = 0
      NCBYTS = 0

C  INITIALIZE /PADESC/
C  -------------------

      IBCT = IFXY('063000')
      IPD1 = IFXY('102000')
      IPD2 = IFXY('031001')
      IPD3 = IFXY('206001')
      IPD4 = IFXY('063255')

C  INITIALIZE /STBFR/
C  ------------------

      DO I=1,NFILES
      IOLUN(I) = 0
      IOMSG(I) = 0
      ENDDO

C  INITIALIZE /REPTAB/
C  -------------------

      DO I=1,5
      LENS(I) = LENX(I)
      DO J=1,2
      IDNR(I,J) = IFXY(ADSN(I,J))
      TYPS(I,J) = TYPX(I,J)
      REPS(I,J) = REPX(I,J)
      ENDDO
      ENDDO

C  INITIALIZE /TABABD/ (INTERNAL ARRAYS HOLDING DICTIONARY TABLE)
C  --------------------------------------------------------------

C    NTBA(0) is the maximum number of entries w/i internal BUFR table A

      NTBA(0) = MAXTBA

C    NTBB(0) is the maximum number of entries w/i internal BUFR Table B

      NTBB(0) = MAXTBB

C    NTBD(0) is the maximum number of entries w/i internal BUFR Table D

      NTBD(0) = MAXTBD

C  INITIALIZE /DXTAB/
C  ------------------

      MAXDX = MAXBYT
c  .... IDXV is the version number of the local tables
      IDXV  = 1

      DO J=1,10
      LDXA(J)  = NLDXA(J)
      LDXB(J)  = NLDXB(J)
      LDXD(J)  = NLDXD(J)
      LD30(J)  = NLD30(J)
      DXSTR(J) = '      '
      NXSTR(J) = NDNDX(J)*2
      DO I=1,NDNDX(J)
      I1 = I*2-1
      CALL IPKM(DXSTR(J)(I1:I1),2,IFXY(DNDX(I,J)))
      ENDDO
      ENDDO

C  INITIALIZE /TABLES/
C  -------------------

      MAXTAB = MAXJL

C  INITIALIZE /BUFRMG/
C  -------------------

      MSGLEN = 0

C  INITIALIZE /MRGCOM/
C  -------------------

      NRPL = 0
      NMRG = 0
      NAMB = 0
      NTOT = 0

C  INITIALIZE /DATELN/
C  -------------------

      IF(LENDAT.NE.10) LENDAT = 8

C  INITIALIZE /ACMODE/
C  ------------------_

c  .... DK: What does this control??
      IAC = 0

C  INITIALIZE /BUFRSR/
C  -------------------

      DO I=1,NFILES
      JSR(I) = 0
      ENDDO

      RETURN
      END
      SUBROUTINE BORT(STR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    BORT
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1998-07-08
C
C ABSTRACT: THIS SUBROUTINE PRINTS (TO STDOUT) A GIVEN ERROR STRING
C   AND THEN CALLS BUFR ARCHIVE LIBRARY SUBROUTINE BORT_EXIT TO ABORT
C   THE APPLICATION PROGRAM CALLING THE BUFR ARCHIVE LIBRARY SOFTWARE.
C   IT IS SIMILAR TO BUFR ARCHIVE LIBRARY SUBROUTINE BORT2, EXCEPT
C   BORT2 PRINTS TWO ERROR STRINGS. 
C
C PROGRAM HISTORY LOG:
C 1998-07-08  J. WOOLLEN -- ORIGINAL AUTHOR (REPLACED CRAY LIBRARY
C                           ROUTINE ABORT)
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION; REPLACED CALL TO
C                           INTRINSIC C ROUTINE "EXIT" WITH CALL TO
C                           BUFRLIB C ROUTINE "BORT_EXIT" WHICH ALWAYS
C                           RETURNS A NON-ZERO STATUS BACK TO EXECUTING
C                           SHELL SCRIPT
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION
C
C USAGE:    CALL BORT (STR)
C   INPUT ARGUMENT LIST:
C     STR      - CHARACTER*(*): ERROR MESSAGE TO BE PRINTED TO
C                STANDARD OUTPUT 
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT_EXIT
C    THIS ROUTINE IS CALLED BY: ADN30    CHEKSTAB CKTABA   CLOSMG
C                               CMSGINI  COMPRES  COPYBF   COPYMG
C                               COPYSB   COPYST   CPYMEM   CPYUPD
C                               DATEBF   DATELEN  DRFINI   DRSTPL
C                               DUMPBF   DXMINI   GETWIN   IDN30
C                               IFBGET   INCTAB   INVMRG   IPKM
C                               IUPM     JSTCHR   JSTNUM   LSTJPB
C                               LSTRPC   LSTRPS   MAKESTAB MINIMG
C                               MSGINI   MSGWRT   MVB      NEMTBA
C                               NEMTBAX  NEMTBB   NEMTBD   NENUAA
C                               NENUBD   NEVN     NEWWIN   NMBYT
C                               NMSUB    NVNWIN   NXTWIN   OPENBF
C                               OPENMB   OPENMG   PAD      PARUTG
C                               POSAPN   POSAPX   RCSTPL   RDBFDX
C                               RDMEMM   RDMEMS   RDMGSB   READ2C
C                               READDX   READERM  READERME READFT
C                               READIBM  READLC   READMG   READMM
C                               READNS   READSB   REWNBF   STANDARD
C                               STATUS   TABENT   TABSUB   TRYBUMP
C                               UFBCNT   UFBCPY   UFBCUP   UFBDMP
C                               UFBEVN   UFBGET   UFBIN3   UFBINT
C                               UFBINX   UFBMEM   UFBMMS   UFBMNS
C                               UFBOVR   UFBQCD   UFBQCP   UFBREP
C                               UFBRMS   UFBSEQ   UFBSTP   UFBTAM
C                               UFDUMP   UPTDD    USRTPL   WRCMPS
C                               WRDLEN   WRITCP   WRITDX   WRITLC
C                               WRITSA   WRITSB   WRITST   WTSTAT
C                               XMSGINI
C                               Normally not called by any application
C                               programs but it could be.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*(*) STR
      PRINT*
      PRINT*,'**************BUFR ARCHIVE LIBRARY ABORT*****************'
      PRINT*,STR
      PRINT*,'**************BUFR ARCHIVE LIBRARY ABORT*****************'
      PRINT*
      CALL EXIT(100)
      END
      SUBROUTINE BORT2(STR1,STR2)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    BORT2
C   PRGMMR: KEYSER           ORG: NP22       DATE: 2003-11-04
C
C ABSTRACT: THIS SUBROUTINE PRINTS (TO STDOUT) TWO GIVEN ERROR STRINGS
C   AND THEN CALLS BUFR ARCHIVE LIBRARY SUBROUTINE BORT_EXIT TO ABORT
C   THE APPLICATION PROGRAM CALLING THE BUFR ARCHIVE LIBRARY SOFTWARE.
C   IT IS SIMILAR TO BUFR ARCHIVE LIBRARY SUBROUTINE BORT, EXCEPT BORT
C   PRINTS ONLY ONE ERROR STRING.
C
C PROGRAM HISTORY LOG:
C 2003-11-04  D. KEYSER  -- ORIGINAL AUTHOR
C
C USAGE:    CALL BORT2 (STR1, STR2)
C   INPUT ARGUMENT LIST:
C     STR1     - CHARACTER*(*): FIRST ERROR MESSAGE TO BE PRINTED TO
C                STANDARD OUTPUT
C     STR2     - CHARACTER*(*): SECOND ERROR MESSAGE TO BE PRINTED TO
C                STANDARD OUTPUT
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT_EXIT
C    THIS ROUTINE IS CALLED BY: ELEMDX   PARSEQ   PARUSR   PARUTG
C                               PKC      RDUSDX   SEQSDX   STRING
C                               UFBINT   UFBOVR   UFBREP   UFBSTP
C                               VALX
C                               Normally not called by any application
C                               programs but it could be.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*(*) STR1, STR2
      PRINT*
      PRINT*,'**************BUFR ARCHIVE LIBRARY ABORT*****************'
      PRINT*,STR1
      PRINT*,STR2
      PRINT*,'**************BUFR ARCHIVE LIBRARY ABORT*****************'
      PRINT*
      CALL EXIT(100)
      END
      SUBROUTINE CAPIT(STR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    CAPIT
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2002-05-14
C
C ABSTRACT: THIS SUBROUTINE CAPITALIZES A STRING OF CHARACTERS. THIS
C   ENABLES THE USE OF MIXED CASE IN THE UNIT SECTION OF THE ASCII
C   BUFR TABLES.  AN EXAMPLE: A PROGRAM WHICH GENERATES AN ASCII BUFR
C   TABLE FROM THE "MASTER TABLE B" MIGHT END UP COPYING SOME UNITS
C   FIELDS IN MIXED OR LOWER CASE.  IF THE UNITS ARE 'CODE TABLE' OR
C   'FLAG TABLE' OR CERTAIN OTHER UNIT DESIGNATIONS, THE TABLE WILL BE
C   PARSED INCORRECTLY, AND THE DATA READ OR INCORRECTLY AS A RESULT.
C   THIS MAKES SURE ALL UNIT DESIGNATIONS ARE SEEN BY THE PARSER IN
C   UPPER CASE TO AVOID THESE TYPES OF PROBLEMS.
C
C PROGRAM HISTORY LOG:
C 2002-05-14  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    CALL CAPIT (STR)
C   INPUT ARGUMENT LIST:
C     STR      - CHARACTER*(*): STRING POSSIBLY CONTAINING MIXED UPPER-
C                AND LOWER-CASE CHARACTERS
C
C   OUTPUT ARGUMENT LIST:
C     STR      - CHARACTER*(*): SAME STRING AS INPUT BUT NOW CONTAINING
C                ALL UPPER-CASE CHARACTERS
C
C REMARKS:
C    THIS ROUTINE CALLS:        None
C    THIS ROUTINE IS CALLED BY: ELEMDX   RDBFDX
C                               Normally not called by any application
C                               programs but it could be.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*(*) STR
      CHARACTER*26 UPS,LOS
      DATA UPS/'ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
      DATA LOS/'abcdefghijklmnopqrstuvwxyz'/

      DO 20 I=1,LEN(STR)
      DO 10 J=1,26
      IF(STR(I:I).EQ.LOS(J:J)) THEN
         STR(I:I) = UPS(J:J)
         GOTO 20
      ENDIF
10    CONTINUE
20    CONTINUE

      RETURN
      END
      SUBROUTINE CHEKSTAB(LUN)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    CHEKSTAB
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE CHECKS THAT AN INTERNAL BUFR TABLE
C   REPRESENTATION IS SELF-CONSISTENT AND FULLY DEFINED.  IF ANY ERRORS
C   ARE FOUND, THEN AN APPROPRIATE CALL IS MADE TO BUFR ARCHIVE LIBRARY
C   SUBROUTINE BORT.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1995-06-28  J. WOOLLEN -- INCREASED THE SIZE OF INTERNAL BUFR TABLE
C                           ARRAYS IN ORDER TO HANDLE BIGGER FILES
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL CHEKSTAB (LUN)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     NEMTAB   NEMTBB   NEMTBD
C    THIS ROUTINE IS CALLED BY: MAKESTAB
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MAXTBA=50)
      PARAMETER (MAXTBB=250)
      PARAMETER (MAXTBD=250)

      COMMON /TABABD/ NTBA(0:NFILES),NTBB(0:NFILES),NTBD(0:NFILES),
     .                MTAB(MAXTBA,NFILES),IDNA(MAXTBA,NFILES,2),
     .                IDNB(MAXTBB,NFILES),IDND(MAXTBD,NFILES),
     .                TABA(MAXTBA,NFILES),TABB(MAXTBB,NFILES),
     .                TABD(MAXTBD,NFILES)

      CHARACTER*600 TABD
      CHARACTER*128 TABB
      CHARACTER*128 TABA
      CHARACTER*128 BORT_STR
      CHARACTER*24  UNIT
      CHARACTER*8   NEMO,NEMS(250)
      CHARACTER*1   TAB
      DIMENSION     IRPS(250),KNTS(250)

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  THERE MUST BE ENTRIES IN TABLES A, B, AND D
C  -------------------------------------------

      IF(NTBA(LUN).EQ.0) GOTO 900
      IF(NTBB(LUN).EQ.0) GOTO 901
      IF(NTBD(LUN).EQ.0) GOTO 902

C  MAKE SURE EACH TABLE A ENTRY DEFINED AS A SEQUENCE
C  --------------------------------------------------

      DO I=1,NTBA(LUN)
      NEMO = TABA(I,LUN)(4:11)
      CALL NEMTAB(LUN,NEMO,IDN,TAB,IRET)
      IF(TAB.NE.'D') GOTO 903
      ENDDO

C  CHECK TABLE B CONTENTS
C  ----------------------

      DO ITAB=1,NTBB(LUN)
      CALL NEMTBB(LUN,ITAB,UNIT,ISCL,IREF,IBIT)
      ENDDO

C  CHECK TABLE D CONTNETS
C  ----------------------

      DO ITAB=1,NTBD(LUN)
      CALL NEMTBD(LUN,ITAB,NSEQ,NEMS,IRPS,KNTS)
      ENDDO

C  EXITS
C  -----

      RETURN
900   CALL BORT
     . ('BUFRLIB: CHEKSTAB - EMPTY TABLE A IN INTERNAL BUFR TABLES')
901   CALL BORT
     . ('BUFRLIB: CHEKSTAB - EMPTY TABLE B IN INTERNAL BUFR TABLES')
902   CALL BORT
     . ('BUFRLIB: CHEKSTAB - EMPTY TABLE D IN INTERNAL BUFR TABLES')
903   WRITE(BORT_STR,'("BUFRLIB: CHEKSTAB - TABLE A ENTRY: ",A," NOT '//
     . 'DEFINED AS A SEQUENCE")') NEMO
      CALL BORT(BORT_STR)
      END
      SUBROUTINE CHRTRN(STR,CHR,N)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    CHRTRN
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE COPIES A SPECIFIED NUMBER OF CHARACTERS
C   FROM A CHARACTER ARRAY INTO A CHARACTER STRING.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION
C
C USAGE:    CALL CHRTRN (STR, CHR, N)
C   INPUT ARGUMENT LIST:
C     CHR      - CHARACTER*1: N-WORD CHARACTER ARRAY
C     N        - INTEGER: NUMBER OF CHARACTERS TO COPY
C
C   OUTPUT ARGUMENT LIST:
C     STR      - CHARACTER*(*): CHARACTER STRING
C
C REMARKS:
C    THIS ROUTINE CALLS:        None
C    THIS ROUTINE IS CALLED BY: RDBFDX
C                               Normally not called by any application
C                               programs but it could be.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*(*) STR
      CHARACTER*1   CHR(N)

C----------------------------------------------------------------------
C----------------------------------------------------------------------
      DO I=1,N
      STR(I:I) = CHR(I)
      ENDDO
      RETURN
      END
      SUBROUTINE CHRTRNA(STR,CHR,N)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    CHRTRNA
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE COPIES A SPECIFIED NUMBER OF CHARACTERS
C   FROM A CHARACTER ARRAY INTO A CHARACTER STRING.  THE DIFFERENCE
C   BETWEEN THIS SUBROUTINE AND BUFR ARCHIVE LIBRARY SUBROUTINE CHRTRN
C   IS THAT, IN THIS SUBROUTINE, THE INPUT CHARACTER ARRAY IS ASSUMED
C   TO BE IN ASCII; THUS, FOR CASES WHERE THE NATIVE MACHINE IS EBCDIC,
C   AN ASCII TO EBCDIC TRANSLATION IS DONE ON THE FINAL STRING BEFORE
C   IT IS OUTPUT.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION
C
C USAGE:    CALL CHRTRNA (STR, CHR, N)
C   INPUT ARGUMENT LIST:
C     CHR      - CHARACTER*1: N-WORD CHARACTER ARRAY IN ASCII
C     N        - INTEGER: NUMBER OF CHARACTERS TO COPY
C
C   OUTPUT ARGUMENT LIST:
C     STR      - CHARACTER*(*): CHARACTER STRING IN ASCII OR EBCDIC,
C                DEPENDING ON NATIVE MACHINE
C
C REMARKS:
C    THIS ROUTINE CALLS:        IPKM     IUPM
C    THIS ROUTINE IS CALLED BY: RDBFDX   READFT   READMG
C                               Normally not called by any application
C                               programs but it could be with COMMON
C                               block /CHARAC/.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /CHARAC/ IASCII,IATOE(0:255),IETOA(0:255)

      CHARACTER*(*) STR
      CHARACTER*1   CHR(N)

C----------------------------------------------------------------------
C----------------------------------------------------------------------

C     Loop on N characters of CHR

      DO I=1,N
      STR(I:I) = CHR(I)

C     If this is an EBCDIC machine, then translate the character
C     from ASCII -> EBCDIC.

      IF(IASCII.EQ.0) CALL IPKM(STR(I:I),1,IATOE(IUPM(STR(I:I),8)))
      ENDDO
      RETURN
      END
      SUBROUTINE CKTABA(LUN,SUBSET,JDATE,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    CKTABA
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2000-09-19
C
C ABSTRACT: THIS SUBROUTINE PARSES THE TABLE A MNEMONIC AND THE DATE
C   OUT OF SECTION 1 OF A BUFR MESSAGE PREVIOUSLY READ FROM UNIT LUNIT
C   USING BUFR ARCHIVE LIBRARY SUBROUTINE READMG OR EQUIVALENT (AND NOW
C   STORED IN THE INTERNAL MESSAGE BUFFER, ARRAY MBAY IN COMMON BLOCK
C   /BITBUF/).  THE TABLE A MNEMONIC IS ASSOCIATED WITH THE BUFR
C   MESSAGE TYPE/SUBTYPE IN SECTION 1.  IT ALSO FILLS IN THE MESSAGE
C   CONTROL WORD PARTITION ARRAYS IN COMMON BLOCK /MSGCWD/.
C
C PROGRAM HISTORY LOG:
C 2000-09-19  J. WOOLLEN -- ORIGINAL AUTHOR (CONSOLIDATED MESSAGE
C                           DECODING LOGIC THAT HAD BEEN REPLICATED IN
C                           READMG, READFT, READTJ, READERM, READERME,
C                           RDMEMM AND READIBM - CKTABA IS NOW CALLED
C                           BY THESE CODES; LOGIC ENHANCED HERE TO
C                           ALLOW COMPRESSED AND STANDARD BUFR MESSAGES
C                           TO BE READ)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MODIFIED TO NOT ABORT WHEN THE SECTION 1
C                           MESSAGE SUBTYPE DOES NOT AGREE WITH THE
C                           SECTION 1 MESSAGE SUBTYPE IN THE DICTIONARY
C                           IF THE MESSAGE TYPE MNEMONIC IS NOT OF THE
C                           FORM "NCtttsss", WHERE ttt IS THE BUFR TYPE
C                           AND sss IS THE BUFR SUBTYPE (E.G., IN
C                           "PREPBUFR" FILES); MODIFIED DATE
C                           CALCULATIONS TO NO LONGER USE FLOATING
C                           POINT ARITHMETIC SINCE THIS CAN LEAD TO
C                           ROUND OFF ERROR AND AN IMPROPER RESULTING
C                           DATE ON SOME MACHINES (E.G., NCEP IBM
C                           FROST/SNOW), INCREASES PORTABILITY;
C                           UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY OR UNUSUAL THINGS
C                           HAPPEN; SUBSET DEFINED AS "        " IF
C                           IRET RETURNED AS 11 (BEFORE WAS UNDEFINED)
C
C USAGE:    CALL CKTABA (LUN, SUBSET, JDATE, IRET)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C
C   OUTPUT ARGUMENT LIST:
C     SUBSET   - CHARACTER*8: TABLE A MNEMONIC FOR TYPE OF BUFR MESSAGE
C                BEING CHECKED
C              "        " = IRET equal to 11 (see IRET below)
C     JDATE    - INTEGER: DATE-TIME STORED WITHIN SECTION 1 OF BUFR
C                MESSAGE BEING CHECKED, IN FORMAT OF EITHER YYMMDDHH OR
C                YYYYMMDDHH, DEPENDING ON DATELEN() VALUE 
C     IRET     - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = unrecognized Table A (message type) value
C                      11 = this is a BUFR table (dictionary) message
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     DIGIT    I4DY     IUPB
C                               NEMTBAX  NUMTAB   OPENBT   RDUSDX
C    THIS ROUTINE IS CALLED BY: RDMEMM   READERM  READERME READFT
C                               READIBM  READMG   READMM
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /PADESC/ IBCT,IPD1,IPD2,IPD3,IPD4
      COMMON /UNPTYP/ MSGUNP(NFILES)
      COMMON /DATELN/ LENDAT
      COMMON /QUIET / IPRT

      CHARACTER*128 BORT_STR
      CHARACTER*8   SUBSET
      CHARACTER*1   TAB
      LOGICAL       TRYBT, DIGIT

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      TRYBT = .TRUE.

C  PARSE SECTION 1
C  ---------------

      IAD1 = 8
      LEN1 = IUPB(MBAY(1,LUN),IAD1+ 1,24)
      LEN2 = IUPB(MBAY(1,LUN),IAD1+ 8, 1)
c  .... Message type
      MTYP = IUPB(MBAY(1,LUN),IAD1+ 9, 8)
c  .... Message subtype
      MSBT = IUPB(MBAY(1,LUN),IAD1+10, 8)
      MEAR = MOD(IUPB(MBAY(1,LUN),IAD1+13, 8),100)
      MMON = IUPB(MBAY(1,LUN),IAD1+14, 8)
      MDAY = IUPB(MBAY(1,LUN),IAD1+15, 8)
      MOUR = IUPB(MBAY(1,LUN),IAD1+16, 8)
      MMIN = IUPB(MBAY(1,LUN),IAD1+17, 8)
      MCEN = MAX(0,IUPB(MBAY(1,LUN),IAD1+18, 8)-MIN(MEAR,1))

      IF(LENDAT.EQ.10) THEN
         JDATE = MCEN*100000000+MEAR*1000000+MMON*10000+MDAY*100+MOUR
         JDATE = I4DY(JDATE)
      ELSE
         JDATE = MEAR*1000000+MMON*10000+MDAY*100+MOUR
      ENDIF

C  DON'T PARSE BUFR TABLE (DICTIONARY) MESSAGES
C  --------------------------------------------

      IF(MTYP.EQ.11) THEN
         IF(IPRT.GE.2)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
            PRINT*,'BUFRLIB: CKTABA - TABLE A VALUE IS 11 (THIS IS A ',
     .       'BUFR TABLE DICTIONARY MESSAGE) - RETURN WITH IRET = 11'
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT*
         ENDIF

C  Return with IRET=1 and SUBSET all blanks
C  ----------------------------------------

         IRET = 11
         SUBSET = "        "
         GOTO 100
      ENDIF

C  PARSE SECTION 2
C  ---------------

      IAD2 = IAD1+LEN1
      LEN2 = IUPB(MBAY(1,LUN),IAD2+1,24) * LEN2

C  PARSE SECTION 3
C  ---------------

      IAD3 = IAD2+LEN2
      LEN3 = IUPB(MBAY(1,LUN),IAD3+1 ,24)
c  .... Number of subsets in msg
      JSUB = IUPB(MBAY(1,LUN),IAD3+5 ,16)
c  .... Compression indicator
      NCMP = IUPB(MBAY(1,LUN),IAD3+7 ,8 )
c  .... First descriptor (integer)
      KSUB = IUPB(MBAY(1,LUN),IAD3+8 ,16)
c  .... Second descriptor (integer)
      ISUB = IUPB(MBAY(1,LUN),IAD3+10,16)

C  LOCATE SECTION 4
C  ----------------

      IAD4 = IAD3+LEN3
      LEN4 = IUPB(MBAY(1,LUN),IAD4+1,24)

C  NOW, TRY TO GET "SUBSET" (MNEMONIC ASSOCIATED WITH TABLE A) FROM MSG
C  --------------------------------------------------------------------

C  IF ISUB FROM SECTION 3 DEFINES TABLE A THEN MSGUNP=0
C  ----------------------------------------------------

c  .... get SUBSET from ISUB
5     CALL NUMTAB(LUN,ISUB,SUBSET,TAB,ITAB)
c  .... is SUBSET from Tbl A?
      CALL NEMTBAX(LUN,SUBSET,MTY1,MSB1,INOD)
c  .... yes it is
      IF(INOD.GT.0) THEN
         MBYT(LUN) = (IAD4+4)
         MSGUNP(LUN) = 0
         GOTO 10
      ENDIF

C  IF KSUB FROM SECTION 3 DEFINES TABLE A THEN MSGUNP=1 (standard)
C  ---------------------------------------------------------------

c  .... get SUBSET from KSUB
      CALL NUMTAB(LUN,KSUB,SUBSET,TAB,ITAB)
c  .... is SUBSET from Tbl A?
      CALL NEMTBAX(LUN,SUBSET,MTY1,MSB1,INOD)
c  .... yes it is
      IF(INOD.GT.0) THEN
         MBYT(LUN) = 8*(IAD4+4)
         MSGUNP(LUN) = 1
         GOTO 10
      ENDIF

C  OKAY, STILL NO "SUBSET", LETS MAKE IT "NCtttsss" (where ttt=MTYP
C  and sss=MSBT) AND SEE IF IT DEFINES TABLE A
C  ----------------------------------------------------------------

      WRITE(SUBSET,'("NC",2I3.3)') MTYP,MSBT
c  .... is SUBSET from Tbl A?
      CALL NEMTBAX(LUN,SUBSET,MTY1,MSB1,INOD)
c  .... yes it is, and KSUB byte count descr.
      IF(INOD.GT.0 .AND. KSUB.EQ.IBCT) THEN
         MBYT(LUN) = (IAD4+4)
         MSGUNP(LUN) = 0
         GOTO 10
      ELSEIF(INOD.GT.0) THEN
c  .... yes it is
         MBYT(LUN) = 8*(IAD4+4)
         MSGUNP(LUN) = 1
         GOTO 10
      ENDIF

C  NOW WE HAVE A GENERATED "SUBSET", BUT IT STILL DOES NOT DEFINE
C  TABLE A - MAKE ONE LAST DESPERATE ATTEMPT - SEE IF AN EXTERNAL
C  USER-SUPPLIED BUFR DICTIONARY TABLE IN CHARACTER FORMAT IS DEFINED
C  IN OPENBT (ONLY POSSIBLE IF APPLICATION PROGRAM HAS AN IN-LINE
C  OPENBT OVERRIDING THE ONE IN THE BUFR ARCHIVE LIBRARY)
C  ------------------------------------------------------------------

      IF(TRYBT) THEN
         TRYBT = .FALSE.
         IF(IPRT.GE.1) THEN
      PRINT*
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
            PRINT*, 'NUFRLIB: CKTABA - LAST RESORT, CHECK FOR EXTERNAL',
     .       ' BUFR TABLE VIA CALL TO IN-LINE OPENBT'
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT*
         ENDIF
         CALL OPENBT(LUNDX,MTYP)
c  .... Good news, there is unit no. (LUNDX) connected to a table file
         IF(LUNDX.GT.0) THEN
c  .... Store the table internally
            CALL RDUSDX(LUNDX,LUN)
            GOTO 5
         ENDIF
      ENDIF

C  IF ALL ATTEMPTS TO DEFINE TABLE A FAIL SKIP GIVE UP
C  ---------------------------------------------------

      IF(IPRT.GE.0)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*,'BUFRLIB: CKTABA - UNRECOGNIZED TABLE A MESSAGE TYPE (',
     . SUBSET, ') - RETURN WITH IRET = -1'
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
      ENDIF
      IRET = -1
      GOTO 100

C  CHECK THE VALIDITY OF THE MTYP/MSBT AND FOR COMPRESSION (MSGUNP=2)
C  ------------------------------------------------------------------

10    CONTINUE
      IF(MTYP.NE.MTY1) GOTO 900
      IF(MSBT.NE.MSB1.AND.DIGIT(SUBSET(3:8))) GOTO 901
      IF(IAND(NCMP,64).GT.0) MSGUNP(LUN) = 2

C  SET THE OTHER REQUIRED PARAMETERS IN MESSAGE CONTROL WORD PARTITION
C  -------------------------------------------------------------------

c  .... Date for this message
      IDATE(LUN) = I4DY(JDATE)
c  .... Number of messages so far in file
      NMSG (LUN) = NMSG(LUN)+1
c  .... Positional index of Table A mnem.
      INODE(LUN) = INOD
c  .... Number of subsets in this message
      MSUB (LUN) = JSUB
c  .... Number of subsets actually read so far
      NSUB (LUN) = 0

c  .... Return successfully
      IRET = 0

C  EXITS
C  -----

100   RETURN
900   WRITE(BORT_STR,'("BUFRLIB: CKTABA - MESSAGE TYPE MISMATCH '//
     . '(SUBSET=",A8,", MTYP=",I3,", MTY1=",I3)') SUBSET,MTYP,MTY1
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: CKTABA - MESSAGE SUBTYPE MISMATCH '//
     . '(SUBSET=",A8,", MSBT=",I3,", MSB1=",I3)') SUBSET,MSBT,MSB1
      CALL BORT(BORT_STR)
      END
      SUBROUTINE CLOSBF(LUNIT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    CLOSBF
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE IS CALLED IN ORDER TO TERMINATE BUFR
C   ARCHIVE LIBRARY SOFTWARE ACCESS TO A LOGICAL UNIT LUNIT FOR INPUT
C   OR OUTPUT OPERATIONS (PREVIOUSLY OPENED BY A FORTRAN "OPEN" ON THE
C   LOGICAL UNIT AND BY BUFR ARCHIVE LIBRARY SUBROUTINE OPENBF).
C   CLOSBF MUST BE CALLED WHEN LUNIT IS CONNECTED TO A BUFR FILE OPEN
C   FOR OUTPUT IN ORDER TO PROPERLY CLOSE AND WRITE ANY CURRENT BUFR
C   MESSAGE WHICH MAY STILL EXIST IN INTERNAL MEMORY (AND MOST LIKELY
C   NOT BE FULL).  IT IS NOT MANDATORY THAT CLOSBF BE CALLED WHEN LUNIT
C   IS CONNECTED TO A BUFR FILE OPEN FOR INPUT, BUT IT IS STILL A GOOD
C   IDEA TO DO SO.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  J. ATOR    -- DON'T CLOSE LUNIT IF OPENED AS A NULL FILE
C                           BY OPENBF {NULL(LUN) = 1 IN NEW COMMON
C                           BLOCK /NULBFR/} (WAS IN DECODER VERSION)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    CALL CLOSBF (LUNIT)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   INPUT FILES:
C     UNIT "LUNIT"  - BUFR FILE
C
C   OUTPUT FILES:
C     UNIT "LUNIT"  - BUFR FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        CLOSMG   STATUS   WTSTAT
C    THIS ROUTINE IS CALLED BY: UFBINX   UFBMEM   UFBTAB
C                               Also called by application programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)

      COMMON /NULBFR/ NULL(NFILES)

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.GT.0 .AND. IM.NE.0) CALL CLOSMG(LUNIT)
      CALL WTSTAT(LUNIT,LUN,0,0)

C  CLOSE LUNIT IF NULL(LUN) = 0
C  ----------------------------

      IF(NULL(LUN).EQ.0) CLOSE(LUNIT)

      RETURN
      END
      SUBROUTINE CLOSMG(LUNIT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    CLOSMG
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE SHOULD ONLY BE CALLED WHEN LOGICAL UNIT
C   LUNIT HAS BEEN OPENED FOR OUTPUT OPERATIONS.  IT CLOSES A BUFR
C   MESSAGE PREVIOUSLY OPENED BY EITHER BUFR ARCHIVE LIBRARY
C   SUBROUTINES OPENMG OR OPENMB AND WRITES IT TO THE UNIT LUNIT.
C   SINCE OPENMG AND OPENMB NORMALLY CALL THIS INTERNALLY, IT IS NOT
C   CALLED TOO OFTEN FROM AN APPLICATION PROGRAM.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2003-05-19  J. WOOLLEN -- CORRECTED A PROBLEM INTRODUCED IN A
C                           PREVIOUS (MAY 2002) IMPLEMENTATION WHICH
C                           PREVENTED THE DUMP CENTER TIME AND
C                           INTITIATION TIME MESSAGES FROM BEING
C                           WRITTEN OUT (THIS AFFECTED APPLICATION
C                           PROGRAM BUFR_DUMPMD, IF IT WERE RECOMPILED,
C                           IN THE DATA DUMPING PROCESS)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL CLOSMG (LUNIT)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     MSGWRT   STATUS   WRCMPS
C                               WTSTAT
C    THIS ROUTINE IS CALLED BY: CLOSBF   OPENMB   OPENMG   WRITSA
C                               WRITST
C                               Also called by application programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.LT.0) GOTO 901
      IF(IM.NE.0) THEN
         IF(NSUB(LUN).GT.0) THEN
            CALL MSGWRT(LUNIT,MBAY(1,LUN),MBYT(LUN))
         ELSE IF(NSUB(LUN).EQ.0.AND.NMSG(LUN).LT.3) THEN
            CALL MSGWRT(LUNIT,MBAY(1,LUN),MBYT(LUN))
         ELSE IF(NSUB(LUN).LT.0) THEN
            CALL WRCMPS(-LUNIT)
         ENDIF
      ENDIF
      CALL WTSTAT(LUNIT,LUN,IL,0)

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: CLOSMG - OUTPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR OUTPUT')
901   CALL BORT('BUFRLIB: CLOSMG - OUTPUT BUFR FILE IS OPEN FOR '//
     . 'INPUT, IT MUST BE OPEN FOR OUTPUT')
      END
      SUBROUTINE CMSGINI(LUN,MESG,SUBSET,IDATE,NSUB,NBYT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    CMSGINI
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2002-05-14
C
C ABSTRACT: THIS SUBROUTINE INITIALIZES A NEW BUFR MESSAGE FOR OUTPUT
C   IN COMPRESSED BUFR.  THE ACTUAL LENGTH OF SECTION 4 (CONTAINING
C   COMPRESSED DATA) IS ALREADY KNOWN.
C
C PROGRAM HISTORY LOG:
C 2002-05-14  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY; LEN3 INITIALIZED AS
C                           ZERO (BEFORE WAS UNDEFINED WHEN FIRST
C                           REFERENCED)
C
C USAGE:    CALL CMSGINI (LUN, MESG, SUBSET, IDATE, NSUB, NBYT)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     SUBSET   - CHARACTER*8: TABLE A MNEMONIC FOR TYPE OF BUFR MESSAGE
C                BEING WRITTEN 
C     IDATE    - INTEGER: DATE-TIME STORED WITHIN SECTION 1 OF BUFR
C                MESSAGE BEING WRITTEN, IN FORMAT OF EITHER YYMMDDHH OR
C                YYYYMMDDHH, DEPENDING ON DATELEN() VALUE
C     NSUB     - INTEGER: NUMBER OF SUBSETS, STORED IN SECTION 3 OF
C                BUFR MESSAGE BEING WRITTEN
C     NBYT     - INTEGER: ACTUAL LENGTH OF SECTION 4 (IN BYTES) BASED
C                ON COMPRESSED DATA
C
C   OUTPUT ARGUMENT LIST:
C     MESG     - INTEGER: *-WORD PACKED BINARY ARRAY CONTAINING BUFR
C                MESSAGE
C     NBYT     - INTEGER: ACTUAL LENGTH OF BUFR MESSAGE (IN BYTES) UP
C                TO THE POINT IN SECTION 4 WHERE COMPRESSED DATA ARE
C                TO BE WRITTEN 
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     I4DY     NEMTAB   NEMTBA
C                               PKB      PKC
C    THIS ROUTINE IS CALLED BY: COMPRES  WRCMPS
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MXMSGL=20000)

      CHARACTER*128 BORT_STR
      CHARACTER*8   SUBSET
      CHARACTER*4   BUFR
      CHARACTER*1   TAB
      DIMENSION     MESG(*)

      DATA BUFR/'BUFR'/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  GET THE MESSAGE TAG AND TYPE, AND BREAK UP THE DATE
C  ---------------------------------------------------

c  .... Given SUBSET, NEMTBA returns MTYP,MSBT,INOD
      CALL NEMTBA(LUN,SUBSET,MTYP,MSBT,INOD)
      CALL NEMTAB(LUN,SUBSET,ISUB,TAB,IRET)
      IF(IRET.EQ.0) GOTO 900

C  DATE CAN BE YYMMDDHH OR YYYYMMDDHH
C  ----------------------------------

      JDATE = I4DY(IDATE)
      MCEN = MOD(JDATE/10**8,100)+1
      MEAR = MOD(JDATE/10**6,100)
      MMON = MOD(JDATE/10**4,100)
      MDAY = MOD(JDATE/10**2,100)
      MOUR = MOD(JDATE      ,100)
      MMIN = 0

c  .... DK: Don't think this can happen, because IDATE=0 is returned
c           as 2000000000 by I4DY meaning MCEN would be 21
      IF(MCEN.EQ.1) GOTO 901

      IF(MEAR.EQ.0) MCEN = MCEN-1
      IF(MEAR.EQ.0) MEAR = 100

C  INITIALIZE THE MESSAGE
C  ----------------------

      LEN3 = 0

c  Section    0    1      3      4    5
c  -------   --   --   ----   ----   --
      MBYT =  8 + 18 + LEN3 + NBYT +  4
c  .... Note: MBYT will be recalulated at the end of this subroutine

      MBIT = 0

C  SECTION 0
C  ---------

      CALL PKC(BUFR ,  4 , MESG,MBIT)
      CALL PKB(MBYT , 24 , MESG,MBIT)
      CALL PKB(   3 ,  8 , MESG,MBIT)

C  SECTION 1
C  ---------

      CALL PKB(  18 , 24 , MESG,MBIT)
      CALL PKB(   0 ,  8 , MESG,MBIT)
      CALL PKB(   3 ,  8 , MESG,MBIT)
      CALL PKB(   7 ,  8 , MESG,MBIT)
      CALL PKB(   0 ,  8 , MESG,MBIT)
      CALL PKB(   0 ,  8 , MESG,MBIT)
      CALL PKB(MTYP ,  8 , MESG,MBIT)
      CALL PKB(MSBT ,  8 , MESG,MBIT)
      CALL PKB(   4 ,  8 , MESG,MBIT)
      CALL PKB(   0 ,  8 , MESG,MBIT)
      CALL PKB(MEAR ,  8 , MESG,MBIT)
      CALL PKB(MMON ,  8 , MESG,MBIT)
      CALL PKB(MDAY ,  8 , MESG,MBIT)
      CALL PKB(MOUR ,  8 , MESG,MBIT)
      CALL PKB(MMIN ,  8 , MESG,MBIT)
      CALL PKB(MCEN ,  8 , MESG,MBIT)

C  SECTION 3
C  ---------

      LEN3 = 3+1+2+1+2+1
      CALL PKB(LEN3 , 24 , MESG,MBIT)
      CALL PKB(   0 ,  8 , MESG,MBIT)
      CALL PKB(NSUB , 16 , MESG,MBIT)
      CALL PKB( 192 ,  8 , MESG,MBIT)
      CALL PKB(ISUB , 16 , MESG,MBIT)
      CALL PKB(   0 ,  8 , MESG,MBIT)

C  SECTION 4
C  ---------

      CALL PKB(NBYT , 24 , MESG,MBIT)
      CALL PKB(   0 ,  8 , MESG,MBIT)

C  SECTION 5 - FILLED IN LATER
C  ---------------------------


C  RETURN WITH THE CORRECT NEW MESSAGE BYTE COUNT
C  ----------------------------------------------

      MBYT = MBIT/8+NBYT
      NBYT = MBIT/8
      MBIT = 32
c  .... DK: MBYT doesn't seem to include 4 bytes in Section 5 ?????
      CALL PKB(MBYT,24,MESG,MBIT)

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: CMSGINI - TABLE A MESSAGE TYPE '//
     . 'MNEMONIC ",A," NOT FOUND IN INTERNAL TABLE D ARRAYS")') SUBSET
      CALL BORT(BORT_STR)
901   CALL BORT
     . ('BUFRLIB: CMSGINI - BUFR MESSAGE DATE (IDATE) is 0000000000')
      END
      SUBROUTINE COMPRES(LUNIT,SUBSET,IDATE,MESG,NBYT,NRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    COMPRES
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2003-11-04
C
C ABSTRACT: THIS SUBROUTINE COMPRESSES SUBSETS IN BUFR MESSAGES
C   PREVIOUSLY READ FROM LUNIT USING READMG OR EQUIVALENT (WITH EACH
C   MESSAGE STORED IN THE INTERNAL MESSAGE BUFFER, ARRAY MBAY IN COMMON
C   BLOCK /BITBUF/).  IT THEN GENERATES A NEW BUFR MESSAGE CONSISTING
C   OF THE COMPRESSED SUBSETS.  NOTE THAT SUBSETS IN THE OUTPUT
C   COMPRESSED MESSAGE MAY HAVE BEEN READ FROM DIFFERENT (ADJACENT)
C   INPUT MESSAGES.
C
C PROGRAM HISTORY LOG:
C 2003-11-04  J. WOOLLEN -- ORIGINAL AUTHOR (WAS IN-LINE IN PROGRAM
C                           BUFR_COMPRESS)
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY OR UNUSUAL THINGS HAPPEN
C
C USAGE:    CALL COMPRES (LUNIT, SUBSET, IDATE, MESG, NBYT, NRET)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     SUBSET   - CHARACTER*8: TABLE A MNEMONIC FOR TYPE OF BUFR MESSAGE
C                BEING COMPRESSED
C     IDATE    - INTEGER: DATE-TIME STORED WITHIN SECTION 1 OF BUFR
C                MESSAGE BEING COMPRESSED, IN FORMAT OF EITHER YYMMDDHH
C                OR YYYYMMDDHH, DEPENDING ON DATELEN() VALUE
C
C   OUTPUT ARGUMENT LIST:
C     MESG     - INTEGER: *-WORD PACKED BINARY ARRAY CONTAINING
C                COMPRESSED BUFR MESSAGE (MUST BE NO GREATER THAN
C                MXMSGL/4 WORDS)
C     NBYT     - INTEGER: LENGTH OF COMPRESSED BUFR MESSAGE (IN BYTES)
C     NRET     - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = there are no more BUFR messages in LUNIT
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     CMSGINI  IREADMG  IUPB
C                               LMSG     PKB      PKC      READ2C
C                               READMG   STATUS
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MROW=4000)
      PARAMETER (MCOL=1000)
      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)
 
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /MATRIX/ NROW,NCOL,MATX(MROW,MCOL),CATX(MROW,MCOL)
      COMMON /REDWRT/ READIT,WRITIT
      COMMON /REMEM/  ITYP(MROW),IWID(MROW),KMIN(MROW),KMAX(MROW),
     .                KBIT(MROW)
 
      CHARACTER*128 BORT_STR
      CHARACTER*8   SUBSET,SUBNEW,CATX,SEC0
      DIMENSION     MESG(*),IEC0(2)
      LOGICAL       READIT,WRITIT
      REAL*8        BMISS

      EQUIVALENCE (SEC0,IEC0)

      DATA SUBNEW /' '/
      DATA IDNEW  /0/
      DATA BMISS  /10E10/
 
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  MAKE SURE WE ARE READY FOR THE NEXT ROUND
C  -----------------------------------------
 
      SUBNEW = SUBSET
      IDNEW  = IDATE
 
      RLN2 = 1./LOG(2.)
      WRITIT = .FALSE.
      NBYT = 0
      NRET = 0
      NROW = 0
      NCOL = 0
 
C  CHECK THE INPUT FILE STATUS
C  ---------------------------
 
      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      IF(IM.EQ.0) GOTO 902
 
C  LOOK AT THE NEXT SUBSET TO COMPRESS
C  -----------------------------------
 
10    IF(NCOL+1.LE.MCOL) THEN
         NCOL = NCOL+1
11       CALL READ2C(LUN,MROW,MATX(1,NCOL),CATX(1,NCOL),ITYP,IWID,IRET)
         IF(IRET.EQ.-1) THEN
            IF(IREADMG(LUNIT,SUBNEW,IDNEW).NE.0) THEN
               WRITIT = .TRUE.
               NCOL = NCOL-1
               NRET = -1
            ELSEIF(SUBNEW.NE.SUBSET.OR.IDNEW.NE.IDATE) THEN
               WRITIT = .TRUE.
               NCOL = NCOL-1
            ELSE
               GOTO 11
            ENDIF
c  .... DK: The following IF branch is never reached because READ2C
c           can no longer return with IRET=-2
         ELSEIF(IRET.EQ.-2) THEN
            NBYT = IUPB(MBAY(1,LUN),5,24)
            IEC0(1) = MBAY(1,LUN)
            IEC0(2) = MBAY(2,LUN)
            DO I=1,LMSG(SEC0)
            MESG(I) = MBAY(I,LUN)
            ENDDO
            CALL READMG(LUNIT,SUBSET,IDATE,NRET)
            GOTO 100
         ELSE
            NROW = IRET
         ENDIF
      ELSE
         WRITIT = .TRUE.
      ENDIF
 
C  COMPUTE THE MIN,MAX,WIDTH FOR EACH ROW - ACCUMULATE LENGTH
C  ----------------------------------------------------------
 
20    LDATA = 32
      IF(NCOL.GE.LCOL) ICOL = NCOL
      IF(NCOL.LT.LCOL) ICOL = 1
      LCOL = NCOL
      DO I=1,NROW
      IF(ITYP(I).EQ.1 .OR. ITYP(I).EQ.2) THEN
         IF(ICOL.EQ.1 .OR. NCOL.EQ.1) THEN
            KMIN(I) = BMISS
            KMAX(I) = 0
         ENDIF
         DO J=ICOL,NCOL
         IF(MATX(I,J).LT.2**IWID(I)-1) THEN
            KMIN(I) = MIN(KMIN(I),MATX(I,J))
            KMAX(I) = MAX(KMAX(I),MATX(I,J))
         ELSE
            KMAX(I) = BMISS          
         ENDIF
         ENDDO
         IF(KMIN(I).EQ.BMISS) THEN
            KMAX(I) = BMISS          
         ELSE
            KMAX(I) = MIN(2**IWID(I)-1,KMAX(I))
         ENDIF
         RANGE = KMAX(I)-KMIN(I)+1
         IF(RANGE.GT.1.AND.ITYP(I).EQ.2) THEN
            KBIT(I) = NINT(LOG(RANGE)*RLN2)
            IF(2**KBIT(I)-1.LT.RANGE) KBIT(I) = KBIT(I)+1
         ELSEIF(RANGE.GT.1.AND.ITYP(I).EQ.1) THEN
            GOTO 903
         ELSE
            KBIT(I) = 0
         ENDIF
         LDATA = LDATA + IWID(I) + 6 + NCOL*KBIT(I)
      ELSEIF(ITYP(I).EQ.3) THEN
         LDATA = LDATA + IWID(I) + 6 + NCOL*IWID(I)
      ENDIF
      ENDDO
 
C  ROUND DATA LENGTH UP TO A WHOLE EVEN BYTE COUNT
C  -----------------------------------------------
 
      IBYT = (LDATA+8-MOD(LDATA,8))/8
      IF(MOD(IBYT,2).NE.0) IBYT = IBYT+1
      JBIT = IBYT*8-LDATA
 
C  CHECK ON THE UPDATED COMPRESSED MESSAGE LENGTH
C  ----------------------------------------------
 
      IF(IBYT+50.GT.MAXBYT) THEN
         READIT = .FALSE.
         WRITIT = .TRUE.
         NCOL = NCOL-1
         GOTO 20
      ELSEIF(.NOT.WRITIT) THEN
         GOTO 10
      ENDIF
 
C  WRITE THE COMPLETE COMPRESSED MESSAGE
C  -------------------------------------
 
      CALL CMSGINI(LUN,MESG,SUBSET,IDATE,NCOL,IBYT)
      IBIT = IBYT*8
      DO I=1,NROW
      IF(ITYP(I).EQ.1.OR.ITYP(I).EQ.2) THEN
         CALL PKB(KMIN(I),IWID(I),MESG,IBIT)
         CALL PKB(KBIT(I),      6,MESG,IBIT)
         IF(KBIT(I).GT.0) THEN
            DO J=1,NCOL
            INCR = MATX(I,J)-KMIN(I)
            CALL PKB(INCR,KBIT(I),MESG,IBIT)
            ENDDO
         ENDIF
      ELSEIF(ITYP(I).EQ.3) THEN
         NCHR = IWID(I)/8
         CALL PKB(   0,IWID(I),MESG,IBIT)
         CALL PKB(NCHR,      6,MESG,IBIT)
         DO J=1,NCOL
         CALL PKC(CATX(I,J),NCHR,MESG,IBIT)
         ENDDO
      ENDIF
      ENDDO
 
C  FILL IN THE END OF THE MESSAGE
C  ------------------------------
 
      CALL PKB(     0,JBIT,MESG,IBIT)
      CALL PKC('7777',   4,MESG,IBIT)
 
C  SEE THAT THE MESSAGE BYTE COUNTERS AGREE
C  ----------------------------------------
 
      LBYT = IUPB(MESG,5,24)
      NBYT = IBIT/8
      IF(NBYT.NE.LBYT) GOTO 904
      IF(MOD(IBIT,8).NE.0) GOTO 905

C  RESET
C  -----
 
      SUBSET = SUBNEW
      IDATE = IDNEW

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: COMPRES - INPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: COMPRES - INPUT BUFR FILE IS OPEN FOR '//
     . 'OUTPUT, IT MUST BE OPEN FOR INPUT')
902   CALL BORT('BUFRLIB: COMPRES - A MESSAGE MUST BE OPEN IN INPUT '//
     . 'BUFR FILE, NONE ARE')
903   CALL BORT('BUFRLIB: COMPRES - NON-STANDARD DELAYED REPLICATION')
904   WRITE(BORT_STR,'("BUFRLIB: COMPRES - INPUT MESSAGE LENGTH FROM '//
     . 'SECTION 0",I6," DOES NOT EQUAL SUM OF ALL INDIVIDUAL SECTION '//
     . 'LENGTHS (",I6,")")') LBYT,NBYT
      CALL BORT(BORT_STR)
905   CALL BORT('BUFRLIB: COMPRES - COMPRESSED MESSAGE DOES NOT END '//
     . 'ON A BYTE BOUNDARY')
      END
      SUBROUTINE CONWIN(LUN,INC1,INC2,NBMP)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    CONWIN (docblock incomplete)
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE ....
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- IMPROVED MACHINE PORTABILITY
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY) (INCOMPLETE)
C
C USAGE:    CALL CONWIN (LUN, INC1, INC2, NBMP)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     INC1     - INTEGER: ....
C     INC2     - INTEGER: ....
C     NBMP     - INTEGER: ....
C
C   OUTPUT ARGUMENT LIST:
C     INC1     - INTEGER: ....
C     INC2     - INTEGER: ....
C
C REMARKS:
C    THIS ROUTINE CALLS:        GETWIN   INVCON   INVWIN   NEWWIN
C                               NXTWIN   USRTPL
C    THIS ROUTINE IS CALLED BY: UFBEVN   UFBIN3   UFBRW
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /USRSTR/ NNOD,NCON,NODS(20),NODC(10),IVLS(10),KONS(10)

      REAL*8 VAL

C----------------------------------------------------------------------
C----------------------------------------------------------------------

C  SPECIAL CASES
C  -------------

c  .... There are no condition nodes in string
      IF(NCON.EQ.0) THEN
         INC1 = 1
         INC2 = NVAL(LUN)
         GOTO 100
      ENDIF

c  .... BUMP node
      IF(INC1.GT.1 .AND. KONS(NCON).EQ.5) THEN
         CALL NXTWIN(LUN,INC1,INC2)
         GOTO 100
      ENDIF

C  EVALUATE CONDITIONS TO SEE IF ANY MORE CASES
C  --------------------------------------------

10    DO NC=1,NCON
      IF(KONS(NC).EQ.5) THEN
         INC1 = INVWIN(NODC(NC),LUN,INC1,NVAL(LUN))
         CALL USRTPL(LUN,INC1-1,NBMP)
         CALL NEWWIN(LUN,INC1,INC2)
      ELSE
15       CALL GETWIN(NODC(NC),LUN,INC1,INC2)
         IF(INC1.EQ.0 .AND. NC.EQ.1) GOTO 100
         IF(INC1.EQ.0              ) GOTO 10
         ICON = INVCON(NC,LUN,INC1,INC2)
         IF(ICON.EQ.0) GOTO 15
      ENDIF
      ENDDO

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE COPYBF(LUNIN,LUNOT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    COPYBF
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE COPIES AN ENTIRE BUFR FILE FROM LOGICAL
C   UNIT LUNIN TO LOGICAL UNIT LUNOT.  BOTH UNITS MUST BE CLOSED TO THE
C   BUFR INTERFACE.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL COPYBF (LUNIN, LUNOT)
C   INPUT ARGUMENT LIST:
C     LUNIN    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR INPUT BUFR
C                FILE
C     LUNOT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR OUTPUT BUFR
C                FILE
C
C   INPUT FILES:
C     UNIT "LUNIN" - BUFR FILE
C
C   OUTPUT FILES:
C     UNIT "LUNOT" - BUFR FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     LMSG     STATUS
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MXMSGL=20000)

      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)

      CHARACTER*8 SEC0
      CHARACTER*1 MOCT(MXMSGL)
      DIMENSION   MBAY(MXMSGL/4)
      EQUIVALENCE (MBAY(1),MOCT(1))

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      ISEC0 = 8/NBYTW+1
      NMSG  = 0

C  CHECK BUFR FILE STATUSES
C  ------------------------

      CALL STATUS(LUNIN,LUN,IL,IM)
      IF(IL.NE.0) GOTO 900
      CALL STATUS(LUNOT,LUN,IL,IM)
      IF(IL.NE.0) GOTO 901

      REWIND(LUNIN)
      REWIND(LUNOT)

C  READ AND COPY A BUFR FILE ON UNIT LUNIN TO UNIT LUNOT
C  -----------------------------------------------------

1     READ(LUNIN,END=2,ERR=902) SEC0,(MBAY(I),I=ISEC0,LMSG(SEC0))
      WRITE(LUNOT     ,ERR=903) SEC0,(MBAY(I),I=ISEC0,LMSG(SEC0))
      GOTO 1

2     CLOSE(LUNIN)
      CLOSE(LUNOT)

C  EXITS
C  -----

      RETURN
900   CALL BORT
     . ('BUFRLIB: COPYBF - INPUT BUFR FILE IS OPEN, IT MUST BE CLOSED')
901   CALL BORT
     . ('BUFRLIB: COPYBF - OUTPUT BUFR FILE IS OPEN, IT MUST BE CLOSED')
902   CALL BORT('BUFRLIB: COPYBF - ERROR READING BUFR FILE')
903   CALL BORT('BUFRLIB: COPYBF - ERROR WRITING BUFR FILE')
      END
      SUBROUTINE COPYMG(LUNIN,LUNOT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    COPYMG
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE COPIES A BUFR MESSAGE, INTACT, FROM LOGICAL
C   UNIT LUNIN, OPENED FOR INPUT VIA A PREVIOUS CALL TO BUFR ARCHIVE
C   LIBRARY SUBROUTINE OPENBF, TO LOGICAL UNIT LUNOT, OPENED FOR OUTPUT
C   VIA A PREVIOUS CALL TO OPENBF.  THE MESSAGE COPIED FROM LOGICAL
C   UNIT LUNIN WILL BE THE ONE MOST RECENTLY READ USING BUFR ARCHIVE
C   LIBRARY SUBROUTINE READMG.  THE OUTPUT FILE MUST HAVE NO CURENTLY
C   OPEN MESSAGES.  ALSO, BOTH FILES MUST HAVE BEEN OPENED TO THE BUFR
C   INTERFACE WITH IDENTICAL BUFR TABLES.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY); OUTPUTS MORE COMPLETE DIAGNOSTIC
C                           INFO WHEN ROUTINE TERMINATES ABNORMALLY
C
C USAGE:    CALL COPYMG (LUNIN, LUNOT)
C   INPUT ARGUMENT LIST:
C     LUNIN    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR INPUT BUFR
C                FILE
C     LUNOU    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR OUTPUT BUFR
C                FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     IUPB     MSGWRT   NEMTBA
C                               STATUS
C    THIS ROUTINE IS CALLED BY: None.
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)

      CHARACTER*10 TAG
      CHARACTER*8  SUBSET
      CHARACTER*3  TYP

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  CHECK THE FILE STATUSES
C  -----------------------

      CALL STATUS(LUNIN,LIN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      IF(IM.EQ.0) GOTO 902

      CALL STATUS(LUNOT,LOT,IL,IM)
      IF(IL.EQ.0) GOTO 903
      IF(IL.LT.0) GOTO 904
      IF(IM.NE.0) GOTO 905

C  MAKE SURE BOTH FILES HAVE THE SAME TABLES
C  -----------------------------------------

      SUBSET = TAG(INODE(LIN))
c  .... Given SUBSET, returns MSGT,MSTB,INOD
      CALL NEMTBA(LOT,SUBSET,MSGT,MSTB,INOD)
      IF(INODE(LIN).NE.INOD) GOTO 906

C  EVERYTHING OKAY, COPY A MESSAGE
C  -------------------------------

      MBYM = IUPB(MBAY(1,LIN),5,24)
      CALL MSGWRT(LUNOT,MBAY(1,LIN),MBYM)

C  SET THE MESSAGE CONTROL WORDS FOR PARTITION ASSOCIATED WITH LUNOT
C  -----------------------------------------------------------------

      NMSG (LOT) = NMSG(LOT) + 1
      NSUB (LOT) = MSUB(LIN)
      IDATE(LOT) = IDATE(LIN)
      INODE(LOT) = INODE(LIN)

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: COPYMG - INPUT BUFR FILE IS CLOSED, IT MUST'//
     . ' BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: COPYMG - INPUT BUFR FILE IS OPEN FOR '//
     . 'OUTPUT, IT MUST BE OPEN FOR INPUT')
902   CALL BORT('BUFRLIB: COPYMG - A MESSAGE MUST BE OPEN IN INPUT '//
     . 'BUFR FILE, NONE ARE')
903   CALL BORT('BUFRLIB: COPYMG - OUTPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR OUTPUT')
904   CALL BORT('BUFRLIB: COPYMG - OUTPUT BUFR FILE IS OPEN FOR '//
     . 'INPUT, IT MUST BE OPEN FOR OUTPUT')
905   CALL BORT('BUFRLIB: COPYMG - ALL MESSAGES MUST BE CLOSED IN '//
     . 'OUTPUT BUFR FILE, A MESSAGE IS OPEN')
906   CALL BORT('BUFRLIB: COPYMG - INPUT AND OUTPUT BUFR FILES MUST '//
     . 'HAVE THE SAME INTERNAL TABLES, THEY ARE DIFFERENT HERE')
      END
      SUBROUTINE COPYSB(LUNIN,LUNOT,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    COPYSB
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE COPIES A PACKED DATA SUBSET, INTACT, FROM
C   LOGICAL UNIT LUNIN, OPENED FOR INPUT VIA A PREVIOUS CALL TO BUFR
C   ARCHIVE LIBRARY SUBROUTINE OPENBF, TO LOGICAL UNIT LUNOT, OPENED
C   FOR OUTPUT VIA A PREVIOUS CALL TO OPENBF.  THE BUFR MESSAGE MUST
C   HAVE BEEN PREVIOUSLY READ FROM UNIT LUNIT USING BUFR ARCHIVE
C   LIBRARY SUBROUTINE READMG OR READERME AND MAY BE EITHER COMPRESSED
C   OR UNCOMPRESSED.  ALSO, BUFR ARCHIVE LIBRARY SUBROUTINE OPENMG OR
C   OPENMB MUST HAVE BEEN PREVIOUSLY CALLED TO OPEN AND INITIALIZE A
C   BUFR MESSAGE WITHIN MEMORY FOR UNIT LUNOT.  EACH CALL TO COPYSB
C   ADVANCES THE POINTER TO THE BEGINNING OF THE NEXT SUBSET IN BOTH
C   THE INPUT AND OUTPUT FILES, UNLESS INPUT PARAMETER LUNOT IS .LT.
C   ZERO, IN WHICH CASE THE OUTPUT POINTER IS NOT ADVANCED. 
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2002-05-14  J. WOOLLEN -- REMOVED OLD CRAY COMPILER DIRECTIVES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL COPYSB  ( LUNIN, LUNOT, IRET )
C   INPUT ARGUMENT LIST:
C     LUNIN    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR INPUT BUFR
C                FILE
C     LUNOT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR OUTPUT BUFR
C                FILE
C
C   OUTPUT ARGUMENT LIST:
C     IRET     - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = there are no more subsets in the input
C                           BUFR message
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     CPYUPD   STATUS   UPB
C    THIS ROUTINE IS CALLED BY: ICOPYSB
C                               Also called by application programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IRET = 0

C  CHECK THE FILE STATUSES
C  -----------------------

      CALL STATUS(LUNIN,LIN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      IF(IM.EQ.0) GOTO 902

      IF(LUNOT.GT.0) THEN
         CALL STATUS(LUNOT,LOT,IL,IM)
         IF(IL.EQ.0) GOTO 903
         IF(IL.LT.0) GOTO 904
         IF(IM.EQ.0) GOTO 905
         IF(INODE(LIN).NE.INODE(LOT)) GOTO 906
      ENDIF

C  SEE IF THERE IS ANOTHER SUBSET IN THE MESSAGE
C  ---------------------------------------------

      IF(NSUB(LIN).EQ.MSUB(LIN)) THEN
         IRET = -1
         GOTO 100
      ENDIF

C  COPY THE SUBSET TO THE OUTPUT MESSAGE AND/OR RESET THE POINTERS
C  ---------------------------------------------------------------

      IBIT = (MBYT(LIN))*8
      CALL UPB(NBYT,16,MBAY(1,LIN),IBIT)
      IF(LUNOT.GT.0) CALL CPYUPD(LUNOT,LIN,LOT,NBYT)
      MBYT(LIN) = MBYT(LIN) + NBYT
      NSUB(LIN) = NSUB(LIN) + 1

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: COPYSB - INPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: COPYSB - INPUT BUFR FILE IS OPEN FOR '//
     . 'OUTPUT, IT MUST BE OPEN FOR INPUT')
902   CALL BORT('BUFRLIB: COPYSB - A MESSAGE MUST BE OPEN IN INPUT '//
     . 'BUFR FILE, NONE ARE')
903   CALL BORT('BUFRLIB: COPYSB - OUTPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR OUTPUT')
904   CALL BORT('BUFRLIB: COPYSB - OUTPUT BUFR FILE IS OPEN FOR '//
     . 'INPUT, IT MUST BE OPEN FOR OUTPUT')
905   CALL BORT('BUFRLIB: COPYSB - A MESSAGE MUST BE OPEN IN OUTPUT '//
     . 'BUFR FILE, NONE ARE')
906   CALL BORT('BUFRLIB: COPYSB - INPUT AND OUTPUT BUFR FILES MUST '//
     . 'HAVE THE SAME INTERNAL TABLES, THEY ARE DIFFERENT HERE')
      END
      SUBROUTINE COPYST(LUNIN,LUNOT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    COPYST
C   PRGMMR: KEYSER           ORG: NP22       DATE: 2003-11-04
C
C ABSTRACT: THIS SUBROUTINE GENERATES A STANDARDIZED VERSION OF A BUFR
C   MESSAGE, READ FROM LOGICAL UNIT LUNIN USING BUFR ARCHIVE LIBRARY
C   SUBROUTINE READMG.  LUNIN MUST HAVE BEEN OPENED FOR INPUT VIA A
C   PREVIOUS CALL TO BUFR ARCHIVE LIBRARY SUBROUTINE OPENBF.  THE
C   STANDARDIZED MESSAGE IS THEN WRITTEN, INTACT, AS A RECORD TO
C   LOGICAL UNIT LUNOT.  SINCE THE OUTPUT BUFR FILE CONTAINS
C   STANDARDIZED MESSAGES, LUNOT NEED NOT BE OPENED FOR OUTPUT VIA A
C   PREVIOUS CALL TO OPENBF, NOR SHOULD ANY OTHER BUFR ARCHIVE LIBRARY
C   ROUTINES (I.E, OPENMG, OPENMB, CLOSMG, CLOBBF) BE PERFORMED ON IT.
C   SEE DOCUMENTATION IN BUFR ARCHIVE LIBRARY ROUTINE STANDARD FOR MORE
C   ON WHAT "STANDARDIZATION" MEANS.
C
C PROGRAM HISTORY LOG:
C 2003-11-04  D. KEYSER  -- ORIGINAL AUTHOR
C
C USAGE:    CALL COPYST (LUNIN, LUNOT)
C   INPUT ARGUMENT LIST:
C     LUNIN    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR INPUT BUFR
C                FILE
C     LUNOU    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR OUTPUT BUFR
C                FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     STANDARD STATUS
C    THIS ROUTINE IS CALLED BY: None.
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      DIMENSION   MSGSTD(MXMSGL/4)

      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)

      CALL STATUS(LUNIN,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      IF(IM.EQ.0) GOTO 902
     
      DO I=1,MXMSGL/4
         MSGSTD=0
      ENDDO

      CALL STANDARD(LUNIN,MBAY(1,LUN),MSGSTD)

      WRITE(LUNOT) MSGSTD

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: COPYST - INPUT BUFR FILE IS CLOSED, IT MUST'//
     . ' BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: COPYST - INPUT BUFR FILE IS OPEN FOR '//
     . 'OUTPUT, IT MUST BE OPEN FOR INPUT')
902   CALL BORT('BUFRLIB: COPYST - A MESSAGE MUST BE OPEN IN INPUT '//
     . 'BUFR FILE, NONE ARE')
      END
      SUBROUTINE CPBFDX(LUD,LUN)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    CPBFDX
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE COPIES BUFR TABLE (DICTIONARY) MESSAGES
C   FROM ONE LOCATION TO ANOTHER WITHIN INTERNAL MEMORY (ARRAYS IN
C   COMMON BLOCKS /MSGCWD/ AND /TABABD/).
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1995-06-28  J. WOOLLEN -- INCREASED THE SIZE OF INTERNAL BUFR TABLE
C                           ARRAYS IN ORDER TO HANDLE BIGGER FILES
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    CALL CPBFDX (LUD, LUN)
C   INPUT ARGUMENT LIST:
C     LUD      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C                FOR INPUT TABLE LOCATION
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C                FOR OUTPUT TABLE LOCATION
C
C REMARKS:
C    THIS ROUTINE CALLS:        DXINIT
C    THIS ROUTINE IS CALLED BY: READDX
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MAXTBA=50)
      PARAMETER (MAXTBB=250)
      PARAMETER (MAXTBD=250)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /TABABD/ NTBA(0:NFILES),NTBB(0:NFILES),NTBD(0:NFILES),
     .                MTAB(MAXTBA,NFILES),IDNA(MAXTBA,NFILES,2),
     .                IDNB(MAXTBB,NFILES),IDND(MAXTBD,NFILES),
     .                TABA(MAXTBA,NFILES),TABB(MAXTBB,NFILES),
     .                TABD(MAXTBD,NFILES)

      CHARACTER*600 TABD
      CHARACTER*128 TABB
      CHARACTER*128 TABA

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  INITIALIZE THE DICTIONARY TABLE PARTITION
C  -----------------------------------------

      CALL DXINIT(LUN,0)

C  COPY ONE TABLE PARTITION TO ANOTHER
C  -----------------------------------

c  .... Positional index for Table A mnem.
      INODE(LUN) = INODE(LUD)

c  .... Set the number of Table A entries
      NTBA(LUN) = NTBA(LUD)
c  .... Set the number of Table B entries
      NTBB(LUN) = NTBB(LUD)
c  .... Set the number of Table D entries
      NTBD(LUN) = NTBD(LUD)

c  .... Copy Table A entries
      DO I=1,NTBA(LUD)
c  .... Message type
      IDNA(I,LUN,1) = IDNA(I,LUD,1)
c  .... Message subtype
      IDNA(I,LUN,2) = IDNA(I,LUD,2)
c  .... Table A entries
      TABA(I,LUN) = TABA(I,LUD)
c  .... Pointer indices into internal tbl
      MTAB(I,LUN) = MTAB(I,LUD)
      ENDDO

c  .... Copy Table B entries
      DO I=1,NTBB(LUD)
c  .... Integer repr. of FXY descr.
      IDNB(I,LUN) = IDNB(I,LUD)
c  .... Table B entries
      TABB(I,LUN) = TABB(I,LUD)
      ENDDO

c  .... Copy Table D entries
      DO I=1,NTBD(LUD)
c  .... Integer repr. of FXY descr.
      IDND(I,LUN) = IDND(I,LUD)
c  .... Table B entries
      TABD(I,LUN) = TABD(I,LUD)
      ENDDO

      RETURN
      END
      SUBROUTINE CPYMEM(LUNOT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    CPYMEM
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE COPIES A BUFR MESSAGE, INTACT, FROM
C   INTERNAL MEMORY, STORED VIA A PREVIOUS CALL TO BUFR ARCHIVE LIBRARY
C   SUBROUTINE UFBMEM, TO LOGICAL UNIT LUNOT, OPENED FOR OUTPUT VIA A
C   PREVIOUS CALL TO BUFR ARCHIVE LIBRARY SUBROUTINE OPENBF.  THE
C   MESSAGE COPIED FROM INTERNAL MEMORY WILL BE THE ONE MOST RECENTLY
C   READ INTO THE MESSAGE BUFFER (ARRAY MBAY IN COMMON BLOCK /BITBUF/)
C   USING BUFR ARCHIVE LIBRARY SUBROUTINE RDMEMM OR READMM.  THE OUTPUT
C   FILE MUST HAVE NO CURENTLY OPEN MESSAGES.  ALSO, THE INTERNAL BUFR
C   TABLES ASSOCIATED WITH THE INPUT MESSAGE MUST BE IDENTICAL TO THE
C   BUFR TABLES USED TO OPEN LUNOT TO THE BUFR INTERFACE.  THIS
C   SUBROUTINE IS SIMILAR TO BUFR ARCHIVE LIBRARY SUBROUTINE COPYMG
C   EXCEPT THE INPUT MESSAGE IS FROM INTERNAL MEMORY NOT FROM A
C   PHYSICAL BUFR FILE.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2001-08-15  D. KEYSER  -- PARAMETER MAXMEM (THE MAXIMUM NUMBER OF
C                           BYTES REQUIRED TO STORE ALL MESSAGES
C                           INTERNALLY) WAS INCREASED FROM 8 MBYTES TO
C                           16 MBYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- PARAMETER MAXMSG (THE MAXIMUM NUMBER OF
C                           BUFR MESSAGES WHICH CAN BE STORED
C                           INTERNALLY) INCREASED FROM 50000 TO 200000;
C                           MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY); OUTPUTS MORE COMPLETE DIAGNOSTIC
C                           INFO WHEN ROUTINE TERMINATES ABNORMALLY
C
C USAGE:    CALL CPYMEM (LUNOT)
C   INPUT ARGUMENT LIST:
C     LUNOT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     IUPB     MSGWRT   NEMTBA
C                               STATUS
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXMSG=200000,MAXMEM=16000000)
      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /MSGMEM/ MUNIT,MLAST,MSGP(0:MAXMSG),MSGS(MAXMEM)
      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)

      CHARACTER*10 TAG
      CHARACTER*8  SUBSET
      CHARACTER*3  TYP

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  CHECK THE FILE STATUSES
C  -----------------------

      CALL STATUS(MUNIT,LIN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      IF(IM.EQ.0) GOTO 902

      CALL STATUS(LUNOT,LOT,IL,IM)
      IF(IL.EQ.0) GOTO 903
      IF(IL.LT.0) GOTO 904
      IF(IM.NE.0) GOTO 905

C  MAKE SURE BOTH FILES HAVE THE SAME TABLES
C  -----------------------------------------

      SUBSET = TAG(INODE(LIN))
c  .... Given SUBSET, returns MTYP,MSTB,INOD
      CALL NEMTBA(LOT,SUBSET,MTYP,MSBT,INOD)
      IF(INODE(LIN).NE.INOD) GOTO 906

C  EVERYTHING OKAY, COPY A MESSAGE
C  -------------------------------

      MBYM = IUPB(MBAY(1,LIN),5,24)
      CALL MSGWRT(LUNOT,MBAY(1,LIN),MBYM)

C  SET THE MESSAGE CONTROL WORDS FOR PARTITION ASSOCIATED WITH LUNOT
C  -----------------------------------------------------------------

      NMSG (LOT) = NMSG(LOT) + 1
      NSUB (LOT) = MSUB(LIN)
      MSUB (LOT) = MSUB(LIN)
      IDATE(LOT) = IDATE(LIN)
      INODE(LOT) = INODE(LIN)

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: CPYMEM - LOGICAL UNIT NO. ASSOC. WITH INPUT'//
     . ' BUFR MESSAGES IN INTERNAL MEMORY IS CLOSED, IT MUST BE OPEN '//
     . 'FOR INPUT')
901   CALL BORT('BUFRLIB: CPYMEM - LOGICAL UNIT NO. ASSOC. WITH INPUT'//
     . ' BUFR MESSAGES IN INTERNAL MEMORY OPEN FOR OUTPUT, MUST BE '//
     . ' OPEN FOR INPUT')
902   CALL BORT('BUFRLIB: CPYMEM - A MESSAGE MUST BE OPEN IN INPUT '//
     . 'BUFR MESSAGES IN INTERNAL MEMORY, NONE ARE')
903   CALL BORT('BUFRLIB: CPYMEM - OUTPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR OUTPUT')
904   CALL BORT('BUFRLIB: CPYMEM - OUTPUT BUFR FILE IS OPEN FOR '//
     . 'INPUT, IT MUST BE OPEN FOR OUTPUT')
905   CALL BORT('BUFRLIB: CPYMEM - ALL MESSAGES MUST BE CLOSED IN '//
     . 'OUTPUT BUFR FILE, A MESSAGE IS OPEN')
906   CALL BORT('BUFRLIB: CPYMEM - INPUT BUFR MESSAGES IN INTERNAL '//
     . 'MEMORY AND OUTPUT BUFR FILE MUST HAVE SAME INTERNAL TABLES '//
     . '(DIFFERENT HERE)')

      END
      SUBROUTINE CPYUPD(LUNIT,LIN,LUN,IBYT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    CPYUPD
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE COPIES A SUBSET FROM ONE MESSAGE BUFFER
C   (ARRAY MBAY IN COMMON BLOCK /BITBUF/) TO ANOTHER AND/OR RESETS THE
C   POINTERS.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2002-05-14  J. WOOLLEN -- REMOVED OLD CRAY COMPILER DIRECTIVES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL CPYUPD (LUNIT, LIN, LUN, IBYT)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     LIN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C                FOR INPUT MESSAGE LOCATION
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C                FOR OUTPUT MESSAGE LOCATION
C     IBYT     - INTEGER: NUMBER OF BYTES OCCUPIED BY THIS SUBSET
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     IUPB     MSGINI   MSGWRT
C                               MVB      PKB
C    THIS ROUTINE IS CALLED BY: COPYSB
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /MSGPTR/ NBY0,NBY1,NBY2,NBY3,NBY4,NBY5
      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)

      CHARACTER*128 BORT_STR

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  SEE IF THE NEW SUBSET FITS
C  --------------------------

      IF(MBYT(LUN)+IBYT+8.GT.MAXBYT) THEN
         CALL MSGWRT(LUNIT,MBAY(1,LUN),MBYT(LUN))
         CALL MSGINI(LUN)
      ENDIF

      IF(MBYT(LUN)+IBYT+8.GT.MAXBYT) GOTO 900

C  TRANSFER SUBSET FROM ONE MESSAGE TO THE OTHER
C  ---------------------------------------------

c  .... DK: Why the -3 in "MBYT(LUN)-3" ??
      CALL MVB(MBAY(1,LIN),MBYT(LIN)+1,MBAY(1,LUN),MBYT(LUN)-3,IBYT)

C  UPDATE THE SUBSET AND BYTE COUNTERS
C  --------------------------------------

      MBYT(LUN)   = MBYT(LUN)   + IBYT
      NSUB(LUN)   = NSUB(LUN)   + 1

      LBIT = (NBY0+NBY1+NBY2+4)*8
      CALL PKB(NSUB(LUN),16,MBAY(1,LUN),LBIT)

      LBYT = NBY0+NBY1+NBY2+NBY3
      NBYT = IUPB(MBAY(1,LUN),LBYT+1,24)
      LBIT = LBYT*8
      CALL PKB(NBYT+IBYT,24,MBAY(1,LUN),LBIT)

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: CPYUPD - THE LENGTH OF THIS SUBSET '//
     . '(",I6," EXCEEDS THE MAXIMUM MESSAGE LENGTH (",I6,")")')
     .  MBYT(LUN)+IBYT+8,MAXBYT
      CALL BORT(BORT_STR)
      END
      SUBROUTINE DATEBF(LUNIT,MEAR,MMON,MDAY,MOUR,IDATE)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    DATEBF
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE RETURNS THE SECTION 1 DATE IN THE FIRST
C   NON-DICTIONARY BUFR MESSAGE IN LOGICAL UNIT LUNIT, REGARDLESS OF
C   THE NUMBER OF SUBSETS IN THE MESSAGE.  LUNIT SHOULD NOT BE
C   PREVIOUSLY OPENED TO THE BUFR INTERFACE.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"; MODIFIED TO MAKE Y2K
C                           COMPLIANT
C 1998-08-31  J. WOOLLEN -- MODIFIED TO CORRECT AN ERROR WHICH LEAD TO
C                           THE YEAR BEING RETURNED IN "MEAR" AS 2-
C                           DIGIT YEAR WHEN A 4-DIGIT YEAR WAS
C                           REQUESTED VIA A PRIOR CALL TO DATELEN (THE
C                           CENTER DATE RETURNED IN "IDATE", IN THE
C                           FORM YYYYMMDDHH, WAS CORRECT IN THE
C                           PREVIOUS VERSION OF THIS ROUTINE
C 1998-10-27  J. WOOLLEN -- MODIFIED TO CORRCT PROBLEMS CAUSED BY IN-
C                           LINING CODE WITH FPP DIRECTIVES
C 2003-05-19  M. SHIREY  -- REPLACED CALLS TO FORTRAN INSRINSIC
C                           FUNCTION ICHAR WITH THE NCEP W3LIB C-
C                           FUNCTION MOVA2I BECAUSE ICHAR DOES NOT WORK
C                           PROPERLY ON SOME MACHINES (E.G., IBM FROST/
C                           SNOW) (NOTE: ON 2003-??-??, MOVA2I WAS
C                           ADDED TO THE BUFRLIB AS A FORTRAN FUNCTION)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MODIFIED DATE CALCULATIONS TO NO LONGER
C                           USE FLOATING POINT ARITHMETIC SINCE THIS
C                           CAN LEAD TO ROUND OFF ERROR AND AN IMPROPER
C                           RESULTING DATE ON SOME MACHINES (E.G., NCEP
C                           IBM FROST/SNOW), INCREASES PORTABILITY;
C                           UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY OR UNUSUAL THINGS
C                           HAPPEN
C
C USAGE:    CALL  DATEBF (LUNIT, MEAR, MMON, MDAY, MOUR, IDATE)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     MEAR     - INTEGER: SECTION 1 4-DIGIT YEAR YYYY
C     MMON     - INTEGER: SECTION 1 MONTH MM
C     MDAY     - INTEGER: SECTION 1 DAY DD
C     MOUR     - INTEGER: SECTION 1 HOUR HH
C     IDATE    - INTEGER: DATE-TIME FROM SECTION 1 OF BUFR MESSAGE IN
C                FORMAT OF EITHER YYMMDDHH OR YYYYMMDDHH, DEPENDING ON
C                DATELEN() VALUE; OR -1 IF SECTION 1 DATE COULD NOT BE
C                LOCATED
C
C   INPUT FILES:
C     UNIT "LUNIT" - BUFR FILE
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     I4DY     MOVA2I   STATUS
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /DATELN/ LENDAT
      COMMON /QUIET / IPRT

      CHARACTER*26  MSTR

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IDATE = -1

C  SEE IF THE FILE IS ALREADY OPEN TO BUFR INTERFACE (A NO-NO)
C  -----------------------------------------------------------

      CALL STATUS(LUNIT,LUN,JL,JM)
      IF(JL.NE.0) GOTO 900

C  CHECK FOR NO BUFR DATA OR NO DATA AT ALL
C  ----------------------------------------

      REWIND LUNIT
      READ(LUNIT,END=100,ERR=100) MSTR
      IF(MSTR(1:4).NE.'BUFR') GOTO 100

C  READ TO A DATA MESSAGE AND PICK OUT THE DATE
C  --------------------------------------------

1     READ(LUNIT,END=100,ERR=100) MSTR
      IF(MOVA2I(MSTR(17:17)).EQ.11) GOTO 1
      MEAR = MOD(MOVA2I(MSTR(21:21)),100)
      MMON = MOVA2I(MSTR(22:22))
      MDAY = MOVA2I(MSTR(23:23))
      MOUR = MOVA2I(MSTR(24:24))
      MMIN = MOVA2I(MSTR(25:25))
      MCEN = MAX(0,MOVA2I(MSTR(26:26))-MIN(MEAR,1))

      IF(LENDAT.EQ.10) THEN
         IDATE = MCEN*100000000+MEAR*1000000+MMON*10000+MDAY*100+MOUR
         IDATE = I4DY(IDATE)
         MEAR  = IDATE/10**6
      ELSE
         IDATE = MEAR*1000000+MMON*10000+MDAY*100+MOUR
      ENDIF

100   IF(IPRT.GE.1 .AND. IDATE.EQ.-1) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
         PRINT*, 'BUFRLIB: DATEBF - SECTION 1 DATE COULD NOT BE ',
     .    'LOCATED - RETURN WITH IDATE = -1'
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
      ENDIF

C  EXITS
C  -----

      RETURN
900   CALL BORT
     . ('BUFRLIB: DATEBF - INPUT BUFR FILE IS OPEN, IT MUST BE CLOSED')
      END
      SUBROUTINE DATELEN(LEN)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    DATELEN
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1998-07-08
C
C ABSTRACT: THIS SUBROUTINE IS USED TO SPECIFY THE LENGTH OF DATE-TIME
C   VALUES THAT WILL BE OUTPUT BY FUTURE CALLS TO ANY OF THE
C   BUFR ARCHIVE LIBRARY SUBROUTINES WHICH READ BUFR MESSAGES (E.G.
C   READMG, READERME, READERM, READFT, READTJ, ETC.).  POSSIBLE VALUES
C   ARE "8" (WHICH IS THE DEFAULT) AND "10".
C
C PROGRAM HISTORY LOG:
C 1998-07-08  J. WOOLLEN -- ORIGINAL AUTHOR (ENTRY POINT IN READMG)
C 2002-05-14  J. WOOLLEN -- CHANGED FROM AN ENTRY POINT TO INCREASE
C                           PORTABILITY TO OTHER PLATFORMS
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL DATELEN (LEN)
C   INPUT ARGUMENT LIST:
C     LEN      - INTEGER: LENGTH OF DATE-TIME VALUES TO BE OUTPUT BY
C                READ SUBROUTINES:  *
C                       8 =   YYMMDDHH (2-digit year)
C                      10 = YYYYMMDDHH (4-digit year)
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /DATELN/ LENDAT

      CHARACTER*128 BORT_STR

      IF(LEN.NE.8 .AND. LEN.NE.10) GOTO 900
      LENDAT = LEN

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: DATELEN - INPUT ARGUMENT IS",I4," - '//
     . 'IT MUST BE EITHER 8 OR 10")') LEN
      CALL BORT(BORT_STR)
      END
      LOGICAL FUNCTION DIGIT(STR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    DIGIT
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS LOGICAL FUNCTION TESTS THE CHARACTERS IN A STRING TO
C   DETERMINE IF THEY ARE ALL DIGITS ('0','1','2','3','4','5','6','7',
C   '8' or '9').
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    DIGIT (STR)
C   INPUT ARGUMENT LIST:
C     STR      - CHARACTER*(*): STRING
C
C   OUTPUT ARGUMENT LIST:
C     DIGIT    - LOGICAL: TRUE IF ALL CHARACTERS IN STR ARE DIGITS
C                ('0' - '9'), OTHERWISE FALSE
C
C REMARKS:
C    THIS ROUTINE CALLS:        None
C    THIS ROUTINE IS CALLED BY: CKTABA   NUMBCK   RDBFDX   RDUSDX
C                               Normally not called by any application
C                               programs but it could be.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*(*) STR
      DIGIT = .FALSE.
      DO I=1,LEN(STR)
      IF(STR(I:I).NE.'0' .AND. STR(I:I).NE.'1' .AND.
     .   STR(I:I).NE.'2' .AND. STR(I:I).NE.'3' .AND.
     .   STR(I:I).NE.'4' .AND. STR(I:I).NE.'5' .AND.
     .   STR(I:I).NE.'6' .AND. STR(I:I).NE.'7' .AND.
     .   STR(I:I).NE.'8' .AND. STR(I:I).NE.'9') GOTO 100
      ENDDO
      DIGIT = .TRUE.

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE DRFINI(LUNIT,MDRF,NDRF,DRFTAG)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    DRFINI (docblock incomplete)
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2002-05-14
C
C ABSTRACT: THIS SUBROUTINE INITIALIZES DELAYED REPLICATION FACTORS,
C   AND ALLOCATES THE SPACE IN THE FULL WORD BUFFER FOR THEIR CONTENTS
C   EXPLICITLY.  THIS IS DONE IMPLICTLY BY BUFR ARCHIVE LIBRARY
C   SUBROUTINE UFBINT IN A MORE LIMITED WAY.  DRFINI ENABLES, FOR
C   INSTANCE, THE SUBSEQUENT USE OF BUFR ARCHIVE LIBRARY SUBROUTINE
C   UFBSEQ TO WRITE DATA DIRECTLY INTO DELAYED REPLICATED SEQUENCES.
C
C PROGRAM HISTORY LOG:
C 2002-05-14  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY) (INCOMPLETE); OUTPUTS MORE
C                           COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL DRFINI (LUNIT, MDRF, NDRF, DRFTAG)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     MDRF     - INTEGER: NDRF-WORD ARRAY ....
C     NDRF     - INTEGER: LENGTH OF MDRF
C     DRFTAG   - CHARACTER*(*): ....
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     STATUS   USRTPL
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs?
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)

      CHARACTER*(*) DRFTAG
      CHARACTER*128 BORT_STR
      CHARACTER*10  TAG
      CHARACTER*3   TYP
      REAL*8        VAL
      DIMENSION     MDRF(NDRF)

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IF(NDRF.GT.100) GOTO 900

      CALL STATUS(LUNIT,LUN,IL,IM)

C  COMFORM THE TEMPLATES TO THE DELAYED REPLICATION FACTORS
C  --------------------------------------------------------

      M = 0
      N = 0

10    DO N=N+1,NVAL(LUN)
      NODE = INV(N,LUN)
      IF(ITP(NODE).EQ.1 .AND. TAG(NODE).EQ.DRFTAG) THEN
         M = M+1
         CALL USRTPL(LUN,N,MDRF(M))
         GOTO 10
      ENDIF
      ENDDO

C  EXITS
C  -----

      RETURN
 900  WRITE(BORT_STR,'("BUFRLIB: DRFINI - THE NUMBER OF DELAYED '//
     . 'REPLICATION FACTORS (",I5,") EXCEEDS THE LIMIT (100)")') NDRF
      CALL BORT(BORT_STR)
      END
      SUBROUTINE DRSTPL(INOD,LUN,INV1,INV2,INVN)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    DRSTPL (docblock incomplete)
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE ....
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT" (LATER REMOVED, UNKNOWN
C                           WHEN)
C 2002-05-14  J. WOOLLEN -- REMOVED OLD CRAY COMPILER DIRECTIVES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY) (INCOMPLETE)
C
C USAGE:    CALL DRSTPL (INOD, LUN, INV1, INV2, INVN)
C   INPUT ARGUMENT LIST:
C     INOD     - INTEGER: ....
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     INV1     - INTEGER: ....
C     INV2     - INTEGER: ....
C     INVN     - INTEGER: ....
C
C   OUTPUT ARGUMENT LIST:
C     INVN     - INTEGER: ....
C
C REMARKS:
C    THIS ROUTINE CALLS:        INVWIN   NEWWIN   USRTPL
C    THIS ROUTINE IS CALLED BY: UFBRW
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)

      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)

      CHARACTER*10 TAG
      CHARACTER*3  TYP

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

1     NODE = INOD
2     NODE = JMPB(NODE)
      IF(NODE.EQ.0) GOTO 100
      IF(TYP(NODE).EQ.'DRS' .OR. TYP(NODE).EQ.'DRB') THEN
         INVN = INVWIN(NODE,LUN,INV1,INV2)
         IF(INVN.GT.0) THEN
            CALL USRTPL(LUN,INVN,1)
            CALL NEWWIN(LUN,INV1,INV2)
            INVN = INVWIN(INOD,LUN,INVN,INV2)
            IF(INVN.GT.0) GOTO 100
            GOTO 1
         ENDIF
      ENDIF
      GOTO 2

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE DUMPBF(LUNIT,JDATE,JDUMP)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    DUMPBF
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1996-12-11
C
C ABSTRACT: THIS SUBROUTINE RETURNS THE SECTION 1 DATE IN THE FIRST
C   TWO NON-DICTIONARY BUFR MESSAGES IN LOGICAL UNIT LUNIT WHICH
C   CONTAIN ZERO SUBSETS.  NORMALLY, THESE "DUMMY" MESSAGES APPEAR
C   ONLY IN DATA DUMP FILES AND ARE IMMEDIATELY AFTER THE DICTIONARY
C   MESSAGES.  THEY CONTAIN A DUMP "CENTER TIME" AND A DUMP FILE
C   "PROCESSING TIME", RESPECTIVELY.  LUNIT SHOULD NOT BE PREVIOUSLY
C   OPENED TO THE BUFR INTERFACE.
C
C PROGRAM HISTORY LOG:
C 1996-12-11  J. WOOLLEN -- ORIGINAL AUTHOR
C 1996-12-17  J. WOOLLEN -- CORRECTED ERROR IN DUMP DATE READER
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"; MODIFIED TO MAKE Y2K
C                           COMPLIANT
C 2003-05-19  M. SHIREY  -- REPLACED CALLS TO FORTRAN INSRINSIC
C                           FUNCTION ICHAR WITH THE NCEP W3LIB C-
C                           FUNCTION MOVA2I BECAUSE ICHAR DOES NOT WORK 
C                           PROPERLY ON SOME MACHINES (E.G., IBM FROST/
C                           SNOW) (NOTE: ON 2003-??-??, MOVA2I WAS
C                           ADDED TO THE BUFRLIB AS A FORTRAN FUNCTION)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MODIFIED DATE CALCULATIONS TO NO LONGER
C                           USE FLOATING POINT ARITHMETIC SINCE THIS
C                           CAN LEAD TO ROUND OFF ERROR AND AN IMPROPER
C                           RESULTING DATE ON SOME MACHINES (E.G., NCEP
C                           IBM FROST/SNOW), INCREASES PORTABILITY;
C                           UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY OR UNUSUAL THINGS
C                           HAPPEN
C
C USAGE:    CALL DUMPBF (LUNIT, JDATE, JDUMP)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     JDATE    - INTEGER: 5-WORD ARRAY CONTAINING THE 4-DIGIT YEAR,
C                MONTH, DAY, HOUR AND MINUTE FROM SECTION 1 OF THE
C                FIRST NON-DICTIONARY BUFR MESSAGE WITH ZERO SUBSETS
C                (NORMALLY THE DATA DUMP CENTER TIME IN A DATA DUMP
C                FILE); OR 5*-1 IF THIS COULD NOT BE LOCATED
C     JDUMP    - INTEGER: 5-WORD ARRAY CONTAINING THE 4-DIGIT YEAR,
C                MONTH, DAY, HOUR AND MINUTE FROM SECTION 1 OF THE
C                SECOND NON-DICTIONARY BUFR MESSAGE WITH ZERO SUBSETS
C                (NORMALLY THE FILE PROCESSING TIME IN A DATA DUMP
C                FILE); OR 5*-1 IF THIS COULD NOT BE LOCATED
C
C   INPUT FILES:
C     UNIT "LUNIT" - BUFR FILE
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     I4DY     MOVA2I   STATUS
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /DATELN/ LENDAT
      COMMON /QUIET / IPRT

      DIMENSION JDATE(5),JDUMP(5)

      CHARACTER*32  MSTR

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      DO I=1,5
      JDATE(I) = -1
      JDUMP(I) = -1
      ENDDO

C  SEE IF THE FILE IS ALREADY OPEN TO BUFR INTERFACE (A NO-NO)
C  -----------------------------------------------------------

      CALL STATUS(LUNIT,LUN,JL,JM)
      IF(JL.NE.0) GOTO 900

C  CHECK FOR NO BUFR DATA OR NO DATA AT ALL
C  ----------------------------------------

      REWIND LUNIT
1     READ(LUNIT,END=200,ERR=200) MSTR
      IF(MSTR(1:4).NE.'BUFR') GOTO 200
      IF(MOVA2I(MSTR(17:17)).EQ.11) GOTO 1

C  DUMP CENTER YY,MM,DD,HH,MM IS IN THE FIRST EMPTY MESSAGE
C  --------------------------------------------------------

      IF(MOVA2I(MSTR(31:31)).EQ.0 .AND. MOVA2I(MSTR(32:32)).EQ.0) THEN
         JDATE(1) = MOD(MOVA2I(MSTR(21:21)),100)
         JDATE(2) = MOVA2I(MSTR(22:22))
         JDATE(3) = MOVA2I(MSTR(23:23))
         JDATE(4) = MOVA2I(MSTR(24:24))
         JDATE(5) = MOVA2I(MSTR(25:25))
         MCEN     = MAX(0,MOVA2I(MSTR(26:26))-MIN(JDATE(1),1))
      ELSE
         GOTO 200
      ENDIF

      IF(LENDAT.EQ.10) THEN
         JDATE(1) = I4DY(MCEN*100000000+JDATE(1)*1000000)/10**6
      ENDIF

C  DUMP CLOCK YY,MM,DD,HH,MM IS IN THE SECOND EMPTY MESSAGE
C  --------------------------------------------------------

      READ(LUNIT,END=200,ERR=200) MSTR

      IF(MOVA2I(MSTR(31:31)).EQ.0 .AND. MOVA2I(MSTR(32:32)).EQ.0) THEN
         JDUMP(1) = MOD(MOVA2I(MSTR(21:21)),100)
         JDUMP(2) = MOVA2I(MSTR(22:22))
         JDUMP(3) = MOVA2I(MSTR(23:23))
         JDUMP(4) = MOVA2I(MSTR(24:24))
         JDUMP(5) = MOVA2I(MSTR(25:25))
         MCEN     = MAX(0,MOVA2I(MSTR(26:26))-MIN(JDUMP(1),1))
      ELSE
         GOTO 200
      ENDIF

      IF(LENDAT.EQ.10) THEN
         JDUMP(1) = I4DY(MCEN*100000000+JDUMP(1)*1000000)/10**6
      ENDIF

      GOTO 100

200   IF(IPRT.GE.1 .AND. (JDATE(1).EQ.-1.OR.JDUMP(1).EQ.-1)) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
         IF(JDATE(1).EQ.-1) PRINT*, 'BUFRLIB: DATEBF - FIRST  EMPTY ',
     .    'BUFR MESSAGE SECTION 1 DATE COULD NOT BE LOCATED - RETURN ',
     .    'WITH JDATE = 4*-1'
         IF(JDUMP(1).EQ.-1) PRINT*, 'BUFRLIB: DATEBF - SECOND EMPTY ',
     .    'BUFR MESSAGE SECTION 1 DATE COULD NOT BE LOCATED - RETURN ',
     .    'WITH JDUMP = 4*-1'
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
      ENDIF

C  EXITS
C  -----

100   RETURN
900   CALL BORT
     . ('BUFRLIB: DUMPBF - INPUT BUFR FILE IS OPEN, IT MUST BE CLOSED')
      END
      SUBROUTINE DXINIT(LUN,IOI)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    DXINIT
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE INITIALIZES THE MESSAGE CONTROL WORD
C   PARTITION ARRAYS (COMMON BLOCK /MSGCWD/) AND THE INTERNAL ARRAYS
C   (COMMON BLOCK /TABABD/) HOLDING THE DICTIONARY TABLE.  IT THEN
C   INITIALIZES THE TABLE WITH APRIORI TABLE B AND D ENTRIES
C   (OPTIONAL).
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1995-06-28  J. WOOLLEN -- INCREASED THE SIZE OF INTERNAL BUFR TABLE
C                           ARRAYS IN ORDER TO HANDLE BIGGER FILES
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    CALL DXINIT (LUN, IOI)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     IOI      - INTEGER: SWITCH:
C                       0 = do not initialize the table with apriori
C                           Table B and D entries
C                    else = initialize the table with apriori Table B
C                           and D entries
C
C REMARKS:
C    THIS ROUTINE CALLS:        ADN30    IFXY     PKTDD
C    THIS ROUTINE IS CALLED BY: CPBFDX   OPENBF   RDBFDX   RDUSDX
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MAXTBA=50)
      PARAMETER (MAXTBB=250)
      PARAMETER (MAXTBD=250)

      COMMON /PADESC/ IBCT,IPD1,IPD2,IPD3,IPD4
      COMMON /REPTAB/ IDNR(5,2),TYPS(5,2),REPS(5,2),LENS(5)
      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /TABABD/ NTBA(0:NFILES),NTBB(0:NFILES),NTBD(0:NFILES),
     .                MTAB(MAXTBA,NFILES),IDNA(MAXTBA,NFILES,2),
     .                IDNB(MAXTBB,NFILES),IDND(MAXTBD,NFILES),
     .                TABA(MAXTBA,NFILES),TABB(MAXTBB,NFILES),
     .                TABD(MAXTBD,NFILES)

      CHARACTER*600 TABD
      CHARACTER*128 TABB
      CHARACTER*128 TABA
      CHARACTER*8   INIB(6,5),INID(5)
      CHARACTER*6   ADN30
      CHARACTER*3   TYPS
      CHARACTER*1   REPS

      DATA INIB   /'------','BYTCNT  ','BYTES  ','+0','+0','16',
     .             '------','BITPAD  ','NONE   ','+0','+0','1 ',
     .             '031000','DRF1BIT ','NUMERIC','+0','+0','1 ',
     .             '031001','DRF8BIT ','NUMERIC','+0','+0','8 ',
     .             '031002','DRF16BIT','NUMERIC','+0','+0','16'/
      DATA NINIB  /5/

      DATA INID   /'        ',
     .             'DRP16BIT',
     .             'DRP8BIT ',
     .             'DRPSTAK ',
     .             'DRP1BIT '/
      DATA NINID  /5/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  CLEAR OUT A MESSAGE CONTROL WORD PARTITION ARRAYS
C  -------------------------------------------------

      NMSG(LUN)  = 0
      NSUB(LUN)  = 0
      MSUB(LUN)  = 0
      INODE(LUN) = 0
      IDATE(LUN) = 0

C  CLEAR OUT A TABLE PARTITION
C  ---------------------------

      NTBA(LUN) = 0
      DO I=1,NTBA(0)
      TABA(I,LUN) = ' '
      MTAB(I,LUN) = 0
      ENDDO

      NTBB(LUN) = 0
      DO I=1,NTBB(0)
      TABB(I,LUN) = ' '
      ENDDO

      NTBD(LUN) = 0
      DO I=1,NTBD(0)
      TABD(I,LUN) = ' '
c  .... This zeroes the counter in TABD array, IRET returns as 0 and
c       is not tested
      CALL PKTDD(I,LUN,0,IRET)
      ENDDO

      IF(IOI.EQ.0) GOTO 100

C  INITIALIZE TABLE WITH APRIORI TABLE B AND D ENTRIES
C  ---------------------------------------------------

      INIB(1,1) = ADN30(IBCT,6)
      INIB(1,2) = ADN30(IPD4,6)

      DO I=1,NINIB
      NTBB(LUN) = NTBB(LUN)+1
      IDNB(I,LUN) = IFXY(INIB(1,I))
      TABB(I,LUN)(  1:  6) = INIB(1,I)
      TABB(I,LUN)(  7: 70) = INIB(2,I)
      TABB(I,LUN)( 71: 94) = INIB(3,I)
      TABB(I,LUN)( 95: 98) = INIB(4,I)
      TABB(I,LUN)( 99:109) = INIB(5,I)
      TABB(I,LUN)(110:112) = INIB(6,I)
      ENDDO

      DO I=2,NINID
      N = NTBD(LUN)+1
      IDND(N,LUN) = IDNR(I,1)
      TABD(N,LUN)(1: 6) = ADN30(IDNR(I,1),6)
      TABD(N,LUN)(7:70) = INID(I)
c  .... DK: what if IRET = -1 ???
      CALL PKTDD(N,LUN,IDNR(1,1),IRET)
c  .... DK: what if IRET = -1 ???
      CALL PKTDD(N,LUN,IDNR(I,2),IRET)
      NTBD(LUN) = N
      ENDDO

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE DXMINI(LUN,MBAY,MBYT,MB4,MBA,MBB,MBD)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    DXMINI
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE INITIALIZES A BUFR TABLE (DICTIONARY)
C   MESSAGE, WRITING ALL THE PRELIMINARY INFORMATION INTO SECTIONS 0,
C   1, 3, 4.  BUFR ARCHIVE LIBRARY SUBROUTINE WRITDX WILL WRITE THE
C   ACTUAL TABLE INFORMATION INTO THE MESSAGE.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1997-07-29  J. WOOLLEN -- MODIFIED TO UPDATE THE CURRENT BUFR VERSION
C                           WRITTEN IN SECTION 0 FROM 2 TO 3
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL DXMINI (LUN, MBAY, MBYT, MB4, MBA, MBB, MBD)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C
C   OUTPUT ARGUMENT LIST:
C     MBAY     - INTEGER: (MXMSGL/4)-WORD PACKED BINARY ARRAY
C                CONTAINING BUFR MESSAGE
C     MBYT     - INTEGER: LENGTH OF BUFR MESSAGE (BYTES)
C     MB4      - INTEGER: BYTE NUMBER IN MESSAGE OF FIRST BYTE IN
C                SECTION 4
C     MBA      - INTEGER: BYTE NUMBER IN MESSAGE OF FOURTH BYTE IN
C                SECTION 4
C     MBB      - INTEGER: BYTE NUMBER IN MESSAGE OF FIFTH BYTE IN
C                SECTION 4
C     MBD      - INTEGER: BYTE NUMBER IN MESSAGE OF SIXTH BYTE IN
C                SECTION 4
C
C REMARKS:
C    ARGUMENT LUN IS NOT REFERENCED IN THIS SUBROUTINE.  IT IS LEFT
C    HERE IN CASE AN APPLICATION PROGRAM CALLS THIS SUBROUTINE.
C
C    THIS ROUTINE CALLS:        BORT     IUPM     PKB      PKC
C    THIS ROUTINE IS CALLED BY: WRITDX
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MXMSGL=20000)

      COMMON /DXTAB / MAXDX,IDXV,NXSTR(10),LDXA(10),LDXB(10),LDXD(10),
     .                LD30(10),DXSTR(10)

      CHARACTER*128 BORT_STR
      CHARACTER*56  DXSTR
      DIMENSION     MBAY(MXMSGL/4)

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

c  .... The local message subtype is set to the version number of the
c       local tables (here = 1)
      MSBT = IDXV

C  INITIALIZE THE MESSAGE
C  ----------------------

      MBIT = 0
      DO I=1,MXMSGL/4
      MBAY(I) = 0
      ENDDO

C  Section 1 message date is simply zeroed out
C  -------------------------------------------

      IH   = 0
      ID   = 0
      IM   = 0
      IY   = 0

c  .... Dictionary messages get type 11 (see WMO Table A)
      MTYP = 11
      NSUB = 1

      IDXS = IDXV+1
      LDXS = NXSTR(IDXS)

      NBY0 = 8
      NBY1 = 18
      NBY2 = 0
      NBY3 = 7 + NXSTR(IDXS) + 1
      NBY4 = 7
      NBY5 = 4
      MBYT = NBY0+NBY1+NBY2+NBY3+NBY4+NBY5

      IF(MOD(NBY3,2).NE.0) GOTO 900

C  SECTION 0
C  ---------

      CALL PKC('BUFR' ,  4 , MBAY,MBIT)
      CALL PKB(  MBYT , 24 , MBAY,MBIT)
      CALL PKB(     3 ,  8 , MBAY,MBIT)

C  SECTION 1
C  ---------

      CALL PKB(  NBY1 , 24 , MBAY,MBIT)
      CALL PKB(     0 ,  8 , MBAY,MBIT)
      CALL PKB(     3 ,  8 , MBAY,MBIT)
      CALL PKB(     7 ,  8 , MBAY,MBIT)
      CALL PKB(     0 ,  8 , MBAY,MBIT)
      CALL PKB(     0 ,  8 , MBAY,MBIT)
      CALL PKB(  MTYP ,  8 , MBAY,MBIT)
      CALL PKB(  MSBT ,  8 , MBAY,MBIT)
      CALL PKB(     4 ,  8 , MBAY,MBIT)
      CALL PKB(  IDXV ,  8 , MBAY,MBIT)
      CALL PKB(    IY ,  8 , MBAY,MBIT)
      CALL PKB(    IM ,  8 , MBAY,MBIT)
      CALL PKB(    ID ,  8 , MBAY,MBIT)
      CALL PKB(    IH ,  8 , MBAY,MBIT)
      CALL PKB(     0 ,  8 , MBAY,MBIT)
      CALL PKB(     0 ,  8 , MBAY,MBIT)

C  SECTION 3
C  ---------

      CALL PKB(       NBY3 ,   24 , MBAY,MBIT)
      CALL PKB(          0 ,    8 , MBAY,MBIT)
      CALL PKB(          1 ,   16 , MBAY,MBIT)
      CALL PKB(       2**7 ,    8 , MBAY,MBIT)
      DO I=1,LDXS
      CALL PKB(IUPM(DXSTR(IDXS)(I:I),8),8,MBAY,MBIT)
      ENDDO
      CALL PKB(          0 ,    8 , MBAY,MBIT)

C  SECTION 4
C  ---------

      MB4 = MBIT/8+1
      CALL PKB(NBY4 , 24 , MBAY,MBIT)
      CALL PKB(   0 ,  8 , MBAY,MBIT)
      MBA = MBIT/8+1
      CALL PKB(   0 ,  8 , MBAY,MBIT)
      MBB = MBIT/8+1
      CALL PKB(   0 ,  8 , MBAY,MBIT)
      MBD = MBIT/8+1
      CALL PKB(   0 ,  8 , MBAY,MBIT)

      IF(MBIT/8+NBY5.NE.MBYT) GOTO 901

C  EXITS
C  -----

      RETURN
900   CALL BORT
     . ('BUFRLIB: DXMINI - LENGTH OF SECTION 3 IS NOT A MULTIPLE OF 2')
901   WRITE(BORT_STR,'("BUFRLIB: DXMINI - NUMBER OF BYTES STORED FOR '//
     . 'A MESSAGE (",I6,") IS NOT THE SAME AS FIRST CALCULATED, MBYT '//
     . '(",I6)') MBIT/8+NBY5,MBYT
      CALL BORT(BORT_STR)
      END
      SUBROUTINE ELEMDX(CARD,LUN)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    ELEMDX
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE DECODES THE SCALE FACTOR, REFERENCE VALUE,
C   BIT WIDTH AND UNITS (I.E., THE "ELEMENTS") FROM A TABLE B MNEMONIC
C   DEFINITION CARD THAT WAS PREVIOUSLY READ FROM A USER-SUPPLIED BUFR
C   DICTIONARY TABLE FILE IN CHARACTER FORMAT BY BUFR ARCHIVE LIBRARY
C   SUBROUTINE RDUSDX.  THESE DECODED VALUES ARE THEN ADDED TO THE
C   ALREADY-EXISTING ENTRY FOR THAT MNEMONIC (BUILT IN RDUSDX) WITHIN
C   THE INTERNAL BUFR TABLE B ARRAY TABB(*,LUN) IN COMMON BLOCK
C   /TABABD/.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1995-06-28  J. WOOLLEN -- INCREASED THE SIZE OF INTERNAL BUFR TABLE
C                           ARRAYS IN ORDER TO HANDLE BIGGER FILES
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY; CHANGED CALL FROM BORT TO BORT2
C
C USAGE:    CALL ELEMDX (CARD, LUN)
C   INPUT ARGUMENT LIST:
C     CARD     - CHARACTER*80: MNEMONIC DEFINITION CARD THAT WAS READ
C                FROM A USER-SUPPLIED BUFR DICTIONARY TABLE
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS 
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT2    CAPIT    JSTCHR   JSTNUM
C                               NEMTAB
C    THIS ROUTINE IS CALLED BY: RDUSDX
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MAXTBA=50)
      PARAMETER (MAXTBB=250)
      PARAMETER (MAXTBD=250)

      COMMON /TABABD/ NTBA(0:NFILES),NTBB(0:NFILES),NTBD(0:NFILES),
     .                MTAB(MAXTBA,NFILES),IDNA(MAXTBA,NFILES,2),
     .                IDNB(MAXTBB,NFILES),IDND(MAXTBD,NFILES),
     .                TABA(MAXTBA,NFILES),TABB(MAXTBB,NFILES),
     .                TABD(MAXTBD,NFILES)

      CHARACTER*600 TABD
      CHARACTER*128 BORT_STR1,BORT_STR2
      CHARACTER*128 TABB
      CHARACTER*128 TABA
      CHARACTER*80  CARD
      CHARACTER*24  UNIT
      CHARACTER*11  REFR,REFR_ORIG
      CHARACTER*8   NEMO
      CHARACTER*4   SCAL,SCAL_ORIG
      CHARACTER*3   BITW,BITW_ORIG
      CHARACTER*1   SIGN,TAB

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  CAPTURE THE VARIOUS ELEMENTS CHARACTERISTICS
C  --------------------------------------------

      NEMO = CARD( 3:10)
      SCAL = CARD(14:17)
      REFR = CARD(21:31)
      BITW = CARD(35:37)
      UNIT = CARD(41:64)
c  .... Make sure the units are all capitalized
      CALL CAPIT(UNIT)

C  FIND THE ELEMENT TAG IN TABLE B
C  -------------------------------

C     Note that an entry for this mnemonic should already exist within
C     the internal BUFR Table B array TABB(*,LUN); this entry should
C     have been created by subroutine RDUSDX when the mnemonic and its
C     associated FXY value and description were initially defined within
C     a card read from the "Descriptor Definition" section at the top of
C     the user-supplied BUFR dictionary table in character format.  Now,
C     we need to retrieve the positional index for that entry within
C     TABB(*,LUN) so that we can access the entry and then add the scale
C     factor, reference value, bit width, and units to it.

      CALL NEMTAB(LUN,NEMO,IDSN,TAB,IELE)
      IF(TAB.NE.'B') GOTO 900

C  LEFT JUSTIFY AND STORE CHARACTERISTICS
C  --------------------------------------

      CALL JSTCHR(UNIT)
      TABB(IELE,LUN)(71:94) = UNIT

      SCAL_ORIG=SCAL
      CALL JSTNUM(SCAL,SIGN,IRET)
      IF(IRET.NE.0) GOTO 901
      TABB(IELE,LUN)(95:95) = SIGN
      TABB(IELE,LUN)(96:98) = SCAL

      REFR_ORIG=REFR
      CALL JSTNUM(REFR,SIGN,IRET)
      IF(IRET.NE.0) GOTO 902
      TABB(IELE,LUN)( 99: 99) = SIGN
      TABB(IELE,LUN)(100:109) = REFR

      BITW_ORIG=BITW
      CALL JSTNUM(BITW,SIGN,IRET)
      IF(IRET.NE.0  ) GOTO 903
      IF(SIGN.EQ.'-') GOTO 903
      TABB(IELE,LUN)(110:112) = BITW

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR1,'("BUFRLIB: ELEMDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"MNEMONIC ",A," IS NOT A TABLE B ENTRY '//
     . '(UNDEFINED, TAB=",A,")")') NEMO,TAB
      CALL BORT2(BORT_STR1,BORT_STR2)
901   WRITE(BORT_STR1,'("BUFRLIB: ELEMDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"PARSED SCALE VALUE (=",A,") IS NOT '//
     . 'NUMERIC")') SCAL_ORIG
      CALL BORT2(BORT_STR1,BORT_STR2)
902   WRITE(BORT_STR1,'("BUFRLIB: ELEMDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"PARSED REFERENCE VALUE (=",A,") IS NOT '//
     . 'NUMERIC")') REFR_ORIG
      CALL BORT2(BORT_STR1,BORT_STR2)
903   WRITE(BORT_STR1,'("BUFRLIB: ELEMDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"PARSED BIT WIDTH VALUE (=",A,") IS NOT '//
     . 'NUMERIC")') BITW_ORIG
      CALL BORT2(BORT_STR1,BORT_STR2)
      END
      SUBROUTINE GETWIN(NODE,LUN,IWIN,JWIN)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    GETWIN (docblock incomplete)
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE ....
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2002-05-14  J. WOOLLEN -- REMOVED OLD CRAY COMPILER DIRECTIVES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY) (INCOMPLETE); OUTPUTS MORE
C                           COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL GETWIN (NODE, LUN, IWIN, JWIN)
C   INPUT ARGUMENT LIST:
C     NODE     - INTEGER: ....
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     IWIN     - INTEGER: ....
C     JWIN     - INTEGER: ....
C
C   OUTPUT ARGUMENT LIST:
C     IWIN     - INTEGER: ....
C     JWIN     - INTEGER: ....
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     INVWIN   LSTRPC
C    THIS ROUTINE IS CALLED BY: CONWIN   UFBEVN   UFBIN3   UFBRW
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)

      CHARACTER*128 BORT_STR
      REAL*8        VAL

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      IRPC = LSTRPC(NODE,LUN)

      IF(IRPC.EQ.0) THEN
         IWIN = INVWIN(NODE,LUN,JWIN,NVAL(LUN))
         IF(IWIN.EQ.0 .and. jwin.gt.1) GOTO 100
         IWIN = 1
         JWIN = NVAL(LUN)
         GOTO 100
      ELSE
         IWIN = INVWIN(IRPC,LUN,JWIN,NVAL(LUN))
         IF(IWIN.EQ.0) THEN
            GOTO 100
         ELSEIF(VAL(IWIN,LUN).EQ.0.) THEN
            IWIN = 0
            GOTO 100
         ENDIF
      ENDIF

      JWIN = INVWIN(IRPC,LUN,IWIN+1,NVAL(LUN))
      IF(JWIN.EQ.0) GOTO 900

C  EXITS
C  -----

100   RETURN
900   WRITE(BORT_STR,'("BUFRLIB: GETWIN - SEARCHED BETWEEN",I5," AND"'//
     . ',I5,", MISSING BRACKET")') IWIN+1,NVAL(LUN)
      CALL BORT(BORT_STR)
      END
      FUNCTION I4DY(IDATE)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    I4DY
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1998-07-08
C
C ABSTRACT: THIS FUNCTION CONVERTS AN EIGHT DIGIT INTEGER DATE
C   (YYMMDDHH) TO TEN DIGITS (YYYYMMDDHH) USING THE Y2K "WINDOWING"
C   TECHNIQUE.  ALL TWO-DIGIT YEARS GREATER THAN "20" ARE ASSUMED TO
C   HAVE A FOUR-DIGIT YEAR BEGINNING WITH "19" (1921-1999) AND ALL TWO-
C   DIGIT YEARS LESS THAN OR EQUAL TO "20" ARE ASSUMED TO HAVE A FOUR-
C   DIGIT YEAR BEGINNING WITH "20" (2000-2020).  IF THE INPUT DATE IS
C   ALREADY TEN DIGITS, THIS ROUTINE JUST RETURNS ITS VALUE.
C
C PROGRAM HISTORY LOG:
C 1998-07-08  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-11-24  J. WOOLLEN -- MODIFIED TO CONFORM TO THE NCEP 2-DIGIT
C                           YEAR TIME WINDOW OF 1921-2020 (BUT
C                           INADVERTENTLY SET TO 1911-2010)
C 1998-12-14  J. WOOLLEN -- MODIFIED TO USE 20 AS THE 2-DIGIT YEAR FOR
C                           WINDOWING TO A 4-DIGIT YEAR (00-20 ==> ADD
C                           2000; 21-99 ==> ADD 1900), THIS WINDOWING
C                           TECHNIQUE WAS INADVERTENTLY CHANGED TO 10
C                           IN THE PREVIOUS IMPLEMENTATION OF I4DY
C                           (1998-11-24)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MODIFIED DATE CALCULATIONS TO NO LONGER USE
C                           FLOATING POINT ARITHMETIC SINCE THIS CAN
C                           LEAD TO ROUND OFF ERROR AND AN IMPROPER
C                           RESULTING DATE ON SOME MACHINES (E.G.,
C                           NCEP IBM FROST/SNOW), INCREASES
C                           PORTABILITY; UNIFIED/PORTABLE FOR WRF;
C                           ADDED DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    I4DY (IDATE)
C   INPUT ARGUMENT LIST:
C     IDATE    - INTEGER: DATE (EITHER YYMMDDHH OR YYYYMMDDHH),
C                DEPENDING ON DATELEN() VALUE 
C
C   OUTPUT ARGUMENT LIST:
C     I4DY     - INTEGER: DATE (YYYYMMDDHH)
C
C REMARKS:
C    THIS ROUTINE CALLS:        None
C    THIS ROUTINE IS CALLED BY: CKTABA   CMSGINI  DATEBF   DUMPBF
C                               OPENMB   OPENMG   REWNBF   XMSGINI
C                               Also called by application programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      IF(IDATE.LT.10**8) THEN
         IY = IDATE/10**6
         IF(IY.GT.20) I4DY = IDATE + 19*100000000
         IF(IY.LE.20) I4DY = IDATE + 20*100000000
      ELSE
         I4DY = IDATE
      ENDIF

      RETURN
      END
      FUNCTION ICOPYSB(LUNIN,LUNOT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    ICOPYSB
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION CALLS BUFR ARCHIVE LIBRARY SUBROUTINE COPYSB
C   AND PASSES BACK ITS RETURN CODE.  SEE COPYSB FOR MORE DETAILS.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR (ENTRY POINT IN IREADMG)
C 2002-05-14  J. WOOLLEN -- CHANGED FROM AN ENTRY POINT TO INCREASE
C                           PORTABILITY TO OTHER PLATFORMS
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    ICOPYSB (LUNIN, LUNOT)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR INPUT BUFR
C                FILE
C     LUNOT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR OUTPUT BUFR
C                FILE
C
C   OUTPUT ARGUMENT LIST:
C     ICOPYSB  - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = there are no more subsets in the input
C                           BUFR message
C
C REMARKS:
C    THIS ROUTINE CALLS:        COPYSB
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CALL COPYSB(LUNIN,LUNOT,IRET)
      ICOPYSB = IRET
      RETURN
      END
      FUNCTION IDN30(ADN30,L30)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    IDN30
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION CONVERTS A DESCRIPTOR FROM ITS FIVE OR SIX
C   CHARACTER ASCII REPRESENTATION TO ITS BIT-WISE (INTEGER)
C   REPRESENTATION.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    IDN30 (ADN30, L30)
C   INPUT ARGUMENT LIST:
C     ADN30    - CHARACTER*(*): CHARACTER FORM OF DESCRIPTOR (FXY
C                VALUE)
C     L30      - INTEGER: LENGTH OF ADN30 (NUMBER OF CHARACTERS, 5 OR
C                6)
C
C   OUTPUT ARGUMENT LIST:
C     IDN      - INTEGER: BIT-WISE REPRESENTATION OF DESCRIPTOR (FXY)
C                VALUE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     ADN30    IFXY
C    THIS ROUTINE IS CALLED BY: RDBFDX
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)

      CHARACTER*(*) ADN30
      CHARACTER*128 BORT_STR

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      IF(LEN(ADN30).LT.L30) GOTO 900
      IF(L30.EQ.5) THEN
         READ(ADN30,'(I5)') IDN30
         IF(IDN30.LT.0 .OR. IDN30.GT.65535) GOTO 901
      ELSEIF(L30.EQ.6) THEN
         IDN30 = IFXY(ADN30)
      ELSE
         GOTO 902
      ENDIF

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: IDN30 - FUNCTION INPUT STRING ",A,'//
     . '" CHARACTER LENGTH (",I4,") IS TOO SHORT (< L30,",I5)')
     . ADN30,LEN(ADN30),L30
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: IDN30 - DESCRIPTOR INTEGER '//
     . 'REPRESENTATION, IDN30 (",I8,"), IS OUTSIDE 16-BIT RANGE '//
     . '(0-65535)")') IDN30
      CALL BORT(BORT_STR)
902   WRITE(BORT_STR,'("BUFRLIB: IDN30 - FUNCTION INPUT STRING ",A,'//
     . '" CHARACTER LENGTH (",I4,") MUST BE EITHER 5 OR 6")')
     . ADN30,L30
      CALL BORT(BORT_STR)
      END
      FUNCTION IFBGET(LUNIT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    IFBGET
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION CHECKS TO SEE IF ANY UNREAD SUBSETS ARE IN
C   AN INPUT BUFR MESSAGE PREVIOUSLY OPENED BY BUFR ARCHIVE LIBRARY
C   SUBROUTINE OPENMG OR OPENMB.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    IFBGET (LUNIT)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     IFBGET   - INTEGER: RETURN CODE:
C                       0 = there is at least one more subset in the
C                           message
C                      -1 = there are no more subsets in the message
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     STATUS
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  MAKE SURE A FILE/MESSAGE IS OPEN FOR INPUT
C  ------------------------------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      IF(IM.EQ.0) GOTO 902

C  SEE IF THERE IS ANOTHER SUBSET IN THE MESSAGE
C  ---------------------------------------------

      IF(NSUB(LUN).LT.MSUB(LUN)) THEN
         IFBGET = 0
      ELSE
         IFBGET = -1
      ENDIF

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: IFBGET - INPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: IFBGET - INPUT BUFR FILE IS OPEN FOR '//
     . 'OUTPUT, IT MUST BE OPEN FOR INPUT')
902   CALL BORT('BUFRLIB: IFBGET - A MESSAGE MUST BE OPEN IN INPUT '//
     . 'BUFR FILE, NONE ARE')
      END
      FUNCTION IFXY(ADSC)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    IFXY
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION RETURNS THE INTEGER CORRESPONDING TO THE
C   BIT-WISE REPRESENTATION OF AN INPUT CHARACTER FXY VALUE OF LENGTH
C   SIX.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION
C
C USAGE:    IFXY (ADSC)
C   INPUT ARGUMENT LIST:
C     ADSC     - CHARACTER*6: CHARACTER FORM OF DESCRIPTOR (FXY VALUE)
C
C   OUTPUT ARGUMENT LIST:
C     IFXY     - INTEGER: BIT-WISE REPRESENTATION OF DESCRIPTOR (FXY)
C                VALUE
C
C REMARKS:
C
C      EXAMPLE:
C
C      If ADSC = '063022', then IFXY = 16150 since:
C
C      0       63           22
C
C      F |     X     |       Y
C        |           |
C     0 0 1 1 1 1 1 1 0 0 0 1 0 1 1 0  =
C
C      ( 2**13 + 2**12 + 2**11 + 2**10 +
C              2**9 + 2**8 + 2**4 + 2**2 + 2**1 )  = 16150
C
C
C    THIS ROUTINE CALLS:        None
C    THIS ROUTINE IS CALLED BY: BFRINI   DXINIT   IDN30    NEMTAB
C                               NEMTBB   NEMTBD   RDBFDX   RDUSDX
C                               UFBQCP   XMSGINI
C                               Normally not called by any application
C                               programs but it could be.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*6 ADSC

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      READ(ADSC,'(I1,I2,I3)') IF,IX,IY
      IFXY = IF*2**14 + IX*2**8 + IY
      RETURN
      END
      SUBROUTINE INCTAB(ATAG,ATYP,NODE)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    INCTAB
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE RETURNS THE NEXT AVAILABLE POSITIONAL INDEX
C   FOR WRITING INTO THE INTERNAL JUMP/LINK TABLE IN COMMON BLOCK
C   /TABLES/, AND IT ALSO USES THAT INDEX TO STORE ATAG AND ATYP
C   WITHIN, RESPECTIVELY, THE INTERNAL JUMP/LINK TABLE ARRAYS TAG(*)
C   AND TYP(*).  IF THERE IS NO MORE ROOM FOR ADDITIONAL ENTRIES WITHIN
C   THE INTERNAL JUMP/LINK TABLE, THEN AN APPROPRIATE CALL IS MADE TO
C   BUFR ARCHIVE LIBRARY SUBROUTINE BORT.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED HISTORY DOCUMENTATION; OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL INCTAB (ATAG, ATYP, NODE)
C   INPUT ARGUMENT LIST:
C     ATAG     - CHARACTER*(*): MNEMONIC NAME
C     ATYP     - CHARACTER*(*): MNEMONIC TYPE
C
C   OUTPUT ARGUMENT LIST:
C     NODE     - INTEGER: NEXT AVAILABLE POSITIONAL INDEX FOR WRITING
C                INTO THE INTERNAL JUMP/LINK TABLE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT
C    THIS ROUTINE IS CALLED BY: TABENT   TABSUB
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)

      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)

      CHARACTER*(*) ATAG,ATYP
      CHARACTER*128 BORT_STR
      CHARACTER*10  TAG
      CHARACTER*3   TYP

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      NTAB = NTAB+1
      IF(NTAB.GT.MAXTAB) GOTO 900
      TAG(NTAB) = ATAG
      TYP(NTAB) = ATYP
      NODE = NTAB

C  EXITS
C  -----

      RETURN
 900  WRITE(BORT_STR,'("BUFRLIB: INCTAB - THE NUMBER OF JUMP/LINK '//
     . 'TABLE ENTRIES EXCEEDS THE LIMIT, MAXTAB (",I7,")")') MAXTAB
      CALL BORT(BORT_STR)
      END
      FUNCTION INVCON(NC,LUN,INV1,INV2)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    INVCON (docblock incomplete)
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION ....
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- IMPROVED MACHINE PORTABILITY
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY) (INCOMPLETE);  OUTPUTS MORE
C                           COMPLETE DIAGNOSTIC INFO WHEN UNUSUAL
C                           THINGS HAPPEN
C
C USAGE:    INVCON (NC, LUN, INV1, INV2)
C   INPUT ARGUMENT LIST:
C     NC       - INTEGER: ....
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     INV1     - INTEGER: ....
C     INV2     - INTEGER: ....
C
C   OUTPUT ARGUMENT LIST:
C     INVCON   - INTEGER: ....
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        None
C    THIS ROUTINE IS CALLED BY: CONWIN
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /USRSTR/ NNOD,NCON,NODS(20),NODC(10),IVLS(10),KONS(10)
      COMMON /QUIET / IPRT

      REAL*8 VAL

C----------------------------------------------------------------------
C----------------------------------------------------------------------

C  CHECK THE INVENTORY INTERVAL
C  ----------------------------

      IF(INV1.LE.0 .OR. INV1.GT.NVAL(LUN)) GOTO 99
      IF(INV2.LE.0 .OR. INV2.GT.NVAL(LUN)) GOTO 99

C  FIND AN OCCURANCE OF NODE IN THE WINDOW MEETING THIS CONDITION
C  --------------------------------------------------------------

      DO INVCON=INV1,INV2
      IF(INV(INVCON,LUN).EQ.NODC(NC)) THEN
         IF(KONS(NC).EQ.1 .AND. VAL(INVCON,LUN).EQ.IVLS(NC)) GOTO 100
         IF(KONS(NC).EQ.2 .AND. VAL(INVCON,LUN).NE.IVLS(NC)) GOTO 100
         IF(KONS(NC).EQ.3 .AND. VAL(INVCON,LUN).LT.IVLS(NC)) GOTO 100
         IF(KONS(NC).EQ.4 .AND. VAL(INVCON,LUN).GT.IVLS(NC)) GOTO 100
      ENDIF
      ENDDO

99    INVCON = 0
      IF(IPRT.GE.2) THEN
      PRINT*
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
         PRINT*, 'BUFRLIB: INVCON - INVCON RETURNING WITH VALUE OF 0'
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT*
      ENDIF

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE INVMRG(LUBFI,LUBFJ)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    INVMRG
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1996-10-09
C
C ABSTRACT: THIS SUBROUTINE MERGES "PARTS" OF SUBSETS WHICH HAVE
C   DUPLICATE SPACE AND TIME COORDINATES BUT DIFFERENT OR UNIQUE
C   OBSERVATIONAL DATA.  IT CANNOT MERGE REPLICATED DATA.
C
C PROGRAM HISTORY LOG:
C 1996-10-09  J. WOOLLEN -- ORIGINAL AUTHOR
C 1996-11-25  J. WOOLLEN -- MODIFIED FOR RADIOSONDE CALL SIGNS
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2002-05-14  J. WOOLLEN -- REMOVED OLD CRAY COMPILER DIRECTIVES;
C                           REMOVED ENTRY POINT MRGINV (IT BECAME A
C                           SEPARATE ROUTINE IN THE BUFRLIB TO
C                           INCREASE PORTABILITY TO OTHER PLATFORMS)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY); OUTPUTS MORE COMPLETE DIAGNOSTIC
C                           INFO WHEN ROUTINE TERMINATES ABNORMALLY
C
C USAGE:    CALL INVMRG (LUBFI, LUBFJ)
C   INPUT ARGUMENT LIST:
C     LUBFI    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR INPUT BUFR
C                FILE
C     LUBFJ    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR OUTPUT BUFR
C                FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     NWORDS   STATUS
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /MRGCOM/ NRPL,NMRG,NAMB,NTOT
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)

      CHARACTER*128 BORT_STR
      CHARACTER*10  TAG
      CHARACTER*3   TYP
      LOGICAL       HEREI,HEREJ,MISSI,MISSJ,SAMEI
      REAL*8        VAL,BMISS

      DATA BMISS /10E10/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IS = 1
      JS = 1

C  GET THE UNIT POINTERS
C  ---------------------

      CALL STATUS(LUBFI,LUNI,IL,IM)
      CALL STATUS(LUBFJ,LUNJ,JL,JM)

C  STEP THROUGH THE BUFFERS COMPARING THE INVENTORY AND MERGING DATA
C  -----------------------------------------------------------------

      DO WHILE(IS.LE.NVAL(LUNI))

C  CHECK TO SEE WE ARE AT THE SAME NODE IN EACH BUFFER
C  ---------------------------------------------------

      NODE = INV(IS,LUNI)
      NODJ = INV(JS,LUNJ)
      IF(NODE.NE.NODJ) GOTO 900

      ITYP = ITP(NODE)

C  FOR TYPE 1 NODES DO AN ENTIRE SEQUENCE REPLACEMENT
C  --------------------------------------------------

      IF(ITYP.EQ.1) THEN
         IF(TYP(NODE).EQ.'DRB') IOFF = 0
         IF(TYP(NODE).NE.'DRB') IOFF = 1
         IWRDS = NWORDS(IS,LUNI)+IOFF
         JWRDS = NWORDS(JS,LUNJ)+IOFF
         IF(IWRDS.GT.IOFF .AND. JWRDS.EQ.IOFF) THEN
            DO N=NVAL(LUNJ),JS+1,-1
            INV(N+IWRDS-JWRDS,LUNJ) = INV(N,LUNJ)
            VAL(N+IWRDS-JWRDS,LUNJ) = VAL(N,LUNJ)
            ENDDO
            DO N=0,IWRDS
            INV(JS+N,LUNJ) = INV(IS+N,LUNI)
            VAL(JS+N,LUNJ) = VAL(IS+N,LUNI)
            ENDDO
            NVAL(LUNJ) = NVAL(LUNJ)+IWRDS-JWRDS
            JWRDS = IWRDS
            NRPL = NRPL+1
         ENDIF
         IS = IS+IWRDS
         JS = JS+JWRDS
      ENDIF

C  FOR TYPES 2 AND 3 FILL MISSINGS
C  -------------------------------

      IF(ITYP.EQ.2) THEN
         HEREI = VAL(IS,LUNI).LT.BMISS
         HEREJ = VAL(JS,LUNJ).LT.BMISS
         MISSI = VAL(IS,LUNI).GE.BMISS
         MISSJ = VAL(JS,LUNJ).GE.BMISS
         SAMEI = VAL(IS,LUNI).EQ.VAL(JS,LUNJ)
         IF(HEREI.AND.MISSJ) THEN
            VAL(JS,LUNJ) = VAL(IS,LUNI)
            NMRG = NMRG+1
         ELSEIF(HEREI.AND.HEREJ.AND..NOT.SAMEI) THEN
            NAMB = NAMB+1
         ENDIF
      ENDIF

      IF(ITYP.EQ.3) THEN
         HEREI = VAL(IS,LUNI).NE.BMISS
         HEREJ = VAL(JS,LUNJ).NE.BMISS
         MISSI = VAL(IS,LUNI).EQ.BMISS
         MISSJ = VAL(JS,LUNJ).EQ.BMISS
         SAMEI = VAL(IS,LUNI).EQ.VAL(JS,LUNJ)
         IF(HEREI.AND.MISSJ) THEN
            VAL(JS,LUNJ) = VAL(IS,LUNI)
            NMRG = NMRG+1
         ELSEIF(HEREI.AND.HEREJ.AND..NOT.SAMEI) THEN
            NAMB = NAMB+1
         ENDIF
      ENDIF

C  BUMP THE COUNTERS AND GO CHECK THE NEXT PAIR
C  --------------------------------------------

      IS = IS + 1
      JS = JS + 1
      ENDDO

      NTOT = NTOT+1

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: INVMRG - NODE FROM INPUT BUFR FILE '//
     . '(",I7,") DOES NOT EQUAL NODE FROM OUTPUT BUFR FILE (",I7,"), '//
     . 'TABULAR MISMATCH")') NODE,NODJ
      CALL BORT(BORT_STR)
      END
      FUNCTION INVTAG(NODE,LUN,INV1,INV2)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    INVTAG (docblock incomplete)
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION ....
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY) (INCOMPLETE); OUTPUTS MORE
C                           COMPLETE DIAGNOSTIC INFO WHEN UNUSUAL
C                           THINGS HAPPEN
C
C USAGE:    INVTAG (NODE, LUN, INV1, INV2)
C   INPUT ARGUMENT LIST:
C     NODE     - INTEGER: ....
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     INV1     - INTEGER: ....
C     INV2     - INTEGER: ....
C
C   OUTPUT ARGUMENT LIST:
C     INVTAG   - INTEGER: ....
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        None
C    THIS ROUTINE IS CALLED BY: UFBRP    UFBSEQ   UFBSP
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /QUIET/  IPRT

      CHARACTER*10 TAG,TAGN
      CHARACTER*3  TYP
      REAL*8       VAL

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      INVTAG = 0
      IF(NODE.EQ.0) GOTO 200
      TAGN = TAG(NODE)

C  SEARCH BETWEEN INV1 AND INV2
C  ----------------------------

10    DO INVTAG=INV1,INV2
      IF(TAG(INV(INVTAG,LUN)).EQ.TAGN) GOTO 100
      ENDDO

      INVTAG = 0

200   IF(IPRT.GE.2) THEN
      PRINT*
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
         PRINT*, 'BUFRLIB: INVTAG - INVTAG RETURNING WITH VALUE OF 0'
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT*
      ENDIF

C  EXIT
C  ----

100   RETURN
      END
      FUNCTION INVWIN(NODE,LUN,INV1,INV2)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    INVWIN (docblock incomplete)
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION ....
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY) (INCOMPLETE); OUTPUTS MORE
C                           COMPLETE DIAGNOSTIC INFO WHEN UNUSUAL
C                           THINGS HAPPEN
C
C USAGE:    INVWIN (NODE, LUN, INV1, INV2)
C   INPUT ARGUMENT LIST:
C     NODE     - INTEGER: ....
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     INV1     - INTEGER: ....
C     INV2     - INTEGER: ....
C
C   OUTPUT ARGUMENT LIST:
C     INVWIN   - INTEGER: ....
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        None
C    THIS ROUTINE IS CALLED BY: CONWIN   DRSTPL   GETWIN   NEVN
C                               TRYBUMP  UFBGET   UFBRW    UFBSEQ
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /QUIET/  IPRT

      REAL*8 VAL

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      INVWIN = 0
      IF(NODE.EQ.0) GOTO 200

C  SEARCH BETWEEN INV1 AND INV2
C  ----------------------------

10    DO INVWIN=INV1,INV2
      IF(INV(INVWIN,LUN).EQ.NODE) GOTO 100
      ENDDO

      INVWIN = 0

 200  IF(IPRT.GE.2) THEN
      PRINT*
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
         PRINT*, 'BUFRLIB: INVWIN - INVWIN RETURNING WITH VALUE OF 0'
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT*
      ENDIF

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE IPKM(CBAY,NBYT,N)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    IPKM
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE PACKS AN INTEGER N INTO A CHARACTER STRING
C   CBAY OF LENGTH NBYT BYTES.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  J. WOOLLEN -- BIG-ENDIAN/LITTLE-ENDIAN INDEPENDENT (WAS
C                           IN DECODER VERSION)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL IPKM (CBAY, NBYT, N)
C   INPUT ARGUMENT LIST:
C     NBYT     - INTEGER: NUMBER OF BYTES INTO WHICH TO PACK N (LENGTH
C                OF STRING)
C     N        - INTEGER: INTEGER TO BE PACKED
C
C   OUTPUT ARGUMENT LIST:
C     CBAY     - CHARACTER*8: STRING OF LENGTH NBYT BYTES CONTAINING
C                PACKED INTEGER N 
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     IREV
C    THIS ROUTINE IS CALLED BY: BFRINI   CHRTNA   PKC      PKTDD
C                               UPC      WRITDX
C                               Normally not called by any application
C                               programs but it could be with COMMON
C                               block /HRDWRD/.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)

      CHARACTER*128 BORT_STR
      CHARACTER*8   CBAY,CINT
      EQUIVALENCE   (CINT,INT)

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      IF(NBYT.GT.NBYTW) GOTO 900

C     Note that the widths of input variable N and local variable INT
C     will both be equal to the default size of an integer (= NBYTW),
C     since they aren't specifically declared otherwise.

      INT = IREV(ISHFT(N,(NBYTW-NBYT)*8))
c  .... big-endian only form commented out
cccc  INT = ISHFT(N,(NBYTW-NBYT)*8)
      DO I=1,NBYT
      CBAY(I:I) = CINT(I:I)
      ENDDO

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: IPKM - NUMBER OF BYTES BEING PACKED '//
     . ', NBYT (",I4,"), IS > THE INTEGER WORD LENGTH ON THIS '//
     . 'MACHINE, NBYTW (",I3,")")') NBYT,NBYTW
      CALL BORT(BORT_STR)
      END
      FUNCTION IRDERM(LUNIT,MBAY)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    IRDERM
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION READS A BUFR MESSAGE INTO A MESSAGE BUFFER.
C   IT IS DESIGNED TO READ FOREIGN (NON-NCEP) BUFR MESSAGES WHICH MAY
C   NOT BE PADDED.  THIS SUBROUTINE DOES NOT WORK PROPERLY ON ALL
C   PLATFORMS (E.G., IBM).
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1997-07-29  J. WOOLLEN -- MODIFIED TO PROCESS GOES SOUNDINGS FROM
C                           NESDIS
C 1998-07-08  J. WOOLLEN -- CORRECTED SOME MINOR ERRORS
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO FOR
C                           INFORMATIONAL PURPOSES
C
C USAGE:    IRDERM (LUNIT, MBAY)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     MBAY     - INTEGER:(MXMSGL/4)-WORD PACKED BINARY ARRAY
C                CONTAINING BUFR MESSAGE
C     IRDERM   - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = there are no more BUFR messages in LUNIT or
C                           I/O error reading BUFR message
C
C   INPUT FILES:
C     UNIT "LUNIT" - BUFR FILE
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        IUPM
C    THIS ROUTINE IS CALLED BY: READERM
C                               Normally not called by any application
C                               programs but it could be.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  IS NOT PORTABLE TO ALL PLATFORMS (E.G, NCEP IBM-SP)
C
C$$$

      PARAMETER (MXMSGL=20000)

      CHARACTER*4  SEVN
      CHARACTER*1  BAY(8*MXMSGL/4)
      CHARACTER*36 SEC013,SECSAV
      DIMENSION    MBAY(MXMSGL/4),KBAY(MXMSGL/4)
      EQUIVALENCE  (BAY(1),KBAY(1),SEC013)

      COMMON /QUIET / IPRT

      DATA IFIRST/0/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IF(IFIRST.EQ.0) THEN
         IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT 101
101   FORMAT(' BUFRLIB: IRDERM - THIS ROUTINE DOES NOT WORK PROPERLY ',
     . 'ON ALL PLATFORMS - USE READIBM INSTEAD')
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
         IFIRST = 1
      ENDIF

      DO I=1,MXMSGL/4
      KBAY(I) = 0
      ENDDO
      IBSKIP = 0

C  FIND A BUFR MESSAGE
C  -------------------

1     READ(LUNIT,END=200,ERR=200) SEC013(1:32)
      LASTRD = 32
2     IBUFR = INDEX(SEC013(1:32),'BUFR')
      IF(IBUFR.EQ.0) THEN
         IBSKIP = IBSKIP + LASTRD
         IF(INDEX(SEC013(1:32),'B').EQ.0) THEN
            READ(LUNIT,END=200,ERR=200) SEC013(1:32)
            LASTRD = 32
         ELSE IF(SEC013(32:32).EQ.'B') THEN
            SEC013(1:1) = 'B'
            READ(LUNIT,END=200,ERR=200) SEC013(2:32)
            LASTRD = 31
         ELSE IF(INDEX(SEC013(1:32),'BU').EQ.0) THEN
            READ(LUNIT,END=200,ERR=200) SEC013(1:32)
            LASTRD = 32
         ELSE IF(SEC013(31:32).EQ.'BU') THEN
            SEC013(1:2) = 'BU'
            READ(LUNIT,END=200,ERR=200) SEC013(3:32)
            LASTRD = 30
         ELSE IF(INDEX(SEC013(1:32),'BU').LT.30) THEN
            READ(LUNIT,END=200,ERR=200) SEC013(1:32)
            LASTRD = 32
         ELSE IF(SEC013(30:32).EQ.'BUF') THEN
            SEC013(1:3) = 'BUF'
            READ(LUNIT,END=200,ERR=200) SEC013(4:32)
            LASTRD = 29
         ELSE
            READ(LUNIT,END=200,ERR=200) SEC013(1:32)
            LASTRD = 32
         ENDIF
         GOTO 2
      ELSE IF(IBUFR.GT.1) THEN
         SECSAV = SEC013
         SEC013(1:33-IBUFR) = SECSAV(IBUFR:32)
         READ(LUNIT,END=200,ERR=200) SEC013(34-IBUFR:32)
         IBSKIP = IBSKIP + IBUFR - 1
      ENDIF

C  IF THIS IS BUFR RELEASE 0, THE FOLLOWING WILL ACCOUNT FOR SECTION-1
C  -------------------------------------------------------------------

      J = IUPM(BAY(5),24)
      I = J + 8

      IF(J.LE.32) THEN

C  DETERMINE WHETHER BYTE COUNT IS FOR SECTION-0 OR SECTION-1
C  ----------------------------------------------------------

         SEVN = SEC013(J-3:J)
         IF(SEVN.EQ.'7777') THEN
            IF(J.LT.32) THEN
               SECSAV = SEC013
               SEC013(1:32-J) = SECSAV(J+1:32)
            ENDIF
            READ(LUNIT,END=200,ERR=200) SEC013(33-J:32)
            IF(IPRT.GE.0)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
            PRINT*,'SHORT RECORD SKIPPED'
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
            ENDIF
            GOTO 2
         ENDIF

C  IF THIS IS BUFR RELEASE 0, SHIFT BYTES 5 AND UP 4 BYTES TO THE RIGHT
C  --------------------------------------------------------------------

         SECSAV = SEC013
         SEC013(9:36) = SECSAV(5:32)

C  IF SECTION-2 IS ABSENT, BEGIN WITH SECTION-3
C  --------------------------------------------

         IF(IUPM(BAY(16),1).GT.0) THEN
            KCONT = 2
         ELSE
            KCONT = 3
         ENDIF

C  DETERMINE WHETHER SECTION-2 AND SECTION-3 ARE IN BYTES 9-36
C  -----------------------------------------------------------

         KREST = 0
         DO K=KCONT,3
         IF(I.LE.33) THEN
            I = I + IUPM(BAY(I+1),24)
            IF(I.GT.36) THEN
               READ(LUNIT,END=200,ERR=200) (BAY(J),J=37,I)
            ENDIF
            KREST = K + 1
         ELSE IF(I.LE.35) THEN
            READ(LUNIT,END=200,ERR=200) (BAY(J),J=37,I+3),
     .                  (BAY(J),J=I+4,I+IUPM(BAY(I+1),24))
            I = I + IUPM(BAY(I+1),24)
            KREST = K + 1
         ENDIF
         ENDDO
         IF(KREST.NE.0) KCONT = KREST
      ELSE
         READ(LUNIT,END=200,ERR=200) (BAY(K),K=33,J)

C  DETERMINE WHETHER BYTE COUNT IS FOR SECTION-0 OR SECTION-1
C  ----------------------------------------------------------

         SEVN = BAY(J-3)//BAY(J-2)//BAY(J-1)//BAY(J)
         IF(SEVN.EQ.'7777') GOTO 50

C  IF THIS IS BUFR RELEASE 0, SHIFT BYTES 5 AND UP 4 BYTES TO THE RIGHT
C  --------------------------------------------------------------------

         READ(LUNIT,END=200,ERR=200) (BAY(K),K=J+5,J+8)
         DO K=J,33,-1
         BAY(K+4) = BAY(K)
         ENDDO
         SECSAV = SEC013
         SEC013(9:36) = SECSAV(5:32)

C  IF SECTION-2 IS ABSENT, BEGIN WITH SECTION-3
C  --------------------------------------------

         IF(IUPM(BAY(16),1).GT.0) THEN
            KCONT = 2
         ELSE
            KCONT = 3
         ENDIF

      ENDIF

C  FOR REMAINING SECTIONS (UP TO SECTION-4) READ BYTE COUNT AND BYTES
C  ------------------------------------------------------------------

      DO K=KCONT,4
      READ(LUNIT,END=200,ERR=200) (BAY(J),J=I+1,I+3),
     .            (BAY(J),J=I+4,I+IUPM(BAY(I+1),24))
      I = I + IUPM(BAY(I+1),24)
      ENDDO

C  CHECK ON SECTION 5 FOR BAD RECORD INDICATOR
C  -------------------------------------------

      READ(LUNIT,END=200,ERR=200) SEVN
      IF(SEVN.NE.'7777') THEN
         IF(IPRT.GE.0)  THEN
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
         PRINT*,'BUFRLIB: IRDERM - BAD RECORD SKIPPED'
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
         ENDIF
         GOTO 1
      ENDIF
      I = I+4

C  FILL IN THE ARRAY TO RETURN
C  ---------------------------

50    DO I=1,MXMSGL/4
      MBAY(I) = KBAY(I)
      ENDDO

      IRDERM =  0
      GOTO 100

200   IRDERM = -1

C  EXIT
C  ----

100   RETURN
      END
      FUNCTION IREADERM(LUNIT,SUBSET,IDATE)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    IREADERM
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION CALLS BUFR ARCHIVE LIBRARY SUBROUTINE READERM
C   AND PASSES BACK ITS RETURN CODE.  SEE READERM FOR MORE DETAILS.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 2002-05-14  J. WOOLLEN -- REMOVED ENTRY POINT IREADERS (IT BECAME A
C                           SEPARATE ROUTINE IN THE BUFRLIB TO
C                           INCREASE PORTABILITY TO OTHER PLATFORMS)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    IREADERM (LUNIT, SUBSET, IDATE)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     SUBSET   - CHARACTER*8: TABLE A MNEMONIC FOR TYPE OF BUFR MESSAGE
C                BEING READ
C     IDATE    - INTEGER: DATE-TIME STORED WITHIN SECTION 1 OF BUFR
C                MESSAGE BEING READ, IN FORMAT OF EITHER YYMMDDHH OR
C                YYYYMMDDHH, DEPENDING ON DATELEN() VALUE
C     IREADERM - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = there are no more BUFR messages in LUNIT
C
C REMARKS:
C    THIS ROUTINE CALLS:        READERM
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*8 SUBSET
      CALL READERM(LUNIT,SUBSET,IDATE,IRET)
      IREADERM = IRET
      RETURN
      END
      FUNCTION IREADERS(LUNIT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    IREADERS
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1996-10-09
C
C ABSTRACT: THIS FUNCTION CALLS BUFR ARCHIVE LIBRARY SUBROUTINE READERS
C   AND PASSES BACK ITS RETURN CODE.  SEE READERS FOR MORE DETAILS.
C
C PROGRAM HISTORY LOG:
C 1996-10-09  J. WOOLLEN -- ORIGINAL AUTHOR (ENTRY POINT IN IREADERM)
C 2002-05-14  J. WOOLLEN -- CHANGED FROM AN ENTRY POINT TO INCREASE
C                           PORTABILITY TO OTHER PLATFORMS
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    IREADERS (LUNIT)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     IREADERS - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = there are no more subsets in the BUFR
C                           message
C
C REMARKS:
C    THIS ROUTINE CALLS:        READERS
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CALL READERS(LUNIT,IRET)
      IREADERS = IRET
      RETURN
      END
      FUNCTION IREADFT(LUNIT,SUBSET,IDATE)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    IREADFT
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1996-10-09
C
C ABSTRACT: THIS FUNCTION CALLS BUFR ARCHIVE LIBRARY SUBROUTINE READFT
C   AND PASSES BACK ITS RETURN CODE.  SEE READFT FOR MORE DETAILS.
C
C PROGRAM HISTORY LOG:
C 1996-10-09  J. WOOLLEN -- ORIGINAL AUTHOR (ENTRY POINT IN IREADMG)
C 2002-05-14  J. WOOLLEN -- CHANGED FROM AN ENTRY POINT TO INCREASE
C                           PORTABILITY TO OTHER PLATFORMS
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    IREADFT (LUNIT, SUBSET, IDATE)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     SUBSET   - CHARACTER*8: TABLE A MNEMONIC FOR TYPE OF BUFR MESSAGE
C                BEING READ
C     IDATE    - INTEGER: DATE-TIME STORED WITHIN SECTION 1 OF BUFR
C                MESSAGE BEING READ, IN FORMAT OF EITHER YYMMDDHH OR
C                YYYYMMDDHH, DEPENDING ON DATELEN() VALUE
C     IREADFT  - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = there are no more BUFR messages in LUNIT
C                           or I/O error reading BUFR message
C
C REMARKS:
C    THIS ROUTINE CALLS:        READFT
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*8 SUBSET
      CALL READFT(LUNIT,SUBSET,IDATE,IRET)
      IREADFT = IRET
      RETURN
      END
      FUNCTION IREADIBM(LUNIT,SUBSET,IDATE)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    IREADIBM
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1999-11-18
C
C ABSTRACT: THIS FUNCTION CALLS BUFR ARCHIVE LIBRARY SUBROUTINE READIBM
C   AND PASSES BACK ITS RETURN CODE.  SEE READIBM FOR MORE DETAILS.
C
C PROGRAM HISTORY LOG:
C 1999-11-18  J. WOOLLEN -- ORIGINAL AUTHOR (ENTRY POINT IN IREADMG)
C 2002-05-14  J. WOOLLEN -- CHANGED FROM AN ENTRY POINT TO INCREASE
C                           PORTABILITY TO OTHER PLATFORMS
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    IREADIBM  (LUNIT, SUBSET, IDATE)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     SUBSET   - CHARACTER*8: TABLE A MNEMONIC FOR TYPE OF BUFR MESSAGE
C                BEING READ
C     IDATE    - INTEGER: DATE-TIME STORED WITHIN SECTION 1 OF BUFR
C                MESSAGE BEING READ, IN FORMAT OF EITHER YYMMDDHH OR
C                YYYYMMDDHH, DEPENDING ON DATELEN() VALUE
C     IREADIBM - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = there are no more BUFR messages in LUNIT
C
C REMARKS:
C    THIS ROUTINE CALLS:        READIBM
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*8 SUBSET
      CALL READIBM(LUNIT,SUBSET,IDATE,IRET)
      IREADIBM = IRET
      RETURN
      END
      FUNCTION IREADMG(LUNIT,SUBSET,IDATE)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    IREADMG
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION CALLS BUFR ARCHIVE LIBRARY SUBROUTINE READMG
C   AND PASSES BACK ITS RETURN CODE.  SEE READMG FOR MORE DETAILS.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1999-11-18  J. WOOLLEN -- ADDED NEW FUNCTION ENTRY POINTS IREADMM AND
C                           IREADIBM
C 2002-05-14  J. WOOLLEN -- REMOVED ENTRY POINTS ICOPYSB, IREADFT,
C                           IREADIBM, IREADMM, IREADNS AND IREADSB
C                           (THEY BECAME SEPARATE ROUTINES IN THE
C                           BUFRLIB TO INCREASE PORTABILITY TO OTHER
C                           PLATFORMS)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    IREADMG (LUNIT, SUBSET, IDATE)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     SUBSET   - CHARACTER*8: TABLE A MNEMONIC FOR TYPE OF BUFR MESSAGE
C                BEING READ
C     IDATE    - INTEGER: DATE-TIME STORED WITHIN SECTION 1 OF BUFR
C                MESSAGE BEING READ, IN FORMAT OF EITHER YYMMDDHH OR
C                YYYYMMDDHH, DEPENDING ON DATELEN() VALUE
C     IREADMG  - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = there are no more BUFR messages in LUNIT
C
C REMARKS:
C    THIS ROUTINE CALLS:        READMG
C    THIS ROUTINE IS CALLED BY: COMPRES  UFBTAB
C                               Also called by application programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*8 SUBSET
      CALL READMG(LUNIT,SUBSET,IDATE,IRET)
      IREADMG = IRET
      RETURN
      END
      FUNCTION IREADMM(IMSG,SUBSET,IDATE)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    IREADMM
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1999-11-18
C
C ABSTRACT: THIS FUNCTION CALLS BUFR ARCHIVE LIBRARY SUBROUTINE READMM
C   AND PASSES BACK ITS RETURN CODE.  SEE READMM FOR MORE DETAILS.
C
C PROGRAM HISTORY LOG:
C 1999-11-18  J. WOOLLEN -- ORIGINAL AUTHOR (ENTRY POINT IN IREADMG)
C 2002-05-14  J. WOOLLEN -- CHANGED FROM AN ENTRY POINT TO INCREASE
C                           PORTABILITY TO OTHER PLATFORMS
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    IREADMM (IMSG, SUBSET, IDATE)
C   INPUT ARGUMENT LIST:
C     IMSG     - INTEGER: POINTER TO BUFR MESSAGE NUMBER (RECORD) IN
C                STORAGE 
C
C   OUTPUT ARGUMENT LIST:
C     SUBSET   - CHARACTER*8: TABLE A MNEMONIC FOR TYPE OF BUFR MESSAGE
C                BEING READ
C     IDATE    - INTEGER: DATE-TIME STORED WITHIN SECTION 1 OF BUFR
C                MESSAGE BEING READ, IN FORMAT OF EITHER YYMMDDHH OR
C                YYYYMMDDHH, DEPENDING ON DATELEN() VALUE
C     IREADMM  - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = IMSG is either 0 or greater than the
C                           number of messages in memory
C
C REMARKS:
C    THIS ROUTINE CALLS:        READMM
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*8 SUBSET
      CALL READMM(IMSG,SUBSET,IDATE,IRET)
      IREADMM = IRET
      RETURN
      END
      FUNCTION IREADNS(LUNIT,SUBSET,IDATE)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    IREADNS
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION CALLS BUFR ARCHIVE LIBRARY SUBROUTINE READNS
C   AND PASSES BACK ITS RETURN CODE.  SEE READNS FOR MORE DETAILS.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR (ENTRY POINT IN IREADMG)
C 2002-05-14  J. WOOLLEN -- CHANGED FROM AN ENTRY POINT TO INCREASE
C                           PORTABILITY TO OTHER PLATFORMS
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    IREADNS (LUNIT, SUBSET, IDATE)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     SUBSET   - CHARACTER*8: TABLE A MNEMONIC FOR BUFR MESSAGE
C                CONTAINING SUBSET BEING READ
C     IDATE    - INTEGER: DATE-TIME STORED WITHIN SECTION 1 OF BUFR
C                MESSAGE CONTAINING SUBSET BEING READ, IN FORMAT OF
C                EITHER YYMMDDHH OR YYYYMMDDHH, DEPENDING ON DATELEN()
C                VALUE
C     IREADNS  - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = there are no more subsets in the BUFR file
C
C REMARKS:
C    THIS ROUTINE CALLS:        READNS
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*8 SUBSET
      CALL READNS(LUNIT,SUBSET,IDATE,IRET)
      IREADNS = IRET
      RETURN
      END
      FUNCTION IREADSB(LUNIT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    IREADSB
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION CALLS BUFR ARCHIVE LIBRARY SUBROUTINE READSB
C   AND PASSES BACK ITS RETURN CODE.  SEE READSB FOR MORE DETAILS.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR (ENTRY POINT IN IREADMG)
C 2002-05-14  J. WOOLLEN -- CHANGED FROM AN ENTRY POINT TO INCREASE
C                           PORTABILITY TO OTHER PLATFORMS
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    IREADSB (LUNIT)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     IREADSB  - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = there are no more subsets in the BUFR
C                           message
C
C REMARKS:
C    THIS ROUTINE CALLS:        READSB
C    THIS ROUTINE IS CALLED BY: UFBTAB
C                               Also called by application programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CALL READSB(LUNIT,IRET)
      IREADSB = IRET
      RETURN
      END
      FUNCTION IREV(N)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    IREV
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION WILL, WHEN THE LOCAL MACHINE IS "LITTLE-
C   ENDIAN" (I.E., USES A RIGHT TO LEFT SCHEME FOR NUMBERING THE BYTES
C   WITHIN A MACHINE WORD), RETURN A COPY OF AN INPUT INTEGER WORD WITH
C   THE BYTES REVERSED.  ALTHOUGH, BY DEFINITION (WITHIN WMO MANUAL
C   306), A BUFR MESSAGE IS A STREAM OF INDIVIDUAL OCTETS (I.E., BYTES)
C   THAT IS INDEPENDENT OF ANY PARTICULAR MACHINE REPRESENTATION, THE
C   BUFR ARCHIVE LIBRARY SOFTWARE OFTEN NEEDS TO INTERPRET ALL OR PARTS
C   OF TWO OR MORE ADJACENT BYTES IN ORDER TO CONSTRUCT AN INTEGER
C   WORD.  BY DEFAULT, THE SOFTWARE USES THE "BIG-ENDIAN" (LEFT TO
C   RIGHT) SCHEME FOR NUMBERING BYTES.  BY REVERSING THE BYTES, IREV
C   ALLOWS THE INTEGER WORD TO BE PROPERLY READ OR WRITTEN (DEPENDING
C   ON WHETHER INPUT OR OUTPUT OPERATIONS, RESPECTIVELY, ARE BEING
C   PERFORMED) ON LITTLE-ENDIAN MACHINES.  IF THE LOCAL MACHINE IS
C   BIG-ENDIAN, IREV SIMPLY RETURNS A COPY OF THE SAME INTEGER THAT WAS
C   INPUT.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION
C
C USAGE:    IREV (N)
C   INPUT ARGUMENT LIST:
C     N        - INTEGER: INTEGER WORD WITH BYTES ORDERED ACCORDING TO
C                THE "BIG-ENDIAN" NUMBERING SCHEME
C
C   OUTPUT ARGUMENT LIST:
C     IREV     - INTEGER: INTEGER WORD WITH BYTES ORDERED ACCORDING TO
C                THE NUMBERING SCHEME OF THE LOCAL MACHINE (EITHER
C                "BIG-ENDIAN" OR "LITTLE-ENDIAN", IF "BIG-ENDIAN THEN
C                THIS IS JUST A DIRECT COPY OF N)
C
C REMARKS:
C    THIS ROUTINE CALLS:        None
C    THIS ROUTINE IS CALLED BY: IPKM     IUPM     PKB      PKC
C                               UPB      UPBB
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)

      CHARACTER*8 CINT,DINT
      EQUIVALENCE(CINT,INT)
      EQUIVALENCE(DINT,JNT)

C----------------------------------------------------------------------
C----------------------------------------------------------------------

C     Note that the value of NREV is set within subroutine WRDLEN.

      IF(NREV.EQ.0) THEN
c  .... big-endian
         IREV = N
      ELSE
c  .... little-endian
         INT = N
         DO I=1,NBYTW
         DINT(I:I) = CINT(IORD(I):IORD(I))
         ENDDO
         IREV = JNT
      ENDIF

      RETURN
      END
      FUNCTION IUPB(MBAY,NBYT,NBIT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    IUPB
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION UNPACKS AND RETURNS A BINARY INTEGER WORD
C   CONTAINED WITHIN NBIT BITS OF A BUFR MESSAGE PACKED INTO THE
C   INTEGER ARRAY MBAY, STARTING WITH THE FIRST BIT OF BYTE NBYT.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION
C
C USAGE:    IUPB (MBAY, NBYT, NBIT)
C   INPUT ARGUMENT LIST:
C     MBAY     - INTEGER: *-WORD PACKED BINARY ARRAY CONTAINING BUFR
C                MESSAGE
C     NBYT     - INTEGER: BYTE WITHIN MBAY AT WHOSE FIRST BIT TO BEGIN
C                UNPACKING
C     NBIT     - INTEGER: NUMBER OF BITS WITHIN MBAY TO BE UNPACKED
C
C   OUTPUT ARGUMENT LIST:
C     IUPB     - INTEGER: UNPACKED INTEGER WORD
C
C REMARKS:
C    THIS ROUTINE CALLS:        UPB
C    THIS ROUTINE IS CALLED BY: CKTABA   COMPRES  COPYMG   CPYMEM
C                               CPYUPD   IUPBS1   MSGUPD   MSGWRT
C                               NMBYT    RDMEMS   STANDARD SUBUPD
C                               UPDS3    WRCMPS   WRITLC
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      DIMENSION MBAY(*)

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      MBIT = (NBYT-1)*8
      CALL UPB(IRET,NBIT,MBAY,MBIT)
      IUPB = IRET
      RETURN
      END
      FUNCTION IUPBS1(MBAY,NBYT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    IUPBS1
C   PRGMMR: ATOR             ORG: NP12       DATE: 2003-11-04
C
C ABSTRACT: THIS FUNCTION UNPACKS AND RETURNS THE BINARY INTEGER WORD
C   CONTAINED WITHIN BYTE NBYT OF SECTION 1 OF THE BUFR MESSAGE STORED
C   IN ARRAY MBAY.  THE START OF THE BUFR MESSAGE (I.E., THE STRING
C   "BUFR") MUST BE ALIGNED ON THE FIRST FOUR BYTES OF MBAY.
C
C PROGRAM HISTORY LOG:
C 2003-11-04  J. ATOR    -- ORIGINAL AUTHOR (WAS IN DECODER VERSION)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF
C
C USAGE:    IUPBS1 (MBAY, NBYT)
C   INPUT ARGUMENT LIST:
C     MBAY     - INTEGER: *-WORD PACKED BINARY ARRAY CONTAINING BUFR
C                MESSAGE
C     NBYT     - INTEGER: BYTE WITHIN SECTION 1 OF BUFR TO UNPACK
C
C   OUTPUT ARGUMENT LIST:
C     IUPBS1   - INTEGER: UNPACKED INTEGER WORD
C
C REMARKS:
C    THIS ROUTINE CALLS:        IUPB     WRDLEN
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      DIMENSION MBAY(*)

      DATA IFIRST / 0 /

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C     If this is the first call to this subroutine, then call BUFR
C     Archive Library subroutine WRDLEN to initialize some important
C     information about the local machine, just in case BUFR Archive
C     Library subroutine OPENBF hasn't been called yet.

      IF ( IFIRST .EQ. 0 ) THEN
         CALL WRDLEN
         IFIRST = 1
      ENDIF

C     Note that there are 8 bytes within Section 0 that must be
C     skipped.

      IUPBS1 = IUPB ( MBAY, NBYT+8, 8 )

      RETURN
      END
      FUNCTION IUPM(CBAY,NBITS)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    IUPM
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION UNPACKS AND RETURNS A BINARY INTEGER WORD
C   CONTAINED WITHIN NBITS BITS OF A CHARACTER STRING CBAY, STARTING
C   WITH THE FIRST BIT OF THE FIRST BYTE OF CBAY.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  J. WOOLLEN -- BIG-ENDIAN/LITTLE-ENDIAN INDEPENDENT (WAS
C                           IN DECODER VERSION)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    IUPM (CBAY, NBITS)
C   INPUT ARGUMENT LIST:
C     CBAY     - CHARACTER*8: CHARACTER STRING CONTAINING PACKED
C                INTEGER
C     NBITS    - INTEGER: NUMBER OF BITS WITHIN CBAY TO BE UNPACKED
C
C   OUTPUT ARGUMENT LIST:
C     IUPM     - INTEGER: UNPACKED INTEGER WORD
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT
C    THIS ROUTINE IS CALLED BY: CHRTRNA  DXMINI   IRDERM   LMSG
C                               MESGBF   PKC      PKTDD    RDBFDX
C                               READIBM  UPC      UPTDD    WRDLEN
C                               WRITDX
C                               Normally not called by any application
C                               programs but it could be with COMMON
C                               block /HRDWRD/.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)

      CHARACTER*128 BORT_STR
      CHARACTER*8   CBAY
      CHARACTER*8   CINT
      DIMENSION     INT(2)
      EQUIVALENCE   (CINT,INT)

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      IF(NBITS.GT.NBITW) GOTO 900
      CINT = CBAY
c  .... line below not included in previous big-endian only version
      INT(1) = IREV(INT(1))
      IUPM = ISHFT(INT(1),NBITS-NBITW)

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: IUPM - NUMBER OF BITS BEING UNPACKED'//
     . ', NBITS (",I4,"), IS > THE INTEGER WORD LENGTH ON THIS '//
     . 'MACHINE, NBITW (",I3,")")') NBITS,NBITW
      CALL BORT(BORT_STR)
      END
      SUBROUTINE JSTCHR(STR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    JSTCHR
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE REMOVES ALL LEADING BLANKS FROM A CHARACTER
C   STRING (LEFT JUSTIFIES).  THE RESULTANT STRING MAY CONTAIN ANY
C   VALID ASCII CHARACTER.  IT IS SIMILAR TO BUFR ARCHIVE LIBRARY
C   FUNCTION LJUST, EXCEPT LJUST RETURNS THE ORIGINAL BLANK STRING IN
C   STR IF THE INPUT CHARACTER STRING IS ALL BLANKS WHILE JSTCHR MAKES
C   AN APPROPRIATE CALL TO BUFR ARCHIVE LIBRARY SUBROUTINE BORT IN THIS
C   CASE.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR (ENTRY POINT IN JSTIFY)
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT" (IN PARENT ROUTINE JSTIFY)
C 2002-05-14  J. WOOLLEN -- CHANGED FROM AN ENTRY POINT TO INCREASE
C                           PORTABILITY TO OTHER PLATFORMS (JSTIFY WAS
C                           THEN REMOVED BECAUSE IT WAS JUST A DUMMY
C                           ROUTINE WITH ENTRIES)
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL JSTCHR (STR)
C   INPUT ARGUMENT LIST:
C     STR      - CHARACTER*(*): STRING
C
C   OUTPUT ARGUMENT LIST:
C     STR      - CHARACTER*(*): COPY OF INPUT STR WITH LEADING BLANKS
C                REMOVED
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT
C    THIS ROUTINE IS CALLED BY: ELEMDX
C                               Normally not called by any application
C                               programs but it could be.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*(*) STR

      IF(STR.EQ.' ') GOTO 900

      LSTR = LEN(STR)
1     IF(STR(1:1).EQ.' ') THEN
         STR  = STR(2:LSTR)
         GOTO 1
      ENDIF

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: JSTCHR - INPUT BLANK CHARACTER STRING NOT '//
     . 'ALLOWED')
      END
      SUBROUTINE JSTNUM(STR,SIGN,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    JSTNUM
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE REMOVES ALL LEADING BLANKS FROM A CHARACTER
C   STRING CONTAINING AN ENCODED INTEGER VALUE.  IF THE VALUE HAS A
C   LEADING SIGN CHARACTER ('+' OR '-'), THEN THIS CHARACTER IS ALSO
C   REMOVED AND IS RETURNED SEPARATELY WITHIN SIGN.  IF THE RESULTANT
C   STRING CONTAINS ANY NON-NUMERIC CHARACTERS, THAN AN APPROPRIATE
C   CALL IS MADE TO TO BUFR ARCHIVE LIBRARY SUBROUTINE BORT.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR (ENTRY POINT IN JSTIFY)
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT" (IN PARENT ROUTINE JSTIFY)
C 2002-05-14  J. WOOLLEN -- CHANGED FROM AN ENTRY POINT TO INCREASE
C                           PORTABILITY TO OTHER PLATFORMS (JSTIFY WAS
C                           THEN REMOVED BECAUSE IT WAS JUST A DUMMY
C                           ROUTINE WITH ENTRIES)
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY OR UNUSUAL THINGS HAPPEN
C
C USAGE:    CALL JSTNUM (STR, SIGN, IRET)
C   INPUT ARGUMENT LIST:
C     STR      - CHARACTER*(*): STRING CONTAINING ENCODED INTEGER VALUE
C
C   OUTPUT ARGUMENT LIST:
C     STR      - CHARACTER*(*): COPY OF INPUT STR WITH LEADING BLANKS
C                AND SIGN CHARACTER REMOVED
C     SIGN     - CHARACTER*1: SIGN OF ENCODED INTEGER VALUE:
C                     '+' = positive value
C                     '-' = negative value
C     IRET     - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = encoded value within STR was not an integer
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     STRNUM
C    THIS ROUTINE IS CALLED BY: ELEMDX
C                               Normally not called by any application
C                               programs but it could be.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*(*) STR
      CHARACTER*1  SIGN

      COMMON /QUIET / IPRT

      IRET = 0

      IF(STR.EQ.' ') GOTO 900

      LSTR = LEN(STR)
2     IF(STR(1:1).EQ.' ') THEN
         STR  = STR(2:LSTR)
         GOTO 2
      ENDIF
      IF(STR(1:1).EQ.'+') THEN
         STR  = STR(2:LSTR)
         SIGN = '+'
      ELSEIF(STR(1:1).EQ.'-') THEN
         STR  = STR(2:LSTR)
         SIGN = '-'
      ELSE
         SIGN = '+'
      ENDIF

      CALL STRNUM(STR,NUM)
      IF(NUM.LT.0) THEN
         IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
         PRINT*, 'BUFRLIB: JSTNUM: ENCODED VALUE WITHIN RESULTANT ',
     .    'CHARACTER STRING (',STR,') IS NOT AN INTEGER - RETURN WITH ',
     .    'IRET = -1'
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
         IRET = -1
      ENDIF

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: JSTNUM - INPUT BLANK CHARACTER STRING NOT '//
     . 'ALLOWED')
      END
      FUNCTION LJUST(STR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    LJUST
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1998-07-08
C
C ABSTRACT: THIS FUNCTION REMOVES ALL LEADING BLANKS FROM A CHARACTER
C   STRING (LEFT JUSTIFIES).  THE RESULTANT STRING MAY CONTAIN ANY
C   VALID ASCII CHARACTER.  IT IS SIMILAR TO BUFR ARCHIVE LIBRARY
C   SUBROUTINE JSTCHR, EXCEPT JSTCHR CALLS BUFR ARCHIVE LIBRARY
C   SUBROUTINE BORT IF THE INPUT CHARACTER STRING IS ALL BLANKS WHILE
C   LJUST RETURNS THE ORIGINAL BLANK STRING IN STR IN THIS CASE.
C
C PROGRAM HISTORY LOG:
C 1998-07-08  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    LJUST (STR)
C   INPUT ARGUMENT LIST:
C     STR      - CHARACTER*(*): STRING TO BE LEFT-JUSTIFED
C
C   OUTPUT ARGUMENT LIST:
C     STR      - CHARACTER*(*): LEFT-JUSTIFED STRING (UNLESS INPUT
C                VALUE CONTAINED ALL BLANKS - THEN INPUT VALUE IS
C                RETURNED WITH NO CHANGES)
C     LJUST    - INTEGER: ALWAYS RETURNED AS 0 (DUMMY)
C
C REMARKS:
C    THIS ROUTINE CALLS:        None
C    THIS ROUTINE IS CALLED BY: None at this time
C                               Normally not called by any application
C                               Programs but it could be.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*(*) STR

      LJUST = 0

      IF(STR.EQ.' ') GOTO 100

      LSTR = LEN(STR)
      DO I=1,LSTR
      DO WHILE(STR(I:I).EQ.' ' .AND. STR(I+1:LSTR).NE.' ')
         STR(I:LSTR) = STR(I+1:LSTR)
      ENDDO
      ENDDO

C  EXIT
C  ----

100   RETURN
      END
      FUNCTION LMSG(SEC0)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    LMSG
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION UNPACKS AND RETURNS THE BUFR MESSAGE LENGTH
C   OUT OF SECTION ZERO OF THE BUFR MESSAGE.  THE BUFR FILE SHOULD BE
C   CLOSED.  BUFR ARCHIVE LIBRARY FUNCTION NMBYT ALSO PERFORMS THIS
C   FUNCTION, BUT ON BUFR MESSAGES AND FILES THAT HAVE BEEN OPENED FOR
C   INPUT BY BUFR ARCHIVE LIBRARY SUBROUTINES OPENBF AND READMG OR
C   THEIR EQUIVALENTS.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    LMSG (SEC0)
C   INPUT ARGUMENT LIST:
C     SEC0     - CHARACTER*8: PACKED BUFR MESSAGE SECTION ZERO
C
C   OUTPUT ARGUMENT LIST:
C     LMSG     - INTEGER: BUFR MESSAGE LENGTH (BYTES)
C
C REMARKS:
C    THIS ROUTINE CALLS:        IUPM
C    THIS ROUTINE IS CALLED BY: COMPRES  COPYBF   MESGBF   POSAPN
C                               POSAPX   RDBFDX   READERME READFT
C                               READIBM  READMG   UFBMEM
C                               Also called by application programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)

      CHARACTER*8 SEC0

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IMSG = 8/NBYTW
      LMSG = IUPM(SEC0(5:7),24)/8
      IF(LMSG.EQ.0) GOTO 100
      LMSG = (LMSG+1)*IMSG

C  EXIT
C  ----

100   RETURN
      END
      FUNCTION LSTJPB(NODE,LUN,JBTYP)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    LSTJPB (docblock incomplete)
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION ....
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY) (INCOMPLETE); OUTPUTS MORE
C                           COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    LSTJPB (NODE, LUN, JBTYP)
C   INPUT ARGUMENT LIST:
C     NODE     - INTEGER: ....
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     JBTYP    - CHARACTER*(*): ....
C
C   OUTPUT ARGUMENT LIST:
C     LSTJPB   - INTEGER: ....
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT
C    THIS ROUTINE IS CALLED BY: NEVN     TRYBUMP
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)

      CHARACTER*(*) JBTYP
      CHARACTER*128 BORT_STR
      CHARACTER*10  TAG
      CHARACTER*3   TYP

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      IF(NODE.LT.INODE(LUN)) GOTO 900
      IF(NODE.GT.ISC(INODE(LUN))) GOTO 901

      NOD = NODE

C  FIND THIS OR THE PREVIOUS "JBTYP" NODE
C  --------------------------------------

10    IF(TYP(NOD).NE.JBTYP) THEN
         NOD = JMPB(NOD)
         IF(NOD.NE.0) GOTO 10
      ENDIF

      LSTJPB = NOD

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: LSTJPB - TABLE NODE (",I7,") IS OUT '//
     . 'OF BOUNDS, < LOWER BOUNDS (",I7,"); TAG IS ",A10)')
     . NODE,INODE(LUN),TAG(NODE)
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: LSTJPB - TABLE NODE (",I7,") IS OUT '//
     . 'OF BOUNDS, > UPPER BOUNDS (",I7,"); TAG IS ",A10)')
     . NODE,ISC(INODE(LUN)),TAG(NODE)
      CALL BORT(BORT_STR)
      END
      FUNCTION LSTRPC(NODE,LUN)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    LSTRPC
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION RETURNS THE PREVIOUS REPLICATION FACTOR NODE,
C   GIVEN A NODE IN THE INTERNAL JUMP/LINK INDEX TABLE FOR A PARTICULAR
C   BUFR FILE.  IF THE INPUT NODE IS A REPLICATION FACTOR NODE, THEN IT
C   IS SIMPLY RETUNED AS LSTRPC.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY); OUTPUTS MORE COMPLETE DIAGNOSTIC
C                           INFO WHEN ROUTINE TERMINATES ABNORMALLY
C
C USAGE:    LSTRPC (NODE, LUN)
C   INPUT ARGUMENT LIST:
C     NODE     - INTEGER: POSITIONAL INDEX IN INTERNAL JUMP/LINK TABLE
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C
C   OUTPUT ARGUMENT LIST:
C     LSTRPC   - INTEGER: POSITIONAL INDEX IN INTERNAL JUMP/LINK TABLE
C                FOR PREVIOUS REPLICATION FACTOR NODE
C                    NODE = input node is a replication factor 
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT
C    THIS ROUTINE IS CALLED BY: GETWIN   NEWWIN   NXTWIN   PARUSR
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)

      CHARACTER*128 BORT_STR
      CHARACTER*10  TAG
      CHARACTER*3   TYP

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      IF(NODE.LT.INODE(LUN)) GOTO 900
      IF(NODE.GT.ISC(INODE(LUN))) GOTO 901

      NOD = NODE

C  FIND THIS OR THE PREVIOUS REPLICATION FACTOR (RPC) NODE
C  -------------------------------------------------------

10    IF(TYP(NOD).NE.'RPC') THEN
         NOD = JMPB(NOD)
         IF(NOD.NE.0) GOTO 10
      ENDIF

      LSTRPC = NOD

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: LSTRPC - TABLE NODE (",I7,") IS OUT '//
     . 'OF BOUNDS, < LOWER BOUNDS (",I7,"); TAG IS ",A10)')
     . NODE,INODE(LUN),TAG(NODE)
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: LSTRPC - TABLE NODE (",I7,") IS OUT '//
     . 'OF BOUNDS, > UPPER BOUNDS (",I7,"); TAG IS ",A10)')
     . NODE,ISC(INODE(LUN)),TAG(NODE)
      CALL BORT(BORT_STR)
      END
      FUNCTION LSTRPS(NODE,LUN)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    LSTRPS (docblock incomplete)
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION ....
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY) (INCOMPLETE); OUTPUTS MORE
C                           COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    LSTRPS (NODE, LUN)
C   INPUT ARGUMENT LIST:
C     NODE     - INTEGER: ....
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C
C   OUTPUT ARGUMENT LIST:
C     LSTRPS   - INTEGER: ....
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT
C    THIS ROUTINE IS CALLED BY: UFBRW
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)

      CHARACTER*128 BORT_STR
      CHARACTER*10  TAG
      CHARACTER*3   TYP

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      IF(NODE.LT.INODE(LUN)) GOTO 900
      IF(NODE.GT.ISC(INODE(LUN))) GOTO 901

      NOD = NODE

C  FIND THIS OR THE PREVIOUS RPS NODE
C  ----------------------------------

10    IF(TYP(NOD).NE.'RPS') THEN
         NOD = JMPB(NOD)
         IF(NOD.NE.0) GOTO 10
      ENDIF

      LSTRPS = NOD

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: LSTRPS - TABLE NODE (",I7,") IS OUT '//
     . 'OF BOUNDS, < LOWER BOUNDS (",I7,"); TAG IS ",A10)')
     . NODE,INODE(LUN),TAG(NODE)
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: LSTRPS - TABLE NODE (",I7,") IS OUT '//
     . 'OF BOUNDS, > UPPER BOUNDS (",I7,"); TAG IS ",A10)')
     . NODE,ISC(INODE(LUN)),TAG(NODE)
      CALL BORT(BORT_STR)
      END
      SUBROUTINE MAKESTAB

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    MAKESTAB
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE CONSTRUCTS AN INTERNAL JUMP/LINK TABLE
C  WITHIN COMMON BLOCK /TABLES/, USING THE INFORMATION WITHIN THE
C  INTERNAL BUFR TABLE ARRAYS (WITHIN COMMON BLOCK /TABABD/) FOR ALL OF
C  THE LUN (I.E., I/O STREAM INDEX) VALUES THAT ARE CURRENTLY DEFINED TO
C  THE BUFR ARCHIVE LIBRARY SOFTWARE.  NOTE THAT THE ENTIRE JUMP/LINK
C  TABLE WILL ALWAYS BE COMPLETELY RECONSTRUCTED FROM SCRATCH, EVEN IF
C  SOME OF THE INFORMATION WITHIN THE INTERNAL BUFR TABLE ARRAYS
C  ALREADY EXISTED THERE AT THE TIME OF THE PREVIOUS CALL TO THIS
C  SUBROUTINE, BECAUSE THERE MAY HAVE BEEN OTHER EVENTS THAT HAVE TAKEN
C  PLACE SINCE THE PREVIOUS CALL TO THIS SUBROUTINE THAT HAVE NOT YET
C  BEEN REFLECTED WITHIN THE INTERNAL JUMP/LINK TABLE, SUCH AS, E.G.
C  THE UNLINKING OF AN LUN VALUE FROM THE BUFR ARCHIVE LIBRARY SOFTWARE
C  VIA A CALL TO BUFR ARCHIVE LIBRARY SUBROUTINE CLOSBF.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1995-06-28  J. WOOLLEN -- INCREASED THE SIZE OF INTERNAL BUFR TABLE
C                           ARRAYS IN ORDER TO HANDLE BIGGER FILES
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED HISTORY DOCUMENTATION; OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY; NOW ALLOWS FOR THE
C                           POSSIBILITY THAT A CONNECTED FILE MAY NOT
C                           CONTAIN ANY DICTIONARY TABLE INFO (E.G.,
C                           AN EMPTY FILE), SUBSEQUENT CONNECTED FILES
C                           WHICH ARE NOT EMPTY WILL NO LONGER GET
C                           TRIPPED UP BY THIS (THIS AVOIDS THE NEED
C                           FOR AN APPLICATION PROGRAM TO DISCONNECT
C                           ANY EMPTY FILES VIA A CALL TO CLOSBF)
C
C USAGE:    CALL MAKESTAB
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     CHEKSTAB STRCLN   TABSUB
C    THIS ROUTINE IS CALLED BY: RDBFDX   RDUSDX
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)
      PARAMETER (MAXTBA=50)
      PARAMETER (MAXTBB=250)
      PARAMETER (MAXTBD=250)

      COMMON /QUIET/  IPRT
      COMMON /STBFR/  IOLUN(NFILES),IOMSG(NFILES)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /TABABD/ NTBA(0:NFILES),NTBB(0:NFILES),NTBD(0:NFILES),
     .                MTAB(MAXTBA,NFILES),IDNA(MAXTBA,NFILES,2),
     .                IDNB(MAXTBB,NFILES),IDND(MAXTBD,NFILES),
     .                TABA(MAXTBA,NFILES),TABB(MAXTBB,NFILES),
     .                TABD(MAXTBD,NFILES)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)

      CHARACTER*600 TABD
      CHARACTER*128 TABB
      CHARACTER*128 TABA
      CHARACTER*128 BORT_STR
      CHARACTER*10  TAG
      CHARACTER*8   NEMO
      CHARACTER*3   TYP
      DIMENSION     LUS(NFILES)
      LOGICAL       EXPAND
      REAL*8        VAL,BMISS

      DATA BMISS  /10E10/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  RESET POINTER TABLE AND STRING CACHE
C  ------------------------------------

      NTAB = 0
      CALL STRCLN

C  FIGURE OUT WHICH UNITS SHARE TABLES
C  -----------------------------------

C     First, determine how many LUN values are currently being used and,
C     for each such one, whether it uses the same dictionary table
C     information as any other LUN values that we have examined so far.
C     If so, then set LUS(LUN) to a nonzero value.

C     Note that, for each LUN value, the MTAB(*,LUN) array contains
C     pointer indices into the internal jump/link table for each of the
C     Table A mnemonics that is currently defined for that LUN value.
C     Thus, the code within the following DO loop is simply checking
C     whether the first Table A mnemonic is the same for two different
C     LUN values as the determination of whether those LUN values indeed
C     share the same dictionary tables.

      DO LUN=1,NFILES
      LUS(LUN) = 0
      IF(IOLUN(LUN).NE.0) THEN
         IF(LUN.GT.1) THEN
         DO LUM=1,LUN-1
cccccccc IF(MTAB(1,LUN).EQ.MTAB(1,LUM)) LUS(LUN) = LUM
         IF(MTAB(1,LUN).EQ.MTAB(1,LUM) .AND. MTAB(1,LUM).NE.0)
     .    LUS(LUN) = LUM
         ENDDO
         ENDIF
      ENDIF
      ENDDO

C  INITIALIZE JUMP/LINK TABLES WITH SUBSETS/SEQUENCES/ELEMENTS
C  -----------------------------------------------------------

      DO LUN=1,NFILES

ccccc IF(IOLUN(LUN).NE.0) THEN
      IF(IOLUN(LUN).NE.0 .AND. NTBA(LUN).GT.0) THEN

C  RESET ANY EXISTING INVENTORY POINTERS
C  -------------------------------------

         IF(IOMSG(LUN).NE.0) THEN
            IF(LUS(LUN).EQ.0) INC = (NTAB+1)-MTAB(1,LUN)
            IF(LUS(LUN).NE.0) INC = MTAB(1,LUS(LUN))-MTAB(1,LUN)
            DO N=1,NVAL(LUN)
            INV(N,LUN) = INV(N,LUN)+INC
            ENDDO
         ENDIF

C  CREATE NEW TABLE ENTRIES IF THIS UNIT DOESN'T SHARE EXISTING ONES
C  -----------------------------------------------------------------

         IF(LUS(LUN).EQ.0) THEN

C     The dictionary table information corresponding to this LUN
C     has not yet been written into the internal jump/link table,
C     so add it in now.

            CALL CHEKSTAB(LUN)
            DO ITBA=1,NTBA(LUN)
            INOD = NTAB+1
            NEMO = TABA(ITBA,LUN)(4:11)
            CALL TABSUB(LUN,NEMO)
            MTAB(ITBA,LUN) = INOD
            ISC(INOD)      = NTAB

C**** note that the following lines are commented out****
cccc        DO N1=INOD,ISC(INOD)-1
cccc        DO N2=N1+1,ISC(INOD)
cccc        IF(TAG(N1).EQ.TAG(N2)) GOTO 900
cccc        ENDDO
cccc        ENDDO
C********************************************************

            ENDDO
         ENDIF

      ENDIF
      ENDDO

C  STORE TYPES AND INITIAL VALUES AND COUNTS
C  -----------------------------------------

      DO NODE=1,NTAB
      IF(TYP(NODE).EQ.'SUB') THEN
         VALI(NODE) = 0
         KNTI(NODE) = 1
         ITP (NODE) = 0
      ELSEIF(TYP(NODE).EQ.'SEQ') THEN
         VALI(NODE) = 0
         KNTI(NODE) = 1
         ITP (NODE) = 0
      ELSEIF(TYP(NODE).EQ.'RPC') THEN
         VALI(NODE) = 0
         KNTI(NODE) = 0
         ITP (NODE) = 0
      ELSEIF(TYP(NODE).EQ.'RPS') THEN
         VALI(NODE) = 0
         KNTI(NODE) = 0
         ITP (NODE) = 0
      ELSEIF(TYP(NODE).EQ.'REP') THEN
         VALI(NODE) = BMISS
         KNTI(NODE) = IRF(NODE)
         ITP (NODE) = 0
      ELSEIF(TYP(NODE).EQ.'DRS') THEN
         VALI(NODE) = 0
         KNTI(NODE) = 1
         ITP (NODE) = 1
      ELSEIF(TYP(NODE).EQ.'DRP') THEN
         VALI(NODE) = 0
         KNTI(NODE) = 1
         ITP (NODE) = 1
      ELSEIF(TYP(NODE).EQ.'DRB') THEN
         VALI(NODE) = 0
         KNTI(NODE) = 0
         ITP (NODE) = 1
      ELSEIF(TYP(NODE).EQ.'NUM') THEN
         VALI(NODE) = BMISS
         KNTI(NODE) = 1
         ITP (NODE) = 2
      ELSEIF(TYP(NODE).EQ.'CHR') THEN
         VALI(NODE) = BMISS
         KNTI(NODE) = 1
         ITP (NODE) = 3
      ELSE
         GOTO 901
      ENDIF
      ENDDO

C  SET UP EXPANSION SEGMENTS FOR TYPE 'SUB', 'DRP', AND 'DRS' NODES
C  ----------------------------------------------------------------

      NEWN = 0

      DO N=1,NTAB
      ISEQ(N,1) = 0
      ISEQ(N,2) = 0
      EXPAND = TYP(N).EQ.'SUB' .OR. TYP(N).EQ.'DRP' .OR. TYP(N).EQ.'DRS'
     .                         .OR. TYP(N).EQ.'REP' .OR. TYP(N).EQ.'DRB'
      IF(EXPAND) THEN
         ISEQ(N,1) = NEWN+1
         NODA = N
         NODE = N+1
         DO K=1,MAXJL
         KNT(K) = 0
         ENDDO
         IF(TYP(NODA).EQ.'REP') KNT(NODE) = KNTI(NODA)
         IF(TYP(NODA).NE.'REP') KNT(NODE) = 1

1        NEWN = NEWN+1
         IF(NEWN.GT.MAXJL) GOTO 902
         JSEQ(NEWN) = NODE
         KNT(NODE) = MAX(KNTI(NODE),KNT(NODE))
2        IF(JUMP(NODE)*KNT(NODE).GT.0) THEN
            NODE = JUMP(NODE)
            GOTO 1
         ELSE IF(LINK(NODE).GT.0) THEN
            NODE = LINK(NODE)
            GOTO 1
         ELSE
            NODE = JMPB(NODE)
            IF(NODE.EQ.NODA) GOTO 3
            IF(NODE.EQ.0   ) GOTO 903
            KNT(NODE) = MAX(KNT(NODE)-1,0)
            GOTO 2
         ENDIF
3        ISEQ(N,2) = NEWN
      ENDIF
      ENDDO

C  PRINT THE SEQUENCE TABLES
C  ------------------------

      IF(IPRT.GE.2) THEN
      PRINT*
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
         PRINT*
         DO I=1,NTAB
         PRINT99,I,
     .   TAG(I),TYP(I),JMPB(I),JUMP(I),LINK(I),IBT(I),IRF(I),ISC(I)
         ENDDO
         PRINT*
99       FORMAT('BUFRLIB: MAKESTAB ',I5,2X,A10,A5,6I8)
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT*
      ENDIF

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: MAKESTAB - MNEMONIC ",A," IS '//
     . 'DUPLICATED IN SUBSET: ",A)') NEMO,TAG(N1)
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: MAKESTAB - UNKNOWN TYPE ",A)')TYP(NODE)
      CALL BORT(BORT_STR)
902   WRITE(BORT_STR,'("BUFRLIB: MAKESTAB - NUMBER OF JSEQ ENTRIES IN'//
     . ' JUMP/LINK TABLE EXCEEDS THE LIMIT (",I6,")")') MAXJL
      CALL BORT(BORT_STR)
903   WRITE(BORT_STR,'("BUFRLIB: MAKESTAB - NODE IS ZERO, FAILED TO '//
     . 'CIRCULATE (TAG IS ",A,")")') TAG(N)
      CALL BORT(BORT_STR)
      END
      SUBROUTINE MAXOUT(MAXO)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    MAXOUT
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2002-05-14
C
C ABSTRACT: THIS SUBROUTINE ALLOWS AN APPLICATION PROGRAM TO SET THE
C  RECORD LENGTH OF NEWLY CREATED BUFR MESSAGES, OVERRIDING THE VALUE
C  SET IN BUFR ARCHIVE LIBRARY SUBROUTINE BFRINI.  THIS MUST BE CALLED
C  AFTER THE INITIAL CALL TO BUFR ARCHIVE LIBRARY SUBROUTINE OPENBF
C  SINCE OPENBF CALLS BFRINI.  THE RECORD LENGTH WILL REMAIN MAX0
C  UNLESS THIS SUBROUTINE IS CALLED AGAIN WITH A NEW MAX0.
C
C PROGRAM HISTORY LOG:
C 2002-05-14  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO FOR
C                           INFORMATIONAL PURPOSES
C
C USAGE:    CALL MAXOUT (MAXO)
C   INPUT ARGUMENT LIST:
C     MAXO     - INTEGER: DESIRED MESSAGE LENGTH (BYTES)
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        None
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /MAXCMP/ MAXCMB,MAXROW,MAXCOL,NCMSGS,NCSUBS,NCBYTS
      COMMON /DXTAB / MAXDX,IDXV,NXSTR(10),LDXA(10),LDXB(10),LDXD(10)
      COMMON /DXTAB / LD30(10),DXSTR(10)
      COMMON /QUIET / IPRT

      CHARACTER*56    DXSTR

      IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT 101, MAXBYT,MAXO
101   FORMAT(' BUFRLIB: MAXOUT - THE RECORD LENGTH OF ALL BUFR ',
     . 'MESSAGES CREATED FROM THIS POINT ON IS BEING CHANGED FROM',I3,
     . ' TO',I3)
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT*
      ENDIF

      MAXBYT = MAXO
      MAXCMB = MAXO
      MAXDX  = MAXO

      RETURN
      END
      SUBROUTINE MESGBC(LUNIT,MESGTYP,ICOMP)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    MESGBC
C   PRGMMR: KEYSER           ORG: NP22       DATE: 2003-11-04
C
C ABSTRACT: THIS SUBROUTINE READS AND EXAMINES SECTION 1 OF MESSAGES
C  IN A BUFR FILE IN SEQUENCE UNTIL IT FINDS THE FIRST MESSAGE THAT
C  ACTUALLY CONTAINS REPORT DATA {I.E., BEYOND THE BUFR TABLE
C  (DICTIONARY) MESSAGES AT THE TOP AND, FOR DUMP FILES, BEYOND THE
C  TWO DUMMY MESSAGES CONTAINING THE CENTER TIME AND THE DUMP TIME}.
C  IT THEN RETURNS THE MESSAGE TYPE FOR THIS FIRST DATA MESSAGE.  IT
C  ALSO EXAMINES SECTION 3 FOR THIS FIRST DATA MESSAGE TO DETERMINE
C  WHETHER OR NOT THE MESSAGE IS COMPRESSED BUFR.  THE BUFR FILE SHOULD
C  NOT BE OPEN VIA BUFR ARCHIVE LIBRARY SUBROUTINE OPENBF PRIOR TO
C  CALLING THIS SUBROUTINE HOWEVER THE BUFR FILE MUST BE CONNECTED TO
C  UNIT LUNIT.  THIS SUBROUTINE IS IDENTICAL TO BUFR ARCHIVE LIBRARY
C  SUBROUTINE MESGBF EXCEPT MESGBF DOES NOT RETURN ANY INFORMATION
C  ABOUT COMPRESSION AND MESGBF READS UNTIL IT FINDS THE FIRST NON-
C  DICTIONARY MESSAGE REGARDLESS OF WHETHER OR NOT IT CONTAINS ANY
C  REPORTS (I.E., IT WOULD STOP AT THE DUMMY MESSAGE CONTAINING THE
C  CENTER TIME FOR DUMP FILES).
C
C PROGRAM HISTORY LOG:
C 2003-11-04  D. KEYSER  -- ORIGINAL AUTHOR
C
C USAGE:    CALL MESGBC (LUNIT, MESGTYP, ICOMP)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     MESGTYP  - INTEGER: BUFR MESSAGE TYPE FOR FIRST MESSAGE IN FILE
C                CONTAINING REPORT DATA
C                    -256 = no messages read or error reading file
C                     < 0 = none of the messages read contain reports;
C                           this is the negative of the message type
C                           for the last message read (-11 indicates
C                           the BUFR file contains only BUFR table
C                           messages)
C     ICOMP    - INTEGER: BUFR MESSAGE COMPRESSION SWITCH:
C                      -3 = BUFR file does not exist
C                      -2 = BUFR file does not contain any report
C                           messages
C                      -1 = cannot determine if first BUFR message 
C                           containing report data is compressed due to
C                           error reading file
C                       0 = first BUFR message containing report data
C                           is NOT compressed
C                       1 = first BUFR message containing report data
C                           IS compressed
C
C   INPUT FILES:
C     UNIT "LUNIT" - BUFR FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        IUPM     LMSG     WRDLEN   MOVA2I
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs (e.g., BUFR_TRANJB).
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)

      CHARACTER*40 MESG
      CHARACTER*8  SEC0
      DIMENSION    MBAY(5000)
      EQUIVALENCE  (MESG,MBAY(1))

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IREC    =    0
      NSUB    =    0
      MESGTYP = -256
      ICOMP   =   -1

C  SINCE OPENBF HAS NOT YET BEEN CALLED, MUST CALL WRDLEN TO GET
C  MACHINE INFO NEEDED LATER
C  -------------------------------------------------------------

      CALL WRDLEN
      IMSG = 8/NBYTW+1

C  READ PAST ANY BUFR TABLES AND RETURN THE FIRST MESSAGE TYPE FOUND
C  -----------------------------------------------------------------

      REWIND LUNIT
1     READ(LUNIT,ERR=901,END=900) SEC0,(MBAY(I),I=IMSG,LMSG(SEC0))
      IREC = IREC + 1
      MESGTYP = IUPM(MESG(17:17),8)
      NSUB = IUPM(MESG(31:31),16)
      IF(MESGTYP.EQ.11 .OR. NSUB.EQ.0) GO TO 1
      ICOMP = 0
      NCMP = MOVA2I(MESG(33:33))
c  BUFR messages are compressed if below is true
      IF(IAND(NCMP,64).GT.0) ICOMP = 1
      REWIND LUNIT
      GOTO 100

900   IF(IREC.EQ.0) THEN
         MESGTYP = -256
         ICOMP =     -3
      ELSE
         IF(MESGTYP.GE.0) MESGTYP = -MESGTYP
         ICOMP  = -2
         REWIND LUNIT
      ENDIF
      GOTO 100

901   MESGTYP = -256
      ICOMP =     -1
      REWIND LUNIT

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE MESGBF(LUNIT,MESGTYP)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    MESGBF
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE READS AND EXAMINES SECTION 1 OF MESSAGES
C  IN A BUFR FILE IN SEQUENCE UNTIL IT FINDS THE FIRST MESSAGE THAT
C  IS NOT A BUFR TABLE (DICTIONARY) (I.E., NOT MESSAGE TYPE 11).  IT
C  THEN RETURNS THE MESSAGE TYPE FOR THIS FIRST NON-DICTIONARY MESSAGE.
C  THE BUFR FILE SHOULD NOT BE OPEN VIA BUFR ARCHIVE LIBRARY SUBROUTINE
C  OPENBF PRIOR TO CALLING THIS SUBROUTINE HOWEVER THE BUFR FILE MUST
C  BE CONNECTED TO UNIT LUNIT.  THIS SUBROUTINE IS IDENTICAL TO BUFR
C  ARCHIVE LIBRARY SUBROUTINE MESGBC EXCEPT MESGBC RETURNS THE MESSAGE
C  TYPE FOR THE FIRST NON-DICTIONARY MESSAGE THAT ACTUALLY CONTAINS
C  REPORT DATA (WHEREAS MESGBF WOULD RETURN THE REPORT TYPE OF A DUMMY
C  MESSAGE CONTAINING THE CENTER TIME FOR DUMP FILES), AND MESGBC ALSO
C  INDICATES WHETHER OR NOT THE FIRST REPORT DATA MESSAGE CONTAINS
C  REPORT DATA IS BUFR COMPRESSED.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    CALL MESGBF (LUNIT, MESGTYP)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     MESGTYP  - INTEGER: BUFR MESSAGE TYPE FOR FIRST NON-DICTIONARY
C                MESSAGE
C                      -1 = no messages read or error
C                      11 = if only BUFR table messages in BUFR file
C
C   INPUT FILES:
C     UNIT "LUNIT" - BUFR FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        IUPM     LMSG     WRDLEN
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MXMSGL=20000)

      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)

      CHARACTER*20 MESG
      CHARACTER*8  SEC0
      DIMENSION    MBAY(MXMSGL/4)
      EQUIVALENCE  (MESG,MBAY(1))

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      MESGTYP = -1

C  SINCE OPENBF HAS NOT YET BEEN CALLED, MUST CALL WRDLEN TO GET 
C  MACHINE INFO NEEDED LATER
C  -------------------------------------------------------------

      CALL WRDLEN
      IMSG = 8/NBYTW+1

C  READ PAST ANY BUFR TABLES AND RETURN THE FIRST MESSAGE TYPE FOUND
C  -----------------------------------------------------------------

      REWIND LUNIT
1     READ(LUNIT,ERR=100,END=100) SEC0,(MBAY(I),I=IMSG,LMSG(SEC0))
      MESGTYP = IUPM(MESG(17:17),8)
      IF(MESGTYP.EQ.11) GOTO 1
      REWIND LUNIT

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE MINIMG(LUNIT,MINI)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    MINIMG
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE PACKS THE VALUE OF MINI INTO BYTE 17 OF
C   SECTION 1 OF THE BUFR MESSAGE THAT IS CURRENTLY OPEN WITHIN MEMORY
C   FOR LUNIT, SO THAT THIS VALUE THEN BECOMES THE MINUTES COMPONENT
C   OF THE SECTION 1 DATE-TIME FOR THE MESSAGE.  THIS SUBROUTINE SHOULD 
C   ONLY BE CALLED WHEN LOGICAL UNIT LUNIT HAS BEEN OPENED FOR OUTPUT
C   OPERATIONS.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR (ENTRY POINT IN MSGINI)
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT" (IN PARENT ROUTINE MSGINI)
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI) (IN PARENT
C                           ROUTINE MSGINI)
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES (IN PARENT ROUTINE
C                           MSGINI)
C 2002-05-14  J. WOOLLEN -- CHANGED FROM AN ENTRY POINT TO INCREASE
C                           PORTABILITY TO OTHER PLATFORMS
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL MINIMG (LUNIT, MINI)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     MINI     - INTEGER: MINUTES VALUE TO BE PACKED
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     PKB      STATUS
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.LT.0) GOTO 901

      IF(IM.EQ.0) GOTO 902
      MBIT = 24*8
      CALL PKB(MINI,8,MBAY(1,LUN),MBIT)

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: MINIMG - OUTPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR OUTPUT')
901   CALL BORT('BUFRLIB: MINIMG - OUTPUT BUFR FILE IS OPEN FOR '//
     . 'INPUT, IT MUST BE OPEN FOR OUTPUT')
902   CALL BORT('BUFRLIB: MINIMG - A MESSAGE MUST BE OPEN IN OUTPUT '//
     . 'BUFR FILE, NONE ARE')
      END
      FUNCTION MOVA2I(A)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    MOVA2I
C   PRGMMR: GILBERT          ORG: NP11       DATE: 2003-11-04
C
C ABSTRACT: THIS FUNCTION COPIES A BIT STRING FROM A CHARACTER*1
C  VARIABLE TO AN INTEGER VARIABLE.  IT IS INTENDED TO REPLACE THE
C  FORTRAN INTRINSIC FUNCTION ICHAR, WHICH ONLY SUPPORTS VALUES OF
C  ICHAR(A) BETWEEN ZERO AND 127, INCLUSIVE ON SOME PLATFORMS (E.G.,
C  THE NCEP IBM SP).  IF "A" IS GREATER THAN 127 IN THE COLLATING
C  SEQUENCE, ICHAR(A) DOES NOT RETURN THE EXPECTED BIT VALUE.  THIS
C  FUNCTION CAN BE USED FOR ALL VALUES OF ICHAR(A) BETWEEN ZERO AND
C  255.
C
C PROGRAM HISTORY LOG:
C 2003-11-04  S. GILBERT -- ORIGINAL AUTHOR
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF
C
C USAGE:    CALL MOVA2I (A)
C   INPUT ARGUMENT LIST:
C     A        - CHARACTER*1: VARIABLE THAT HOLDS THE BITSTRING TO
C                EXTRACT
C
C   OUTPUT ARGUMENT LIST:
C     MOVA2I   - INTEGER: VALUE OF THE BITSTRING IN CHARACTER A
C
C REMARKS:
C    THIS ROUTINE CALLS:        None
C    THIS ROUTINE IS CALLED BY: DATEBF   DUMPBF   MESGBC   REWNBF
C                               Also called by application programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*1 A
      CHARACTER*4 CTEMP
      INTEGER*4 ITEMP,FF
      EQUIVALENCE (CTEMP,ITEMP)
      FF=255
      CTEMP=A//A//A//A
      MOVA2I=IAND(ITEMP,FF)
      RETURN
      END
      SUBROUTINE MRGINV

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    MRGINV
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1996-10-09
C
C ABSTRACT: THIS SUBROUTINE PRINTS A SUMMARY OF MERGE ACTIVITY.
C
C PROGRAM HISTORY LOG:
C 1996-10-09  J. WOOLLEN -- ORIGINAL AUTHOR (ENTRY POINT IN INVMRG)
C 2002-05-14  J. WOOLLEN -- CHANGED FROM AN ENTRY POINT TO INCREASE
C                           PORTABILITY TO OTHER PLATFORMS
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    CALL MRGINV
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        None
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /MRGCOM/ NRPL,NMRG,NAMB,NTOT
      COMMON /QUIET / IPRT

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IF(IPRT.GE.0) THEN
      PRINT*,'+++++++++++++++++++++++BUFRLIB+++++++++++++++++++++++++'
      PRINT*,'-------------------------------------------------------'
      PRINT*,'INVENTORY FROM MERGE PROCESS IN BUFRLIB ROUTINE INVMRG '
      PRINT*,'-------------------------------------------------------'
      PRINT*,'NUMBER OF DRB EXPANSIONS  = ',NRPL
      PRINT*,'NUMBER OF MERGES          = ',NMRG
      PRINT*,'NUMBER THAT ARE AMBIGUOUS = ',NAMB
      PRINT*,'-------------------------------------------------------'
      PRINT*,'TOTAL NUMBER OF VISITS    = ',NTOT
      PRINT*,'-------------------------------------------------------'
      PRINT*,'+++++++++++++++++++++++BUFRLIB+++++++++++++++++++++++++'
      ENDIF

      RETURN
      END
      SUBROUTINE MSGINI(LUN)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    MSGINI
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE INITIALIZES, WITHIN THE INTERNAL ARRAYS, A
C   NEW BUFR MESSAGE FOR OUTPUT.  ARRAYS ARE FILLED IN COMMON BLOCKS
C   /MSGPTR/, /MSGCWD/ AND /BITBUF/.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1996-12-11  J. WOOLLEN -- MODIFIED TO ALLOW INCLUSION OF MINUTES IN
C                           WRITING THE MESSAGE DATE INTO A BUFR
C                           MESSAGE
C 1997-07-29  J. WOOLLEN -- MODIFIED TO UPDATE THE CURRENT BUFR VERSION
C                           WRITTEN IN SECTION 0 FROM 2 TO 3
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"; MODIFIED TO MAKE Y2K
C                           COMPLIANT
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2002-05-14  J. WOOLLEN -- REMOVED ENTRY POINT MINIMG (IT BECAME A
C                           SEPARATE ROUTINE IN THE BUFRLIB TO
C                           INCREASE PORTABILITY TO OTHER PLATFORMS)
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED HISTORY DOCUMENTATION; OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL MSGINI (LUN)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     NEMTAB   NEMTBA   PKB
C                               PKC
C    THIS ROUTINE IS CALLED BY: CPYUPD   MSGUPD   OPENMB   OPENMG
C                               SUBUPD
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /PADESC/ IBCT,IPD1,IPD2,IPD3,IPD4
      COMMON /MSGPTR/ NBY0,NBY1,NBY2,NBY3,NBY4,NBY5
      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)

      CHARACTER*128 BORT_STR
      CHARACTER*10  TAG
      CHARACTER*8   SUBTAG
      CHARACTER*4   BUFR,SEVN
      CHARACTER*3   TYP
      CHARACTER*1   TAB

      DATA BUFR/'BUFR'/
      DATA SEVN/'7777'/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  GET THE MESSAGE TAG AND TYPE, AND BREAK UP THE DATE
C  ---------------------------------------------------

      SUBTAG = TAG(INODE(LUN))
c  .... Given SUBSET, NEMTBA returns MTYP,MSBT,INOD
      CALL NEMTBA(LUN,SUBTAG,MTYP,MSBT,INOD)
      IF(INODE(LUN).NE.INOD) GOTO 900
      CALL NEMTAB(LUN,SUBTAG,ISUB,TAB,IRET)
      IF(IRET.EQ.0) GOTO 901

C  DATE CAN BE YYMMDDHH OR YYYYMMDDHH
C  ----------------------------------

      MCEN = MOD(IDATE(LUN)/10**8,100)+1
      MEAR = MOD(IDATE(LUN)/10**6,100)
      MMON = MOD(IDATE(LUN)/10**4,100)
      MDAY = MOD(IDATE(LUN)/10**2,100)
      MOUR = MOD(IDATE(LUN)      ,100)
      MMIN = 0

c  .... DK: Can this happen?? (investigate)
      IF(MCEN.EQ.1) GOTO 902

      IF(MEAR.EQ.0) MCEN = MCEN-1
      IF(MEAR.EQ.0) MEAR = 100

C  INITIALIZE THE MESSAGE
C  ----------------------

      MBIT = 0
      NBY0 = 8
      NBY1 = 18
      NBY2 = 0
      NBY3 = 20
      NBY4 = 4
      NBY5 = 4
      NBYT = NBY0+NBY1+NBY2+NBY3+NBY4+NBY5

C  SECTION 0
C  ---------

      CALL PKC(BUFR ,  4 , MBAY(1,LUN),MBIT)
      CALL PKB(NBYT , 24 , MBAY(1,LUN),MBIT)
      CALL PKB(   3 ,  8 , MBAY(1,LUN),MBIT)

C  SECTION 1
C  ---------

      CALL PKB(NBY1 , 24 , MBAY(1,LUN),MBIT)
      CALL PKB(   0 ,  8 , MBAY(1,LUN),MBIT)
      CALL PKB(   3 ,  8 , MBAY(1,LUN),MBIT)
      CALL PKB(   7 ,  8 , MBAY(1,LUN),MBIT)
      CALL PKB(   0 ,  8 , MBAY(1,LUN),MBIT)
      CALL PKB(   0 ,  8 , MBAY(1,LUN),MBIT)
      CALL PKB(MTYP ,  8 , MBAY(1,LUN),MBIT)
      CALL PKB(MSBT ,  8 , MBAY(1,LUN),MBIT)
      CALL PKB(   4 ,  8 , MBAY(1,LUN),MBIT)
      CALL PKB(   0 ,  8 , MBAY(1,LUN),MBIT)
      CALL PKB(MEAR ,  8 , MBAY(1,LUN),MBIT)
      CALL PKB(MMON ,  8 , MBAY(1,LUN),MBIT)
      CALL PKB(MDAY ,  8 , MBAY(1,LUN),MBIT)
      CALL PKB(MOUR ,  8 , MBAY(1,LUN),MBIT)
      CALL PKB(MMIN ,  8 , MBAY(1,LUN),MBIT)
      CALL PKB(MCEN ,  8 , MBAY(1,LUN),MBIT)

C  SECTION 3
C  ---------

      CALL PKB(NBY3 , 24 , MBAY(1,LUN),MBIT)
      CALL PKB(   0 ,  8 , MBAY(1,LUN),MBIT)
      CALL PKB(   0 , 16 , MBAY(1,LUN),MBIT)
      CALL PKB(2**7 ,  8 , MBAY(1,LUN),MBIT)
      CALL PKB(IBCT , 16 , MBAY(1,LUN),MBIT)
      CALL PKB(ISUB , 16 , MBAY(1,LUN),MBIT)
      CALL PKB(IPD1 , 16 , MBAY(1,LUN),MBIT)
      CALL PKB(IPD2 , 16 , MBAY(1,LUN),MBIT)
      CALL PKB(IPD3 , 16 , MBAY(1,LUN),MBIT)
      CALL PKB(IPD4 , 16 , MBAY(1,LUN),MBIT)
      CALL PKB(   0 ,  8 , MBAY(1,LUN),MBIT)

C  SECTION 4
C  ---------

      CALL PKB(NBY4 , 24 , MBAY(1,LUN),MBIT)
      CALL PKB(   0 ,  8 , MBAY(1,LUN),MBIT)

C  SECTION 5
C  ---------

      CALL PKC(SEVN ,  4 , MBAY(1,LUN),MBIT)

C  DOUBLE CHECK INITIAL MESSAGE LENGTH
C  -----------------------------------

      IF(MOD(MBIT,8).NE.0) GOTO 903
      IF(MBIT/8.NE.NBYT  ) GOTO 904

      NMSG(LUN) = NMSG(LUN)+1
      NSUB(LUN) = 0
      MBYT(LUN) = NBYT

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: MSGINI - MISMATCH BETWEEN INODE (=",'//
     . 'I7,") & POSITIONAL INDEX, INOD (",I7,") OF SUBTAG (",A,") IN '//
     . 'DICTIONARY")') INODE(LUN),INOD,SUBTAG
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: MSGINI - TABLE A MESSAGE TYPE '//
     . 'MNEMONIC ",A," NOT FOUND IN INTERNAL TABLE D ARRAYS")') SUBTAG
      CALL BORT(BORT_STR)
902   CALL BORT
     . ('BUFRLIB: MSGINI - BUFR MESSAGE DATE (IDATE) is 0000000000')
903   CALL BORT('BUFRLIB: MSGINI - INITIALIZED MESSAGE DOES NOT END '//
     . 'ON A BYTE BOUNDARY')
904   WRITE(BORT_STR,'("BUFRLIB: MSGINI - NUMBER OF BYTES STORED FOR '//
     . 'INITIALIZED MESSAGE (",I6,") IS NOT THE SAME AS FIRST '//
     . 'CALCULATED, NBYT (",I6)') MBIT/8,NBYT
      CALL BORT(BORT_STR)
      END
      SUBROUTINE MSGUPD(LUNIT,LUN)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    MSGUPD
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE PACKS UP THE CURRENT SUBSET WITHIN MEMORY
C  (ARRAY IBAY IN COMMON BLOCK /BITBUF/) AND THEN TRIES TO ADD IT TO
C  THE BUFR MESSAGE THAT IS CURRENTLY OPEN WITHIN MEMORY FOR LUNIT
C  (ARRAY MBAY IN COMMON BLOCK /BITBUF/).  IF THE SUBSET WILL NOT FIT
C  INTO THE CURRENTLY OPEN MESSAGE, THEN THAT MESSAGE IS FLUSHED TO
C  LUNIT AND A NEW ONE IS CREATED IN ORDER TO HOLD THE CURRENT SUBSET.
C  IF THE SUBSET IS LARGER THAN AN EMPTY MESSAGE, THE SUBSET IS
C  DISCARDED AND A DIAGNOSTIC IS PRINTED.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1998-12-14  J. WOOLLEN -- NO LONGER CALLS BORT IF A SUBSET IS LARGER
C                           THAN A MESSAGE, JUST DISCARDS THE SUBSET
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION
C
C USAGE:    CALL MSGUPD (LUNIT, LUN)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C                (ASSOCIATED WITH FILE CONNECTED TO LOGICAL UNIT LUNIT)
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        IUPB     MSGINI   MSGWRT   MVB
C                               PAD      PKB      USRTPL
C    THIS ROUTINE IS CALLED BY: WRITSA   WRITSB
C                               Normally not called by any application
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /MSGPTR/ NBY0,NBY1,NBY2,NBY3,NBY4,NBY5
      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /QUIET / IPRT

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  PAD THE SUBSET BUFFER
C  ---------------------

      CALL PAD(IBAY,IBIT,IBYT,8)

C  SEE IF THE NEW SUBSET FITS
C  --------------------------

      IF(MBYT(LUN)+IBYT+8.GT.MAXBYT) THEN
c  .... NO it does not fit
         CALL MSGWRT(LUNIT,MBAY(1,LUN),MBYT(LUN))
         CALL MSGINI(LUN)
      ENDIF

      IF(MBYT(LUN)+IBYT+8.GT.MAXBYT) GOTO 900

C  SET A BYTE COUNT AND TRANSFER THE SUBSET BUFFER INTO THE MESSAGE
C  ----------------------------------------------------------------

      LBIT = 0
      CALL PKB(IBYT,16,IBAY,LBIT)
c  .... DK: Why the -3 in "MBYT(LUN)-3" ??
      CALL MVB(IBAY,1,MBAY(1,LUN),MBYT(LUN)-3,IBYT)

C  UPDATE THE SUBSET AND BYTE COUNTERS
C  --------------------------------------

      MBYT(LUN)   = MBYT(LUN)   + IBYT
      NSUB(LUN)   = NSUB(LUN)   + 1

      LBIT = (NBY0+NBY1+NBY2+4)*8
      CALL PKB(NSUB(LUN),16,MBAY(1,LUN),LBIT)

      LBYT = NBY0+NBY1+NBY2+NBY3
      NBYT = IUPB(MBAY(1,LUN),LBYT+1,24)
      LBIT = LBYT*8
      CALL PKB(NBYT+IBYT,24,MBAY(1,LUN),LBIT)

C  RESET THE USER ARRAYS AND EXIT NORMALLY
C  ---------------------------------------

      CALL USRTPL(LUN,1,1)
      GOTO 100

C  ON ENCOUTERING OVERLARGE SUBSETS, EXIT GRACEFULLY (SUBSET DISCARDED)
C  --------------------------------------------------------------------

900   IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*,'BUFRLIB: MSGUPD - SUBSET LONGER THAN ANY POSSIBLE ',
     . 'MESSAGE {SUBSET LENGTH= ',MBYT(LUN)+IBYT+8,', MESSAGE LENGTH= ',
     . MAXBYT,'}'
      PRINT*,'>>>>>>>OVERLARGE SUBSET DISCARDED FROM FILE<<<<<<<<'
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
      ENDIF

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE MSGWRT(LUNIT,MBAY,MBYT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    MSGWRT
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE PERFORMS SOME FINAL CHECKS ON AN OUTPUT
C  BUFR MESSAGE (E.G. CONFIRMING THAT EACH SECTION OF THE MESSAGE HAS
C  AN EVEN NUMBER OF BYTES), AND THEN PREPARES THE MESSAGE FOR FINAL
C  OUTPUT (E.G., ADDING THE STRING "7777" TO THE LAST FOUR BYTES OF THE
C  MESSAGE, PADDING OUT WITH ZERO BITS TO THE NEXT MACHINE WORD
C  BOUNDARY, ETC.).  IT THEN WRITES OUT THE FINISHED MESSAGE TO LOGICAL
C  UNIT LUNIT AND ALSO STORES A COPY OF IT WITHIN COMMON /BUFRMG/ FOR
C  POSSIBLE LATER RETRIEVAL VIA BUFR ARCHIVE LIBRARY SUBROUTINE WRITSA.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1997-07-29  J. WOOLLEN -- MODIFIED TO UPDATE THE CURRENT BUFR VERSION
C                           WRITTEN IN SECTION 0 FROM 2 TO 3
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1998-11-24  J. WOOLLEN -- MODIFIED TO ZERO OUT THE PADDING BYTES
C                           WRITTEN AT THE END OF SECTION 4
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2003-11-04  J. ATOR    -- DON'T WRITE TO LUNIT IF OPENED AS A NULL
C                           FILE BY OPENBF {NULL(LUN) = 1 IN NEW
C                           COMMON BLOCK /NULBFR/} (WAS IN DECODER
C                           VERSION); ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL MSGWRT (LUNIT, MBAY, MBYT)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     MBAY     - INTEGER: *-WORD  PACKED BINARY ARRAY CONTAINING BUFR
C                MESSAGE TO OUTPUT TO LUNIT (FIRST MBYT WORDS FILLED)
C     MBYT     - INTEGER: NUMBER OF FILLED WORDS IN MBAY
C
C   OUTPUT FILES:
C     UNIT 06      - STANDARD OUTPUT PRINT
C     UNIT "LUNIT" - BUFR FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     IUPB     PKB      PKC
C    THIS ROUTINE IS CALLED BY: CLOSMG   COPYMG   CPYMEM   CPYUPD
C                               MSGUPD   SUBUPD   WRCMPS   WRITDX
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)
      COMMON /BUFRMG/ MSGLEN,MSGTXT(MXMSGL/4)
      COMMON /NULBFR/ NULL(NFILES)
      COMMON /QUIET / IPRT

      CHARACTER*4 BUFR,SEVN
      DIMENSION   MBAY(*)

      DATA BUFR/'BUFR'/
      DATA SEVN/'7777'/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  MAKE SURE ALL SECTIONS HAVE EVEN NUMBER OF BYTES
C  ------------------------------------------------

      IAD1 = 8
      LEN1 = IUPB(MBAY,IAD1+1,24)
      LEN2 = IUPB(MBAY,IAD1+8, 1)
      MTYP = IUPB(MBAY,IAD1+9, 8)
      IAD2 = IAD1+LEN1
      LEN2 = IUPB(MBAY,IAD2+1,24)*LEN2
      IAD3 = IAD2+LEN2
      LEN3 = IUPB(MBAY,IAD3+1,24)
      IAD4 = IAD3+LEN3
      LEN4 = IUPB(MBAY,IAD4+1,24)

      IF(MOD(LEN1,2).NE.0) GOTO 901
      IF(MOD(LEN2,2).NE.0) GOTO 902
      IF(MOD(LEN3,2).NE.0) GOTO 903
      IF(MOD(LEN4,2).NE.0) THEN
         IAD5 = IAD4+LEN4
         IBIT = IAD4*8
         LEN4 = LEN4+1
         CALL PKB(LEN4,24,MBAY,IBIT)
         IBIT = IAD5*8
         CALL PKB(0,8,MBAY,IBIT)
         MBYX = MBYT+1
      ELSE
         MBYX = MBYT
      ENDIF

C  WRITE SECTION 0 BYTE COUNT AND SECTION 5
C  ----------------------------------------

      IBIT = 0
      KBIT = (MBYX-4)*8

      CALL PKC(BUFR, 4,MBAY,IBIT)
      CALL PKB(MBYX,24,MBAY,IBIT)
      CALL PKC(SEVN, 4,MBAY,KBIT)

C  ZERO OUT THE EXTRA BYTES WHICH WILL BE WRITTEN
C  ----------------------------------------------

C     i.e. since the BUFR message is stored within the integer array
C           MBAY(*) (rather than within a character array), we need
C           to make sure that the "7777" is followed by zeroed-out
C           bytes up to the next machine word boundary (i.e. up through
C           the last byte of the current member of MBAY(*))

      IMSG = 8/NBYTW
      MWRD = (MBYX/8+1)*IMSG
      MBZZ = MWRD*NBYTW-MBYX
      DO I=1,MBZZ
      CALL PKB(0,8,MBAY,KBIT)
      ENDDO

C  WRITE THE MESSAGE PLUS PADDING TO A WORD BOUNDARY IF NULL(LUN) = 0
C  ------------------------------------------------------------------

      IMSG = 8/NBYTW
      MWRD = (MBYX/8+1)*IMSG
      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(NULL(LUN).EQ.0) WRITE(LUNIT) (MBAY(I),I=1,MWRD)

      IF(IPRT.GE.2) THEN
      PRINT*
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
         PRINT*,'BUFRLIB: MSGWRT - LUNIT=',LUNIT,' BYTES=',MWRD*NBYTW
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT*
      ENDIF

C  save a memory copy of this message - no bufr tables though
C  ----------------------------------------------------------

      IF(MTYP.NE.11) THEN

C        Store a copy of this message within COMMON /BUFRMG/, for
C        retrieval during the next call to subroutine WRITSA.

         MSGLEN = MWRD
         DO I=1,MSGLEN
         MSGTXT(I) = MBAY(I)
         ENDDO
      ENDIF

C  EXITS
C  -----

      RETURN
901   CALL BORT
     . ('BUFRLIB: MSGWRT - LENGTH OF SECTION 1 IS NOT A MULTIPLE OF 2')
902   CALL BORT
     . ('BUFRLIB: MSGWRT - LENGTH OF SECTION 2 IS NOT A MULTIPLE OF 2')
903   CALL BORT
     . ('BUFRLIB: MSGWRT - LENGTH OF SECTION 3 IS NOT A MULTIPLE OF 2')
      END
      SUBROUTINE MVB(IB1,NB1,IB2,NB2,NBM)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    MVB
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE COPIES A SPECIFIED NUMBER OF BYTES FROM
C   ONE PACKED BINARY ARRAY TO ANOTHER.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1998-10-27  J. WOOLLEN -- MODIFIED TO CORRECT PROBLEMS CAUSED BY IN-
C                           LINING CODE WITH FPP DIRECTIVES
C 2002-05-14  J. WOOLLEN -- REMOVED OLD CRAY COMPILER DIRECTIVES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL MVB (IB1, NB1, IB2, NB2, NBM)
C   INPUT ARGUMENT LIST:
C     IB1      - INTEGER: *-WORD PACKED INPUT BINARY ARRAY
C     NB1      - INTEGER: POINTER TO FIRST BYTE IN IB1 TO COPY FROM
C     NB2      - INTEGER: POINTER TO FIRST BYTE IN IB2 TO COPY TO
C     NBM      - INTEGER: NUMBER OF BYTES TO MOVE
C
C   OUTPUT ARGUMENT LIST:
C     IB2      - INTEGER: *-WORD PACKED OUTPUT BINARY ARRAY
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     PKB      UPB
C    THIS ROUTINE IS CALLED BY: CPYUPD   MSGUPD   STANDARD SUBUPD
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*128 BORT_STR
      DIMENSION     IB1(*),IB2(*),NVAL(24000)

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IF(NBM.GT.24000) GOTO 900
      JB1 = 8*(NB1-1)
      JB2 = 8*(NB2-1)

      DO N=1,NBM
      CALL UPB(NVAL(N),8,IB1,JB1)
      ENDDO

      DO N=1,NBM
      CALL PKB(NVAL(N),8,IB2,JB2)
      ENDDO

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: MVB - THE NUMBER OF BYTES BEING '//
     . 'REQUESTED TO MOVE (",I7,") EXCEEDS THE LIMIT (24000)")') NBM
      CALL BORT(BORT_STR)
      END
      FUNCTION NEMOCK(NEMO)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    NEMOCK
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION CHECKS A MNEMONIC THAT WAS READ VIA BUFR
C   ARCHIVE LIBRARY SUBROUTINE RDUSDX (I.E., A MNEMONIC THAT WAS READ
C   FROM A USER-SUPPLIED BUFR DICTIONARY TABLE IN CHARACTER FORMAT) TO
C   VERIFY THAT IT HAS A LENGTH OF BETWEEN ONE AND EIGHT CHARACTERS AND
C   THAT IT ONLY CONTAINS CHARACTERS FROM THE ALLOWABLE CHARACTER SET.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- SPLIT NON-ZERO RETURN INTO -1 FOR LENGTH
C                           NOT 1-8 CHARACTERS AND -2 FOR INVALID
C                           CHARACTERS (RETURN ONLY -1 BEFORE FOR ALL
C                           PROBLEMATIC CASES); UNIFIED/PORTABLE FOR
C                           WRF; ADDED HISTORY DOCUMENTATION
C
C USAGE:    NEMOCK (NEMO)
C   INPUT ARGUMENT LIST:
C     NEMO     - CHARACTER*(*): MNEMONIC TO BE CHECKED
C
C   OUTPUT ARGUMENT LIST:
C     NEMOCK   - INTEGER: INDICATOR AS TO WHETHER NEMO IS VALID:
C                       0 = yes
C                      -1 = no, length not between 1 and 8 characters
C                      -2 = no, it does not contain characters from the
C                           allowable character set
C
C REMARKS:
C    THIS ROUTINE CALLS:        None
C    THIS ROUTINE IS CALLED BY: RDUSDX   SEQSDX
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*(*) NEMO
      CHARACTER*38  CHRSET

      DATA CHRSET /'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.'/
      DATA NCHR   /38/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  GET THE LENGTH OF NEMO
C  ----------------------

      LNEMO = 0

      DO I=LEN(NEMO),1,-1
      IF(NEMO(I:I).NE.' ') THEN
         LNEMO = I
         GOTO 1
      ENDIF
      ENDDO

1     IF(LNEMO.LT.1 .OR. LNEMO.GT.8) THEN
         NEMOCK = -1
         GOTO 100
      ENDIF

C  SCAN NEMO FOR ALLOWABLE CHARACTERS
C  ----------------------------------

      DO 10 I=1,LNEMO
      DO J=1,NCHR
      IF(NEMO(I:I).EQ.CHRSET(J:J)) GOTO 10
      ENDDO
      NEMOCK = -2
      GOTO 100
10    ENDDO

      NEMOCK = 0

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE NEMTAB(LUN,NEMO,IDN,TAB,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    NEMTAB
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE SEARCHES FOR MNEMONIC NEMO WITHIN THE
C   INTERNAL TABLE B AND D ARRAYS HOLDING THE DICTIONARY TABLE (ARRAYS
C   IN COMMON BLOCK /TABABD/) AND, IF FOUND, RETURNS INFORMATION ABOUT
C   THAT MNEMONIC FROM WITHIN THESE ARRAYS.  OTHERWISE, IT CHECKS
C   WHETHER NEMO IS A TABLE C OPERATOR DESCRIPTOR AND, IF SO, DIRECTLY
C   COMPUTES AND RETURNS SIMILAR INFORMATION ABOUT THAT DESCRIPTOR.
C   THIS SUBROUTINE MAY BE USEFUL TO APPLICATION PROGRAMS WHICH WANT
C   TO CHECK WHETHER A PARTICULAR MNEMONIC IS IN THE DICTIONARY.  IN
C   THIS CASE, BUFR ARCHIVE LIBRARY SUBROUTINE OPENBF MUST FIRST BE
C   CALLED TO STORE THE DICTIONARY TABLE INTERNALLY, AND BUFR ARCHIVE
C   LIBRARY SUBROUTINE STATUS MUST BE CALLED TO CONNECT THE LOGICAL
C   UNIT NUMBER FOR THE BUFR FILE OPENED IN OPENBF TO LUN.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1995-06-28  J. WOOLLEN -- INCREASED THE SIZE OF INTERNAL BUFR TABLE
C                           ARRAYS IN ORDER TO HANDLE BIGGER FILES
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2000-09-19  J. WOOLLEN -- ADDED CAPABILITY TO ENCODE AND DECODE DATA
C                           USING THE OPERATOR DESCRIPTORS (BUFR TABLE
C                           C) FOR CHANGING WIDTH AND CHANGING SCALE
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION
C
C USAGE:    CALL NEMTAB (LUN, NEMO, IDN, TAB, IRET)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     NEMO     - CHARACTER*(*): MNEMONIC TO SEARCH FOR
C
C   OUTPUT ARGUMENT LIST:
C     IDN      - INTEGER: BIT-WISE REPRESENTATION OF FXY VALUE
C                CORRESPONDING TO NEMO (IF NEMO WAS FOUND)
C     TAB      - CHARACTER*1: INTERNAL TABLE ARRAY IN WHICH NEMO WAS
C                FOUND:
C                     'B' = Table B array
C                     'C' = Table C array
C                     'D' = Table D array
C     IRET     - INTEGER: POSITIONAL INDEX OF NEMO WITHIN TAB
C                       0 = NEMO was not found within any of the Table
C                           B, C, or D arrays
C
C REMARKS:
C    THIS ROUTINE CALLS:        IFXY
C    THIS ROUTINE IS CALLED BY: CHEKSTAB CMSGINI ELEMDX MSGINI
C                               SEQSDX   TABSUB  UFBQCD UFDUMP
C                               XMSGINI
C                               Also called by application programs
C                               (see ABSTRACT).
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MAXTBA=50)
      PARAMETER (MAXTBB=250)
      PARAMETER (MAXTBD=250)

      COMMON /TABABD/ NTBA(0:NFILES),NTBB(0:NFILES),NTBD(0:NFILES),
     .                MTAB(MAXTBA,NFILES),IDNA(MAXTBA,NFILES,2),
     .                IDNB(MAXTBB,NFILES),IDND(MAXTBD,NFILES),
     .                TABA(MAXTBA,NFILES),TABB(MAXTBB,NFILES),
     .                TABD(MAXTBD,NFILES)

      CHARACTER*(*) NEMO
      CHARACTER*600 TABD
      CHARACTER*128 TABB
      CHARACTER*128 TABA
      CHARACTER*8   NEMT
      CHARACTER*1   TAB
      LOGICAL       FOLVAL

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      FOLVAL = NEMO(1:1).EQ.'.'
      IRET = 0
      TAB = ' '

C  LOOK FOR NEMO IN TABLE B
C  ------------------------

      DO 1 I=1,NTBB(LUN)
      NEMT = TABB(I,LUN)(7:14)
      IF(NEMT.EQ.NEMO) THEN
         IDN  = IDNB(I,LUN)
         TAB  = 'B'
         IRET = I
         GOTO 100
      ELSEIF(FOLVAL.AND.NEMT(1:1).EQ.'.') THEN
         DO J=2,LEN(NEMT)
         IF(NEMT(J:J).NE.'.' .AND. NEMT(J:J).NE.NEMO(J:J)) GOTO 1
         ENDDO
         IDN  = IDNB(I,LUN)
         TAB  = 'B'
         IRET = I
         GOTO 100
      ENDIF
1     ENDDO

C  DON'T LOOK IN TABLE D FOR FOLLOWING VALUE-MNEMONICS
C  ---------------------------------------------------

      IF(FOLVAL) GOTO 100

C  LOOK IN TABLE D IF WE GOT THIS FAR
C  ----------------------------------

      DO I=1,NTBD(LUN)
      NEMT = TABD(I,LUN)(7:14)
      IF(NEMT.EQ.NEMO) THEN
         IDN  = IDND(I,LUN)
         TAB  = 'D'
         IRET = I
         GOTO 100
      ENDIF
      ENDDO

C  IF STILL NOTHING, CHECK HERE FOR TABLE C OPERATOR DESCRIPTORS
C  -------------------------------------------------------------

      IF(NEMO(1:3).EQ.'201' .OR.
     .   NEMO(1:3).EQ.'202' .OR.
     .   NEMO(1:3).EQ.'203' .OR.
     .   NEMO(1:3).EQ.'206' ) THEN
         READ(NEMO,'(I6)') IRET
         IDN = IFXY(NEMO)
         TAB = 'C'
         IRET = MOD(IRET/1000,10)
         GOTO 100
      ENDIF

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE NEMTBA(LUN,NEMO,MTYP,MSBT,INOD)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    NEMTBA
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE SEARCHES FOR MNEMONIC NEMO WITHIN THE
C  INTERNAL TABLE A ARRAYS HOLDING THE DICTIONARY TABLE (ARRAYS IN
C  COMMON BLOCK /TABABD/) AND, IF FOUND, RETURNS INFORMATION ABOUT THAT
C  MNEMONIC FROM WITHIN THESE ARRAYS.  IT IS IDENTICAL TO BUFR ARCHIVE
C  LIBRARY SUBROUTINE NEMTBAX EXCEPT IF NEMO IS NOT FOUND, THIS
C  SUBROUTINE MAKES AN APPROPRIATE CALL TO BUFR ARCHIVE LIBRARY
C  SUBROUTINE BORT.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1995-06-28  J. WOOLLEN -- INCREASED THE SIZE OF INTERNAL BUFR TABLE
C                           ARRAYS IN ORDER TO HANDLE BIGGER FILES
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL NEMTBA (LUN, NEMO, MTYP, MSBT, INOD)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     NEMO     - CHARACTER*(*): TABLE A MNEMONIC TO SEARCH FOR
C
C   OUTPUT ARGUMENT LIST:
C     MTYP     - INTEGER: MESSAGE TYPE CORRESPONDING TO NEMO
C     MSBT     - INTEGER: MESSAGE SUBTYPE CORRESPONDING TO NEMO
C     INOD     - INTEGER: POSITIONAL INDEX OF NEMO WITHIN INTERNAL
C                JUMP/LINK TABLE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT
C    THIS ROUTINE IS CALLED BY: CMSGINI  COPYMG   CPYMEM   MSGINI
C                               OPENMB   OPENMG   XMSGINI
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MAXTBA=50)
      PARAMETER (MAXTBB=250)
      PARAMETER (MAXTBD=250)

      COMMON /TABABD/ NTBA(0:NFILES),NTBB(0:NFILES),NTBD(0:NFILES),
     .                MTAB(MAXTBA,NFILES),IDNA(MAXTBA,NFILES,2),
     .                IDNB(MAXTBB,NFILES),IDND(MAXTBD,NFILES),
     .                TABA(MAXTBA,NFILES),TABB(MAXTBB,NFILES),
     .                TABD(MAXTBD,NFILES)

      CHARACTER*(*) NEMO
      CHARACTER*600 TABD
      CHARACTER*128 BORT_STR
      CHARACTER*128 TABB
      CHARACTER*128 TABA

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  LOOK FOR NEMO IN TABLE A
C  ------------------------

      DO I=1,NTBA(LUN)
      IF(TABA(I,LUN)(4:11).EQ.NEMO) THEN
         MTYP = IDNA(I,LUN,1)
         MSBT = IDNA(I,LUN,2)
         INOD = MTAB(I,LUN)
         IF(MTYP.LT.0 .OR. MTYP.GT.255) GOTO 901
         IF(MSBT.LT.0 .OR. MSBT.GT.255) GOTO 902
         GOTO 100
      ENDIF
      ENDDO
      GOTO 900

C  EXITS
C  -----

100   RETURN
900   WRITE(BORT_STR,'("BUFRLIB: NEMTBA - CAN''T FIND MNEMONIC ",A)')
     . NEMO
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: NEMTBA - INVALID MESSAGE TYPE (",I4,'//
     . '") RETURNED FOR MENMONIC ",A)') MTYP,NEMO
      CALL BORT(BORT_STR)
902   WRITE(BORT_STR,'("BUFRLIB: NEMTBA - INVALID MESSAGE SUBTYPE (",'//
     . 'I4,") RETURNED FOR MENMONIC ",A)') MSBT,NEMO
      CALL BORT(BORT_STR)
      END
      SUBROUTINE NEMTBAX(LUN,NEMO,MTYP,MSBT,INOD)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    NEMTBAX
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1999-11-18
C
C ABSTRACT: THIS SUBROUTINE SEARCHES FOR MNEMONIC NEMO WITHIN THE
C   INTERNAL TABLE A ARRAYS HOLDING THE DICTIONARY TABLE (ARRAYS IN
C   COMMON BLOCK /TABABD/) AND, IF FOUND, RETURNS INFORMATION ABOUT
C   THAT MNEMONIC FROM WITHIN THESE ARRAYS.  IT IS IDENTICAL TO BUFR
C   ARCHIVE LIBRARY SUBROUTINE NEMTBA EXCEPT IF NEMO IS NOT FOUND, THIS
C   SUBROUTINE RETURNS WITH INOD EQUAL TO ZERO (NEMTBA CALLS BUFR
C   ARCHIVE LIBRARY SUBROUTINE BORT IN THIS CASE).
C
C PROGRAM HISTORY LOG:
C 1999-11-18  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL NEMTBAX (LUN, NEMO, MTYP, MSBT, INOD)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     NEMO     - CHARACTER*(*): TABLE A MNEMONIC TO SEARCH FOR
C
C   OUTPUT ARGUMENT LIST:
C     MTYP     - INTEGER: MESSAGE TYPE CORRESPONDING TO NEMO
C     MSBT     - INTEGER: MESSAGE SUBTYPE CORRESPONDING TO NEMO
C     INOD     - INTEGER: POSITIONAL INDEX OF NEMO WITHIN INTERNAL
C                         JUMP/LINK TABLE IF NEMO FOUND
C                       0 = NEMO not found
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT
C    THIS ROUTINE IS CALLED BY: CKTABA
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MAXTBA=50)
      PARAMETER (MAXTBB=250)
      PARAMETER (MAXTBD=250)

      COMMON /TABABD/ NTBA(0:NFILES),NTBB(0:NFILES),NTBD(0:NFILES),
     .                MTAB(MAXTBA,NFILES),IDNA(MAXTBA,NFILES,2),
     .                IDNB(MAXTBB,NFILES),IDND(MAXTBD,NFILES),
     .                TABA(MAXTBA,NFILES),TABB(MAXTBB,NFILES),
     .                TABD(MAXTBD,NFILES)

      CHARACTER*(*) NEMO
      CHARACTER*600 TABD
      CHARACTER*128 BORT_STR
      CHARACTER*128 TABB
      CHARACTER*128 TABA

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      INOD = 0

C  LOOK FOR NEMO IN TABLE A
C  ------------------------

      DO I=1,NTBA(LUN)
      IF(TABA(I,LUN)(4:11).EQ.NEMO) THEN
         MTYP = IDNA(I,LUN,1)
         MSBT = IDNA(I,LUN,2)
         INOD = MTAB(I,LUN)
         IF(MTYP.LT.0 .OR. MTYP.GT.255) GOTO 900
         IF(MSBT.LT.0 .OR. MSBT.GT.255) GOTO 901
         GOTO 100
      ENDIF
      ENDDO

C  EXITS
C  -----

100   RETURN
900   WRITE(BORT_STR,'("BUFRLIB: NEMTBAX - INVALID MESSAGE TYPE (",I4'//
     . ',") RETURNED FOR MENMONIC ",A)') MTYP,NEMO
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: NEMTBAX - INVALID MESSAGE SUBTYPE ("'//
     . ',I4,") RETURNED FOR MENMONIC ",A)') MSBT,NEMO
      CALL BORT(BORT_STR)
      END
      SUBROUTINE NEMTBB(LUN,ITAB,UNIT,ISCL,IREF,IBIT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    NEMTBB
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE CHECKS ALL OF THE PROPERTIES (E.G. FXY
C   VALUE, UNITS, SCALE FACTOR, REFERENCE VALUE, ETC.) OF A SPECIFIED
C   MNEMONIC WITHIN THE INTERNAL BUFR TABLE B ARRAYS (IN COMMON BLOCK
C   /TABABD/) IN ORDER TO VERIFY THAT THE VALUES OF THOSE PROPERTIES
C   ARE ALL LEGAL AND WELL-DEFINED.  IF ANY ERRORS ARE FOUND, THEN AN
C   APPROPRIATE CALL IS MADE TO BUFR ARCHIVE LIBRARY SUBROUTINE BORT.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1995-06-28  J. WOOLLEN -- INCREASED THE SIZE OF INTERNAL BUFR TABLE
C                           ARRAYS IN ORDER TO HANDLE BIGGER FILES
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"; CORRECTED SOME MINOR ERRORS
C 1999-11-18  J. WOOLLEN -- CHANGED CALL TO FUNCTION "VAL$" TO "VALX"
C                           (IT HAS BEEN RENAMED TO REMOVE THE
C                           POSSIBILITY OF THE "$" SYMBOL CAUSING
C                           PROBLEMS ON OTHER PLATFORMS)
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL NEMTBB (LUN, ITAB, UNIT, ISCL, IREF, IBIT)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     ITAB     - INTEGER: POSITIONAL INDEX INTO INTERNAL BUFR TABLE B
C                ARRAYS FOR MNEMONIC TO BE CHECKED
C
C   OUTPUT ARGUMENT LIST:
C     UNIT     - CHARACTER*24: UNITS OF MNEMONIC
C     ISCL     - INTEGER: SCALE FACTOR OF MNEMONIC
C     IREF     - INTEGER: REFERENCE VALUE OF MNEMONIC
C     IBIT     - INTEGER: BIT WIDTH OF MNEMONIC
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     IFXY     VALX
C    THIS ROUTINE IS CALLED BY: CHEKSTAB TABENT
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MAXTBA=50)
      PARAMETER (MAXTBB=250)
      PARAMETER (MAXTBD=250)

      COMMON /TABABD/ NTBA(0:NFILES),NTBB(0:NFILES),NTBD(0:NFILES),
     .                MTAB(MAXTBA,NFILES),IDNA(MAXTBA,NFILES,2),
     .                IDNB(MAXTBB,NFILES),IDND(MAXTBD,NFILES),
     .                TABA(MAXTBA,NFILES),TABB(MAXTBB,NFILES),
     .                TABD(MAXTBD,NFILES)

      CHARACTER*600 TABD
      CHARACTER*128 BORT_STR
      CHARACTER*128 TABB
      CHARACTER*128 TABA
      CHARACTER*24  UNIT
      CHARACTER*8   NEMO
      REAL*8        MXR

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      MXR = 1E11-1

      IF(ITAB.LE.0 .OR. ITAB.GT.NTBB(LUN)) GOTO 900

C  PULL OUT TABLE B INFORMATION
C  ----------------------------

      IDN  = IDNB(ITAB,LUN)
      NEMO = TABB(ITAB,LUN)( 7:14)
      UNIT = TABB(ITAB,LUN)(71:94)
      ISCL = VALX(TABB(ITAB,LUN)( 95: 98))
      IREF = VALX(TABB(ITAB,LUN)( 99:109))
      IBIT = VALX(TABB(ITAB,LUN)(110:112))

C  CHECK TABLE B CONTENTS
C  ----------------------

      IF(IDN.LT.IFXY('000000')) GOTO 901
      IF(IDN.GT.IFXY('063255')) GOTO 901

      IF(ISCL.LT.-999 .OR. ISCL.GT.999) GOTO 902
      IF(IREF.LE.-MXR .OR. IREF.GE.MXR) GOTO 903
      IF(IBIT.LE.0) GOTO 904
      IF(UNIT(1:5).NE.'CCITT' .AND. IBIT.GT.32      ) GOTO 904
      IF(UNIT(1:5).EQ.'CCITT' .AND. MOD(IBIT,8).NE.0) GOTO 905

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: NEMTBB - ITAB (",I7,") NOT FOUND IN '//
     . 'TABLE B")') ITAB
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: NEMTBB - INTEGER REPRESENTATION OF '//
     . 'DESCRIPTOR FOR TABLE B MNEMONIC ",A," (",I7,") IS OUTSIDE '//
     . 'RANGE 0-16383 (16283 -> 0-63-255)")') NEMO,IDN
      CALL BORT(BORT_STR)
902   WRITE(BORT_STR,'("BUFRLIB: NEMTBB - SCALE VALUE FOR TABLE B '//
     .'MNEMONIC ",A," (",I7,") IS OUTSIDE RANGE -999 TO 999")')
     . NEMO,ISCL
      CALL BORT(BORT_STR)
903   WRITE(BORT_STR,'("BUFRLIB: NEMTBB - REFERENCE VALUE FOR TABLE B'//
     .' MNEMONIC ",A," (",I7,") IS OUTSIDE RANGE +/- 1E11-1")')
     . NEMO,IREF
      CALL BORT(BORT_STR)
904   WRITE(BORT_STR,'("BUFRLIB: NEMTBB - BIT WIDTH FOR NON-CHARACTER'//
     . ' TABLE B MNEMONIC ",A," (",I7,") IS > 32")') NEMO,IBIT
      CALL BORT(BORT_STR)
905   WRITE(BORT_STR,'("BUFRLIB: NEMTBB - BIT WIDTH FOR CHARACTER '//
     . 'TABLE B MNEMONIC ",A," (",I7,") IS NOT A MULTIPLE OF 8")')
     . NEMO,IBIT
      CALL BORT(BORT_STR)
      END
      SUBROUTINE NEMTBD(LUN,ITAB,NSEQ,NEMS,IRPS,KNTS)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    NEMTBD
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE RETURNS A LIST OF THE MNEMONICS (I.E.,
C   "CHILD" MNEMONICS) CONTAINED WITHIN A TABLE D SEQUENCE MNEMONIC
C   (I.E., A "PARENT MNEMONIC").  THIS INFORMATION SHOULD HAVE BEEN
C   PACKED INTO THE INTERNAL BUFR TABLE D ENTRY FOR THE PARENT MNEMONIC
C   (IN COMMON BLOCK /TABABD/) VIA PREVIOUS CALLS TO BUFR ARCHIVE
C   LIBRARY SUBROUTINE PKTDD.  NOTE THAT NEMTBD DOES NOT RECURSIVELY
C   RESOLVE CHILD MNEMONICS WHICH ARE THEMSELVES TABLE D SEQUENCE
C   MNEMONICS; RATHER, SUCH RESOLUTION MUST BE DONE VIA SEPARATE
C   SUBSEQUENT CALLS TO THIS SUBROUTINE.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1995-06-28  J. WOOLLEN -- INCREASED THE SIZE OF INTERNAL BUFR TABLE
C                           ARRAYS IN ORDER TO HANDLE BIGGER FILES
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2000-09-19  J. WOOLLEN -- MUST NOW CHECK FOR TABLE C (OPERATOR
C                           DESCRIPTOR) MNEMONICS SINCE THE CAPABILITY
C                           HAS NOW BEEN ADDED TO ENCODE AND DECODE
C                           THESE
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL NEMTBD (LUN, ITAB, NSEQ, NEMS, IRPS, KNTS)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     ITAB     - INTEGER: POSITIONAL INDEX OF PARENT MNEMONIC WITHIN
C                INTERNAL BUFR TABLE D ARRAY TABD(*,*)
C
C   OUTPUT ARGUMENT LIST:
C     NSEQ     - INTEGER: TOTAL NUMBER OF CHILD MNEMONICS FOR THE
C                PARENT MNEMONIC GIVEN BY TABD(ITAB,LUN)
C     NEMS     - CHARACTER*8: 250-WORD ARRAY CONTAINING CHILD MNEMONICS
C     IRPS     - INTEGER: 250-WORD RETURN VALUE ARRAY (SEE REMARKS)
C     KNTS     - INTEGER: 250-WORD RETURN VALUE ARRAY (FIRST NSEQ
C                VALUES FILLED (SEE REMARKS)
C
C REMARKS:
C    VALUE FOR OUTPUT ARGUMENT IRPS:
C       The interpretation of the return value IRPS(I) depends upon the
C       type of descriptor corresponding to NEMS(I), as follows:
C
C       IF ( NEMS(I) corresponds to an F=1 regular (i.e. non-delayed)
C            replication descriptor ) THEN
C          IRPS(I) = 1
C       ELSE IF ( NEMS(I) corresponds to a delayed replicator or
C                 replication factor descriptor )  THEN
C          IRPS(I) = positional index of corresponding descriptor
C                    within internal replication array IDNR(*,*)
C       ELSE
C          IRPS(I) = 0
C       END IF
C
C
C    VALUE FOR OUTPUT ARGUMENT KNTS:
C       The interpretation of the return value KNTS(I) depends upon the
C       type of descriptor corresponding to NEMS(I), as follows:
C
C       IF ( NEMS(I) corresponds to an F=1 regular (i.e. non-delayed)
C            replication descriptor ) THEN
C          KNTS(I) = number of replications
C       ELSE
C          KNTS(I) = 0
C       END IF
C
C
C    THIS ROUTINE CALLS:        BORT     IFXY     NUMTAB   RSVFVM
C                               UPTDD
C    THIS ROUTINE IS CALLED BY: CHEKSTAB TABSUBD
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MAXTBA=50)
      PARAMETER (MAXTBB=250)
      PARAMETER (MAXTBD=250)

      COMMON /TABABD/ NTBA(0:NFILES),NTBB(0:NFILES),NTBD(0:NFILES),
     .                MTAB(MAXTBA,NFILES),IDNA(MAXTBA,NFILES,2),
     .                IDNB(MAXTBB,NFILES),IDND(MAXTBD,NFILES),
     .                TABA(MAXTBA,NFILES),TABB(MAXTBB,NFILES),
     .                TABD(MAXTBD,NFILES)

      CHARACTER*600 TABD
      CHARACTER*128 TABB
      CHARACTER*128 TABA
      CHARACTER*128 BORT_STR
      CHARACTER*8   NEMO,NEMS,NEMT,NEMF
      CHARACTER*1   TAB
      DIMENSION     NEMS(250),IRPS(250),KNTS(250)
      LOGICAL       REP

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IF(ITAB.LE.0 .OR. ITAB.GT.NTBD(LUN)) GOTO 900

      REP  = .FALSE.

C  CLEAR THE RETURN VALUES
C  -----------------------

      NSEQ = 0

      DO I=1,250
      NEMS(I) = ' '
      IRPS(I) = 0
      KNTS(I) = 0
      ENDDO

C  PARSE THE TABLE D ENTRY
C  -----------------------

      NEMO = TABD(ITAB,LUN)(7:14)
      IDSC = IDND(ITAB,LUN)
      CALL UPTDD(ITAB,LUN,0,NDSC)

      IF(IDSC.LT.IFXY('300000')) GOTO 901
      IF(IDSC.GT.IFXY('363255')) GOTO 901
cccc  IF(NDSC.LE.0             ) GOTO 902

C     Loop through each child mnemonic.

c  .... DK: What happens here if NDSC=0 ?
      DO J=1,NDSC
      IF(NSEQ+1.GT.250) GOTO 903
      CALL UPTDD(ITAB,LUN,J,IDSC)
c  .... get NEMT from IDSC
      CALL NUMTAB(LUN,IDSC,NEMT,TAB,IRET)
      IF(TAB.EQ.'R') THEN
         IF(REP) GOTO 904
         REP = .TRUE.
         IF(IRET.LT.0) THEN

C           F=1 regular (i.e. non-delayed) replication.

            IRPS(NSEQ+1) = 1
            KNTS(NSEQ+1) = ABS(IRET)
         ELSEIF(IRET.GT.0) THEN

C           Delayed replication.

            IRPS(NSEQ+1) = IRET
         ENDIF
      ELSEIF(TAB.EQ.'F') THEN

C            Replication factor.

         IF(.NOT.REP) GOTO 904
         IRPS(NSEQ+1) = IRET
         REP = .FALSE.
      ELSEIF(TAB.EQ.'D'.OR.TAB.EQ.'C') THEN
         REP = .FALSE.
         NSEQ = NSEQ+1
         NEMS(NSEQ) = NEMT
      ELSEIF(TAB.EQ.'B') THEN
         REP = .FALSE.
         NSEQ = NSEQ+1
         IF(NEMT(1:1).EQ.'.') THEN

C            This is a "following value" mnemonic.

            CALL UPTDD(ITAB,LUN,J+1,IDSC)
c  .... get NEMF from IDSC
            CALL NUMTAB(LUN,IDSC,NEMF,TAB,IRET)
            CALL RSVFVM(NEMT,NEMF)
            IF(TAB.NE.'B') GOTO 906
         ENDIF
         NEMS(NSEQ) = NEMT
      ELSE
         GOTO 905
      ENDIF
      ENDDO

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: NEMTBD - ITAB (",I7,") NOT FOUND IN '//
     . 'TABLE D")') ITAB
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: NEMTBD - INTEGER REPRESENTATION OF '//
     . 'DESCRIPTOR FOR TABLE D MNEMONIC ",A," (",I7,") IS OUTSIDE '//
     . 'RANGE 0-65535 (65535 -> 3-63-255)")') NEMO,IDSC
      CALL BORT(BORT_STR)
902   WRITE(BORT_STR,'("BUFRLIB: NEMTBD - TABLE D MNEMONIC ",A," IS A'//
     . ' ZERO LENGTH SEQUENCE")') NEMO
      CALL BORT(BORT_STR)
903   WRITE(BORT_STR,'("BUFRLIB: NEMTBD - THERE ARE MORE THAN 250 '//
     . 'DESCRIPTORS (THE LIMIT) IN TABLE D SEQUENCE MNEMONIC ",A)') NEMO
      CALL BORT(BORT_STR)
904   WRITE(BORT_STR,'("BUFRLIB: NEMTBD - REPLICATOR IS OUT OF ORDER '//
     . 'IN TABLE D SEQUENCE MNEMONIC ",A)') NEMO
      CALL BORT(BORT_STR)
905   WRITE(BORT_STR,'("BUFRLIB: NEMTBD - UNRECONGIZED DESCRIPTOR '//
     . '(INTEGER=",I7,") IN TABLE D SEQUENCE MNEMONIC ",A)') IDSC,NEMO
      CALL BORT(BORT_STR)
906   WRITE(BORT_STR,'("BUFRLIB: NEMTBD - A ''FOLLOWING VALUE'' '//
     . 'MNEMONIC (",A,") IS FROM TABLE ",A,", IT MUST BE FROM TABLE B'//
     . '")') NEMF,TAB
      CALL BORT(BORT_STR)
      END
      SUBROUTINE NENUAA(NEMO,NUMB,LUN)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    NENUAA
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE CHECKS A MNEMONIC AND FXY VALUE PAIR THAT
C   WERE READ FROM A USER-SUPPLIED BUFR DICTIONARY TABLE IN CHARACTER
C   FORMAT, IN ORDER TO MAKE SURE THAT NEITHER VALUE HAS ALREADY BEEN
C   DEFINED WITHIN INTERNAL BUFR TABLE A (IN COMMON BLOCK /TABABD/) FOR
C   THE GIVEN LUN.  IF EITHER VALUE HAS ALREADY BEEN DEFINED FOR THIS
C   LUN, THEN AN APPROPRIATE CALL IS MADE TO BUFR ARCHIVE LIBRARY
C   SUBROUTINE BORT.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR (ENTRY POINT IN NENUCK)
C 1995-06-28  J. WOOLLEN -- INCREASED THE SIZE OF INTERNAL BUFR TABLE
C                           ARRAYS IN ORDER TO HANDLE BIGGER FILES
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT" (IN PARENT ROUTINE NENUCK)
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI) (IN PARENT
C                           ROUTINE NENUCK)
C 2002-05-14  J. WOOLLEN -- CHANGED FROM AN ENTRY POINT TO INCREASE
C                           PORTABILITY TO OTHER PLATFORMS (NENUCK WAS
C                           THEN REMOVED BECAUSE IT WAS JUST A DUMMY
C                           ROUTINE WITH ENTRIES)
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL NENUAA (NEMO, NUMB, LUN)
C   INPUT ARGUMENT LIST:
C     NEMO     - CHARACTER*8: MNEMONIC
C     NUMB     - CHARACTER*6: FXY VALUE ASSOCIATED WITH NEMO
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C
C REMARKS:
C
C    EXAMPLE SHOWING LAYOUT OF INTERNAL BUFR TABLE A (FROM A DBX DEBUG
C    SESSION USING "bufrtab.002", AND WHERE LUN = 1)
C
C   (dbx) print NTBA[1]
C   8
C
C   (dbx) print TABA[1,1]
C   0x1002c764 = "218NC002001 MESSAGE TYPE 002-001  RAWINSONDE -",
C                " FIXED LAND                                   ",
C                "                                    "
C
C   (dbx) print TABA[2,1]
C   0x1002c7e4 = "219NC002002 MESSAGE TYPE 002-002  RAWINSONDE -",
C                " MOBIL LAND                                   ",
C                "                                    "
C
C   (dbx) print TABA[3,1]
C   0x1002c864 = "220NC002003 MESSAGE TYPE 002-003  RAWINSONDE -",
C                " SHIP                                         ",
C                "                                    "
C
C   and so on, up through TABA[8,1] ( = TABA[NTBA[LUN],LUN] )
C
C
C    THIS ROUTINE CALLS:        BORT
C    THIS ROUTINE IS CALLED BY: RDBFDX   RDUSDX
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MAXTBA=50)
      PARAMETER (MAXTBB=250)
      PARAMETER (MAXTBD=250)

      COMMON /TABABD/ NTBA(0:NFILES),NTBB(0:NFILES),NTBD(0:NFILES),
     .                MTAB(MAXTBA,NFILES),IDNA(MAXTBA,NFILES,2),
     .                IDNB(MAXTBB,NFILES),IDND(MAXTBD,NFILES),
     .                TABA(MAXTBA,NFILES),TABB(MAXTBB,NFILES),
     .                TABD(MAXTBD,NFILES)

      CHARACTER*600 TABD
      CHARACTER*128 BORT_STR
      CHARACTER*128 TABB
      CHARACTER*128 TABA
      CHARACTER*8   NEMO
      CHARACTER*6   NUMB

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  CHECK TABLE A
C  -------------

      DO N=1,NTBA(LUN)
      IF(NUMB(4:6).EQ.TABA(N,LUN)(1: 3)) GOTO 900
      IF(NEMO     .EQ.TABA(N,LUN)(4:11)) GOTO 901
      ENDDO

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: NENUAA - TABLE A FXY VALUE (",A,") '//
     . 'HAS ALREADY BEEN DEFINED (DUPLICATE)")') NUMB
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: NENUAA - TABLE A MNEMONIC (",A,") '//
     . 'HAS ALREADY BEEN DEFINED (DUPLICATE)")') NEMO
      CALL BORT(BORT_STR)
      END
      SUBROUTINE NENUBD(NEMO,NUMB,LUN)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    NENUBD
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE CHECKS A MNEMONIC AND FXY VALUE PAIR THAT
C   WERE READ FROM A USER-SUPPLIED BUFR DICTIONARY TABLE IN CHARACTER
C   FORMAT, IN ORDER TO MAKE SURE THAT NEITHER VALUE HAS ALREADY BEEN
C   DEFINED WITHIN INTERNAL BUFR TABLE B OR D (IN COMMON BLOCK
C   /TABABD/) FOR THE GIVEN LUN.  IF EITHER VALUE HAS ALREADY BEEN
C   DEFINED FOR THIS LUN, THEN AN APPROPRIATE CALL IS MADE TO
C   BUFR ARCHIVE LIBRARY SUBROUTINE BORT.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR (ENTRY POINT IN NENUCK)
C 1995-06-28  J. WOOLLEN -- INCREASED THE SIZE OF INTERNAL BUFR TABLE
C                           ARRAYS IN ORDER TO HANDLE BIGGER FILES
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT" (IN PARENT ROUTINE NENUCK)
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI) (IN PARENT
C                           ROUTINE NENUCK)
C 2002-05-14  J. WOOLLEN -- CHANGED FROM AN ENTRY POINT TO INCREASE
C                           PORTABILITY TO OTHER PLATFORMS (NENUCK WAS
C                           THEN REMOVED BECAUSE IT WAS JUST A DUMMY
C                           ROUTINE WITH ENTRIES)
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL NENUBD (NEMO, NUMB, LUN)
C   INPUT ARGUMENT LIST:
C     NEMO     - CHARACTER*8: MNEMONIC
C     NUMB     - CHARACTER*6: FXY VALUE ASSOCIATED WITH NEMO
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C
C REMARKS:
C    EXAMPLE SHOWING LAYOUT OF INTERNAL BUFR TABLE B (FROM A DBX DEBUG
C    SESSION USING "bufrtab.002", AND WHERE LUN = 1)
C
C   (dbx) print NTBB[1]
C   95
C
C   (dbx) print TABB[1,1]
C   0x1003c164 = "063000BYTCNT                                  ",
C                "                        BYTES                 ",
C                "  +0  +0         16                 "
C
C   (dbx) print TABB[2,1]
C   0x1003c1e4 = "063255BITPAD                                  ",
C                "                        NONE                  ",
C                "  +0  +0         1                  "
C
C   (dbx) print TABB[3,1]
C   0x1003c264 = "031000DRF1BIT                                 ",
C                "                        NUMERIC               ",
C                "  +0  +0         1                  "
C
C   (dbx) print TABB[8,1]
C   0x1003c4e4 = "001003WMOR     WMO REGION NUMBER              ",
C                "                        CODE TABLE            ",
C                "  +0  +0         3                  "
C
C   (dbx) print TABB[11,1]
C   0x1003c664 = "001194BUHD     BULLETIN HEADER                ",
C                "                        CCITT IA5             ",
C                "  +0  +0         64                 "
C
C   (dbx) print TABB[21,1]
C   0x1003cb64 = "004003DAYS     DAY                            ",
C                "                        DAY                   ",
C                "  +0  +0         6                  "
C
C   (dbx) print TABB[33,1]
C   0x1003d164 = "005002CLAT     LATITUDE (COARSE ACCURACY)     ",
C                "                        DEGREES               ",
C                "  +2  -0000"     15                 "
C
C   and so on, up through TABB[95,1] ( = TABB[NTBB[LUN],LUN] )
C
C
C
C    EXAMPLE SHOWING LAYOUT OF INTERNAL BUFR TABLE D (FROM A DBX DEBUG
C    SESSION USING "bufrtab.002", AND WHERE LUN = 1)
C
C   (dbx) print NTBD[1]
C   43
C
C   (dbx) &TABD[1,1]/14c
C   1008a364:  '3' '6' '0' '0' '0' '1' 'D' 'R' 'P' '1' '6' 'B' 'I' 'T'
C
C   (dbx) &TABD[2,1]/14c
C   1008a5bc:  '3' '6' '0' '0' '0' '2' 'D' 'R' 'P' '8' 'B' 'I' 'T' ' '
C
C   (dbx) &TABD[3,1]/14c
C   1008a814:  '3' '6' '0' '0' '0' '3' 'D' 'R' 'P' 'S' 'T' 'A' 'K' ' '
C
C   (dbx) &TABD[4,1]/14c
C   1008aa6c:  '3' '6' '0' '0' '0' '4' 'D' 'R' 'P' '1' 'B' 'I' 'T' ' '
C
C   (dbx) &TABD[5,1]/14c
C   1008acc4:  '3' '6' '3' '2' '1' '8' 'N' 'C' '0' '0' '2' '0' '0' '1'
C
C   (dbx) &TABD[6,1]/14c
C   1008af1c:  '3' '6' '3' '2' '1' '9' 'N' 'C' '0' '0' '2' '0' '0' '2'
C
C   (dbx) &TABD[24,1]/14c
C   1008d94c:  '3' '6' '1' '1' '3' '0' 'U' 'A' 'A' 'D' 'F' ' ' ' ' ' '
C
C   and so on, up through TABD[43,1] ( = TABD[NTBD[LUN],LUN] )
C
C
C    THIS ROUTINE CALLS:        BORT
C    THIS ROUTINE IS CALLED BY: RDBFDX   RDUSDX
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MAXTBA=50)
      PARAMETER (MAXTBB=250)
      PARAMETER (MAXTBD=250)

      COMMON /TABABD/ NTBA(0:NFILES),NTBB(0:NFILES),NTBD(0:NFILES),
     .                MTAB(MAXTBA,NFILES),IDNA(MAXTBA,NFILES,2),
     .                IDNB(MAXTBB,NFILES),IDND(MAXTBD,NFILES),
     .                TABA(MAXTBA,NFILES),TABB(MAXTBB,NFILES),
     .                TABD(MAXTBD,NFILES)

      CHARACTER*600 TABD
      CHARACTER*128 BORT_STR
      CHARACTER*128 TABB
      CHARACTER*128 TABA
      CHARACTER*8   NEMO
      CHARACTER*6   NUMB

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C  CHECK TABLE B AND D
C  -------------------

      DO N=1,NTBB(LUN)
      IF(NUMB.EQ.TABB(N,LUN)(1: 6)) GOTO 900
      IF(NEMO.EQ.TABB(N,LUN)(7:14)) GOTO 901
      ENDDO

      DO N=1,NTBD(LUN)
      IF(NUMB.EQ.TABD(N,LUN)(1: 6)) GOTO 902
      IF(NEMO.EQ.TABD(N,LUN)(7:14)) GOTO 903
      ENDDO

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: NENUBD - TABLE B FXY VALUE (",A,") '//
     . 'HAS ALREADY BEEN DEFINED (DUPLICATE)")') NUMB
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: NENUAA - TABLE B MNEMONIC (",A,") '//
     . 'HAS ALREADY BEEN DEFINED (DUPLICATE)")') NEMO
      CALL BORT(BORT_STR)
902   WRITE(BORT_STR,'("BUFRLIB: NENUBD - TABLE D FXY VALUE (",A,") '//
     . 'HAS ALREADY BEEN DEFINED (DUPLICATE)")') NUMB
      CALL BORT(BORT_STR)
903   WRITE(BORT_STR,'("BUFRLIB: NENUAA - TABLE D MNEMONIC (",A,") '//
     . 'HAS ALREADY BEEN DEFINED (DUPLICATE)")') NEMO
      CALL BORT(BORT_STR)
      END
      FUNCTION NEVN(NODE,LUN,INV1,INV2,I1,I2,I3,USR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    NEVN (docblock incomplete)
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2003-11-04
C
C ABSTRACT: THIS FUNCTION ACCUMULATES ALL DATA EVENTS FOR A PARTICULAR
C   DATA VALUE AND LEVEL AND RETURNS THEM TO THE CALLING PROGRAM.  THE
C   VALUE OF THE FUNCTION ITSELF IS THE TOTAL NUMBER OF EVENTS FOUND.
C
C PROGRAM HISTORY LOG:
C 2003-11-04  J. WOOLLEN -- ORIGINAL AUTHOR (WAS IN VERIFICATION
C                           VERSION)
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY)
C                           (INCOMPLETE); OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    NEVN (NODE, LUN, INV1, INV2, I1, I2, I3, USR)
C   INPUT ARGUMENT LIST:
C     NODE     - INTEGER: ....
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     INV1     - INTEGER: ....
C     INV2     - INTEGER: ....
C     I1       - INTEGER: LENGTH OF FIRST DIMENSION OF USR
C     I2       - INTEGER: LENGTH OF SECOND DIMENSION OF USR
C     I3       - INTEGER: LENGTH OF THIRD DIMENSION OF USR
C
C   OUTPUT ARGUMENT LIST:
C     USR      - REAL*8:(I1,I2,I3) STARTING ADDRESS OF DATA VALUES READ
C                FROM DATA SUBSET, EVENTS ARE RETURNED IN THE THIRD
C                DIMENSION FOR A PARTICULAR DATA VALUE AND LEVEL IN THE
C                FIRST AND SECOND DIMENSIONS
C     NEVN     - INTEGER: NUMBER OF EVENTS IN STACK (MUST BE LESS THAN
C                OR EQUAL TO I3)
C
C REMARKS:
C    IMPORTANT: THIS ROUTINE SHOULD ONLY BE CALLED BY ROUTINE UFBIN3,
C               WHICH, ITSELF, IS CALLED ONLY BY VERIFICATION
C               APPLICATION PROGRAM GRIDTOBS, WHERE IT WAS PREVIOUSLY
C               AN IN-LINE SUBROUTINE.  IN GENERAL, NEVN DOES NOT WORK
C               PROPERLY IN OTHER APPLICATION PROGRAMS AT THIS TIME.
C
C    THIS ROUTINE CALLS:        BORT     INVWIN   LSTJPB
C    THIS ROUTINE IS CALLED BY: UFBIN3
C                               Should NOT be called by any
C                               application programs!!!
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)

      CHARACTER*128 BORT_STR
      DIMENSION     USR(I1,I2,I3)
      REAL*8        VAL,USR

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      NEVN = 0

C  FIND THE ENCLOSING EVENT STACK DESCRIPTOR
C  -----------------------------------------

      NDRS = LSTJPB(NODE,LUN,'DRS')
      IF(NDRS.LE.0) GOTO 100

      INVN = INVWIN(NDRS,LUN,INV1,INV2)
      IF(INVN.EQ.0) GOTO 900

      NEVN = VAL(INVN,LUN)
      IF(NEVN.GT.I3) GOTO 901

C  SEARCH EACH STACK LEVEL FOR THE REQUESTED NODE AND COPY THE VALUE
C  -----------------------------------------------------------------

      N2 = INVN + 1

      DO L=1,NEVN
        N1 = N2
        N2 = N2 + VAL(N1,LUN)
        DO N=N1,N2
        IF(INV(N,LUN).EQ.NODE) USR(1,1,L) = VAL(N,LUN)
        ENDDO
      ENDDO

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: NEVN - CAN''T FIND THE EVENT STACK!!!!!!')
901   WRITE(BORT_STR,'("BUFRLIB: NEVN - THE NO. OF EVENTS FOR THE '//
     . 'REQUESTED STACK (",I3,") EXCEEDS THE VALUE OF THE 3RD DIM. OF'//
     . ' THE USR ARRAY (",I3,")")') NEVN,I3
      CALL BORT(BORT_STR)
      END
      SUBROUTINE NEWWIN(LUN,IWIN,JWIN)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    NEWWIN (docblock incomplete)
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE ....
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2002-05-14  J. WOOLLEN -- REMOVED OLD CRAY COMPILER DIRECTIVES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY) (INCOMPLETE); OUTPUTS MORE
C                           COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL NEWWIN (LUN, IWIN, JWIN)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     IWIN     - INTEGER: ....
C
C   OUTPUT ARGUMENT LIST:
C     JWIN     - INTEGER: ....
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     LSTRPC
C    THIS ROUTINE IS CALLED BY: CONWIN   DRSTPL   UFBRW
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)

      CHARACTER*128 BORT_STR
      REAL*8        VAL

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      IF(IWIN.EQ.1) THEN
         JWIN = NVAL(LUN)
         GOTO 100
      ENDIF

C  REFIND THE JWIN BOUNDARY FROM IWIN
C  ----------------------------------

      NODE = INV(IWIN,LUN)
      IF(LSTRPC(NODE,LUN).NE.NODE) GOTO 900
      JWIN = IWIN+VAL(IWIN,LUN)

C  EXITS
C  -----

100   RETURN
900   WRITE(BORT_STR,'("BUFRLIB: NEWWIN - LISTRPC FOR NODE",I6,'//
     . '" (LISTRPC=",I5,") DOES NOT EQUAL VALUE OF NODE, NOT RPC '//
     . '(IWIN =",I8,")")') NODE,LSTRPC(NODE,LUN),IWIN
      CALL BORT(BORT_STR)
      END
      FUNCTION NMBYT(LUNIT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    NMBYT
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2000-09-19
C
C ABSTRACT: THIS FUNCTION RETURNS THE LENGTH OF A BUFR MESSAGE OPEN FOR
C   INPUT VIA A PREVIOUS CALL TO BUFR ARCHIVE LIBRARY SUBROUTINE READMG
C   OR EQUIVALENT.  LMSG ALSO PERFORMS THIS FUNCTION, BUT ON BUFR
C   MESSAGES AND FILES THAT HAVE NOT BEEN OPENED FOR INPUT BY BUFR
C   ARCHIVE LIBRARY SUBROUTINES OPENBF AND READMG OR THEIR EQUIVALENTS.
C
C PROGRAM HISTORY LOG:
C 2000-09-19  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    NMBYT (LUNIT)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     NMBYT    - INTEGER: BUFR MESSAGE LENGTH (BYTES)
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     IUPB     STATUS
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      NMBYT = -1

C  CHECK THE FILE STATUS
C  ---------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      IF(IM.EQ.0) GOTO 902
      NMBYT = IUPB(MBAY(1,LUN),5,24)

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: NMBYT - INPUT BUFR FILE IS CLOSED, IT MUST '//
     . 'BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: NMBYT - INPUT BUFR FILE IS OPEN FOR OUTPUT,'//
     . ' IT MUST BE OPEN FOR INPUT')
902   CALL BORT('BUFRLIB: NMBYT - A MESSAGE MUST BE OPEN IN INPUT '//
     . 'BUFR FILE, NONE ARE')
      END
      FUNCTION NMSUB(LUNIT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    NMSUB
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION RETURNS THE NUMBER OF SUBSETS IN A BUFR
C   MESSAGE OPEN FOR INPUT VIA A PREVIOUS CALL TO BUFR ARCHIVE LIBRARY
C   SUBROUTINE READMG OR EQUIVALENT.  THE SUBSETS THEMSELVES DO NOT
C   HAVE TO BE READ.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    NMSUB (LUNIT)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     NMSUB    - INTEGER: NUMBER OF SUBSETS IN BUFR MESSAGE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     STATUS
C    THIS ROUTINE IS CALLED BY: UFBMNS   UFBTAB   UFBTAM
C                               Also called by application programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      NMSUB = 0

C  CHECK THE FILE STATUS
C  ---------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      IF(IM.EQ.0) GOTO 902

      NMSUB = MSUB(LUN)

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: NMSUB - INPUT BUFR FILE IS CLOSED, IT MUST '//
     . 'BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: NMSUB - INPUT BUFR FILE IS OPEN FOR OUTPUT,'//
     . ' IT MUST BE OPEN FOR INPUT')
902   CALL BORT('BUFRLIB: NMSUB - A MESSAGE MUST BE OPEN IN INPUT '//
     . 'BUFR FILE, NONE ARE')
      END
      FUNCTION NUMBCK(NUMB)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    NUMBCK
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION CHECKS THE CHARACTER STRING REPRESENTING AN
C   FXY (DESCRIPTOR) VALUE THAT WAS READ VIA BUFR ARCHIVE LIBRARY
C   SUBROUTINE RDUSDX (I.E., READ FROM A USER-SUPPLIED BUFR DICTIONARY
C   TABLE IN CHARACTER FORMAT) TO VERIFY THAT THE FIRST CHARACTER (THE
C   "F" VALUE) IS 'A', '0' OR '3'; THAT THE REMAINING CHARACTERS (2-6)
C   (THE "X" AND "Y" VALUES) ARE ALL NUMERIC; THAT CHARACTERS 2-3 (THE
C   "X" VALUE) ARE BETWEEN '00' AND '63'; AND THAT CHARACTERS 4-6 (THE
C   "Y" VALUE) ARE BETWEEN '000' AND '255'.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- SPLIT NON-ZERO RETURN INTO -1 FOR INVALID
C                           CHARACTER IN POSITION 1, -2 FOR INVALID
C                           CHARACTERS IN POSITIONS 2 THROUGH 6, -3 FOR
C                           INVALID CHARACTERS IN POSITIONS 2 AND 3 DUE
C                           TO BEING OUT OF RANGE, AND -4 FOR INVALID
C                           CHARACTERS IN POSITIONS 4 THROUGH 6 DUE TO
C                           BEING OUT OF RANGE (RETURN ONLY -1 BEFORE
C                           FOR ALL PROBLEMATIC CASES); UNIFIED/
C                           PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION
C
C USAGE:   NUMBCK (NUMB)
C   INPUT ARGUMENT LIST:
C     NUMB     - CHARACTER*6: FXY VALUE TO BE CHECKED
C
C   OUTPUT ARGUMENT LIST:
C     NUMBCK   - INTEGER: INDICATOR AS TO WHETHER NUMB IS VALID:
C                       0 = yes
C                      -1 = no, first character ("F"value) is not 'A',
C                           '0' OR '3'
C                      -2 = no, remaining characters (2-6) ("X" and "Y"
C                           values) are not all numeric
C                      -3 = no, characters 2-3 ("X" value) are not
C                           between '00' and '63'
C                      -4 = no, characters 4-6 ("Y" value) are not
C                           between '000' and '255'
C
C REMARKS:
C    THIS ROUTINE CALLS:        DIGIT
C    THIS ROUTINE IS CALLED BY: RDUSDX
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*10 CHRSET
      CHARACTER*6  NUMB
      CHARACTER*1  FC
      LOGICAL      DIGIT

      DATA CHRSET /'0123456789'/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      NUMBCK = 0
      LNUMB  = 0
      FC     = NUMB(1:1)

C  CHECK THE FIRST CHARACTER OF NUMB
C  ---------------------------------

      IF(.NOT.(FC.EQ.'A' .OR. FC.EQ.'0' .OR. FC.EQ.'3')) THEN
         NUMBCK = -1
         GOTO 100
      ENDIF

C  CHECK THE REST OF NUMB
C  ----------------------

      DO 10 I=2,6
      DO J=1,10
      IF(NUMB(I:I).EQ.CHRSET(J:J)) GOTO 10
      ENDDO
      NUMBCK = -2
      GOTO 100
10    ENDDO

C  CHECK FOR A VALID DESCRIPTOR
C  ----------------------------

      IF(DIGIT(NUMB(2:6))) THEN
         READ(NUMB,'(1X,I2,I3)') IX,IY
      ELSE
         NUMBCK = -2
         GOTO 100
      ENDIF

      IF(IX.LT.0 .OR. IX.GT. 63) THEN
         NUMBCK = -3
         GOTO 100
      ELSE IF(IY.LT.0 .OR. IY.GT.255) THEN
         NUMBCK = -4
         GOTO 100
      ENDIF

      NUMBCK = 0

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE NUMTAB(LUN,IDN,NEMO,TAB,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    NUMTAB
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE FIRST SEARCHES FOR AN INTEGER IDN,
C   CONTAINING THE BIT-WISE REPRESENTATION OF A DESCRIPTOR (FXY) VALUE,
C   WITHIN THE INTERNAL BUFR REPLICATION ARRAYS IN COMMON BLOCK
C   /REPTAB/ TO SEE IF IDN IS A REPLICATION DESCRIPTOR OR A REPLICATION
C   FACTOR DESCRIPTOR.  IF THIS SEARCH IS UNSUCCESSFUL, IT SEACHES FOR
C   IDN WITHIN THE INTERNAL BUFR TABLE D AND B ARRAYS IN COMMON BLOCK
C   /TABABD/ TO SEE IF IDN IS A TABLE D OR TABLE B DESCRIPTOR.  IF THIS
C   SEARCH IS ALSO UNSUCCESSFUL, IT SEARCHES TO SEE IF IDN IS A TABLE C
C   OPERATOR DESCRIPTOR.  IF IDN IS FOUND IN ANY OF THESE SEARCHES,
C   THIS SUBROUTINE RETURNS THE CORRESPONDING MNEMONIC AND OTHER
C   INFORMATION FROM WITHIN EITHER THE INTERNAL ARRAYS FOR REPLICATION,
C   REPLICATION FACTOR, TABLE D OR TABLE B DESCRIPTORS; OR FROM THE
C   KNOWN VALUES FOR TABLE C DESCRIPTORS.  IF IDN IS NOT FOUND, IT
C   RETURNS WITH IRET=0.  THIS SUBROUTINE IS IDENTICAL TO BUFR ARCHIVE
C   LIBRARY SUBROUTINE NUMTBD EXCEPT NUMTBD SEARCHS FOR IDN WITHIN ONLY
C   THE INTERNAL TABLE D AND B ARRAYS.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1995-06-28  J. WOOLLEN -- INCREASED THE SIZE OF INTERNAL BUFR TABLE
C                           ARRAYS IN ORDER TO HANDLE BIGGER FILES
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2000-09-19  J. WOOLLEN -- ADDED CAPABILITY TO ENCODE AND DECODE DATA
C                           USING THE OPERATOR DESCRIPTORS (BUFR TABLE
C                           C) FOR CHANGING WIDTH AND CHANGING SCALE
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; CORRECTED TYPO ("IDN" WAS
C                           SPECIFIED AS "ID" IN CALCULATION OF IRET
C                           FOR TAB='C')
C
C USAGE:    CALL NUMTAB (LUN, IDN, NEMO, TAB, IRET)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     IDN      - INTEGER: BIT-WISE REPRESENTATION OF DESCRIPTOR (FXY)
C                VALUE
C
C   OUTPUT ARGUMENT LIST:
C     NEMO     - CHARACTER*(*): MNEMONIC CORRESPONDING TO IDN
C     TAB      - CHARACTER*1: TYPE OF FXY VALUE THAT IS BIT-WISE
C                REPRESENTED BY IDN:
C                     'B' = BUFR Table B descriptor
C                     'C' = BUFR Table C descriptor
C                     'D' = BUFR Table D descriptor
C                     'R' = BUFR replication descriptor
C                     'F' = BUFR replication factor descriptor
C     IRET     - INTEGER: RETURN VALUE (SEE REMARKS)
C
C
C REMARKS:
C    THE INTERPRETATION OF THE RETURN VALUE IRET DEPENDS UPON THE
C    RETURN VALUE OF TAB AND THE INPUT VALUE IDN, AS FOLLOWS:
C
C    IF ( TAB = 'B' ) THEN
C       IRET = positional index of IDN within internal BUFR Table B
C              array
C    ELSE IF ( TAB = 'C') THEN
C    IRET = the X portion of the FXY value that is bit-wise represented
C           by IDN
C    ELSE IF ( TAB = 'D') THEN
C       IRET = positional index of IDN within internal BUFR Table D
C              array
C    ELSE IF ( TAB = 'R') THEN
C       IF ( the F portion of the FXY value that is bit-wise
C            represented by IDN ) = 1 THEN
C          ---> regular (non-delayed) replication
C          IRET = -1 * ( the Y portion of the FXY value that is bit-
C                        wise represented by IDN )
C          ---> where Y = the number of F=1 regular replications
C       ELSE
C          ---> delayed replication
C          IRET = positional index, I, of IDN within internal
C                 replication array IDNR(I,1), where I=2,5
C          ---> IRET = I = 2 --> 16-bit delayed replication descriptor
C          ---> IRET = I = 3 -->  8-bit delayed replication descriptor
C          ---> IRET = I = 4 -->  8-bit delayed replication descriptor
C                                (stack)
C          ---> IRET = I = 5 -->  1-bit delayed replication descriptor
C       END IF
C    ELSE IF ( TAB = 'F') THEN
C       IRET = positional index, I, of IDN within internal replication
C              array IDNR(I,2), where I=2,5
C       ---> IRET = I = 2 --> 16-bit replication factor descriptor
C       ---> IRET = I = 3 -->  8-bit replication factor descriptor
C       ---> IRET = I = 4 -->  8-bit replication factor descriptor
C                              (stack)
C       ---> IRET = I = 5 -->  1-bit replication factor descriptor
C    ELSE IF ( IRET = 0 ) THEN
C       IDN was not found in internal BUFR Table B or D, nor does it
C       represent a Table C operator descriptor, a replication
C       descriptor, or a replication factor descriptor
C    END IF
C
C
C    THIS ROUTINE CALLS:        ADN30
C    THIS ROUTINE IS CALLED BY: CKTABA   NEMTBD   SEQSDX   STANDARD
C                               UFBQCP   XMSGINI
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MAXTBA=50)
      PARAMETER (MAXTBB=250)
      PARAMETER (MAXTBD=250)

C     Note that the values within the COMMON /REPTAB/ arrays were
C     initialized within subroutine BFRINI.

      COMMON /REPTAB/ IDNR(5,2),TYPS(5,2),REPS(5,2),LENS(5)

      COMMON /TABABD/ NTBA(0:NFILES),NTBB(0:NFILES),NTBD(0:NFILES),
     .                MTAB(MAXTBA,NFILES),IDNA(MAXTBA,NFILES,2),
     .                IDNB(MAXTBB,NFILES),IDND(MAXTBD,NFILES),
     .                TABA(MAXTBA,NFILES),TABB(MAXTBB,NFILES),
     .                TABD(MAXTBD,NFILES)

      CHARACTER*(*) NEMO
      CHARACTER*600 TABD
      CHARACTER*128 TABB
      CHARACTER*128 TABA
      CHARACTER*6   ADN30,CID
      CHARACTER*3   TYPS
      CHARACTER*1   REPS,TAB

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      NEMO = ' '
      IRET = 0
      TAB = ' '

C  LOOK FOR A REPLICATOR OR A REPLICATOR FACTOR DESCRIPTOR
C  -------------------------------------------------------

      IF(IDN.GE.IDNR(1,1) .AND. IDN.LE.IDNR(1,2)) THEN

C        Note that the above test is checking whether IDN is the bit-
C        wise representation of a FXY (descriptor) value denoting F=1
C        regular (i.e. non-delayed) replication, since, as was
C        initialized within subroutine BFRINI,
C        IDNR(1,1) = IFXY('101000'), and IDNR(1,2) = IFXY('101255').

         TAB  = 'R'
c  .... -Y in FXY value
         IRET = -MOD(IDN,256)
         GOTO 100
      ENDIF

      DO I=2,5
      IF(IDN.EQ.IDNR(I,1)) THEN
         TAB  = 'R'
         IRET = I
         GOTO 100
      ELSEIF(IDN.EQ.IDNR(I,2)) THEN
         TAB  = 'F'
         IRET = I
         GOTO 100
      ENDIF
      ENDDO

C  LOOK FOR IDN IN TABLE D
C  -----------------------

      DO I=1,NTBD(LUN)
      IF(IDN.EQ.IDND(I,LUN)) THEN
         NEMO = TABD(I,LUN)(7:14)
         TAB  = 'D'
         IRET = I
         GOTO 100
      ENDIF
      ENDDO

C  LOOK FOR IDN IN TABLE B
C  -----------------------

      DO I=1,NTBB(LUN)
      IF(IDN.EQ.IDNB(I,LUN)) THEN
         NEMO = TABB(I,LUN)(7:14)
         TAB  = 'B'
         IRET = I
         GOTO 100
      ENDIF
      ENDDO

C  LOOK FOR IDN IN TABLE C
C  -----------------------

      CID = ADN30(IDN,6)
      CID = CID(1:3)
      IF(CID.EQ.'201' .OR. CID.EQ.'202' .OR. CID.EQ.'206') THEN
         NEMO = ADN30(IDN,6)
         TAB  = 'C'
         IRET = MOD(IDN,10)
         GOTO 100
      ENDIF

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE NUMTBD(LUN,IDN,NEMO,TAB,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    NUMTBD
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2002-05-14
C
C ABSTRACT: THIS SUBROUTINE SEARCHES FOR AN INTEGER IDN, CONTAINING THE
C   BIT-WISE REPRESENTATION OF A DESCRIPTOR (FXY) VALUE, WITHIN THE
C   INTERNAL BUFR TABLE D AND B ARRAYS IN COMMON BLOCK /TABABD/.  IF
C   FOUND, IT RETURNS THE CORRESPONDING MNEMONIC AND OTHER INFORMATION
C   FROM WITHIN THESE ARRAYS.  IF IDN IS NOT FOUND, IT RETURNS WITH
C   IRET=0.  THIS SUBROUTINE IS IDENTICAL TO BUFR ARCHIVE LIBRARY
C   SUBROUTINE NUMTAB EXCEPT NUMTAB ALSO SEARCHS FOR IDN WITHIN
C   INTERNAL BUFR REPLICATION ARRAYS AND BUFR TABLE C.
C
C PROGRAM HISTORY LOG:
C 2002-05-14  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    CALL NUMTBD (LUN, IDN, NEMO, TAB, IRET)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     IDN      - INTEGER: BIT-WISE REPRESENTATION OF DESCRIPTOR (FXY)
C                VALUE
C
C   OUTPUT ARGUMENT LIST:
C     NEMO     - CHARACTER*(*): MNEMONIC CORRESPONDING TO IDN
C     TAB      - CHARACTER*1: TYPE OF FXY VALUE THAT IS BIT-WISE
C                REPRESENTED BY IDN:
C                     'B' = BUFR Table B descriptor
C                     'D' = BUFR Table D descriptor
C     IRET     - INTEGER: RETURN VALUE (SEE REMARKS)
C
C REMARKS:
C    THE INTERPRETATION OF THE RETURN VALUE IRET DEPENDS UPON THE
C    RETURN VALUE OF TAB, AS FOLLOWS:
C
C    IF ( TAB = 'B' ) THEN
C       IRET = positional index of IDN within internal BUFR Table B
C              array
C    ELSE IF ( TAB = 'D') THEN
C       IRET = positional index of IDN within internal BUFR Table D
C              array
C    ELSE IF ( IRET = 0 ) THEN
C       IDN was not found in internal BUFR Table B or D
C    END IF
C
C
C    THIS ROUTINE CALLS:        None
C    THIS ROUTINE IS CALLED BY: XMSGINI
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MAXTBA=50)
      PARAMETER (MAXTBB=250)
      PARAMETER (MAXTBD=250)

      COMMON /TABABD/ NTBA(0:NFILES),NTBB(0:NFILES),NTBD(0:NFILES),
     .                MTAB(MAXTBA,NFILES),IDNA(MAXTBA,NFILES,2),
     .                IDNB(MAXTBB,NFILES),IDND(MAXTBD,NFILES),
     .                TABA(MAXTBA,NFILES),TABB(MAXTBB,NFILES),
     .                TABD(MAXTBD,NFILES)

      CHARACTER*(*) NEMO
      CHARACTER*600 TABD
      CHARACTER*128 TABB
      CHARACTER*128 TABA
      CHARACTER*1   TAB

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      NEMO = ' '
      IRET = 0
      TAB = ' '

C  LOOK FOR IDN IN TABLE D
C  -----------------------

      DO I=1,NTBD(LUN)
      IF(IDN.EQ.IDND(I,LUN)) THEN
         NEMO = TABD(I,LUN)(7:14)
         TAB  = 'D'
         IRET = I
         GOTO 100
      ENDIF
      ENDDO

C  LOOK FOR IDN IN TABLE B
C  -----------------------

      DO I=1,NTBB(LUN)
      IF(IDN.EQ.IDNB(I,LUN)) THEN
         NEMO = TABB(I,LUN)(7:14)
         TAB  = 'B'
         IRET = I
         GOTO 100
      ENDIF
      ENDDO

C  EXIT
C  ----

100   RETURN
      END
      FUNCTION NVNWIN(NODE,LUN,INV1,INV2,INVN,NMAX)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    NVNWIN (docblock incomplete)
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION ....
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY) (INCOMPLETE); OUTPUTS MORE
C                           COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY OR UNUSUAL THINGS
C                           HAPPEN
C
C USAGE:    NVNWIN (NODE, LUN, INV1, INV2, INVN, NMAX)
C   INPUT ARGUMENT LIST:
C     NODE     - INTEGER: ....
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     INV1     - INTEGER: ....
C     INV2     - INTEGER: ....
C     NMAX     - INTEGER: LENGTH OF INVN
C
C   OUTPUT ARGUMENT LIST:
C     INVN     - INTEGER: NMAX-WORD ARRAY ....
C     NVNWIN   - INTEGER: ....
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT
C    THIS ROUTINE IS CALLED BY: UFBEVN
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /QUIET / IPRT

      CHARACTER*128 BORT_STR
      DIMENSION     INVN(NMAX)
      REAL*8        VAL,BMISS

      DATA BMISS/10E10/

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      IF(NODE.EQ.0) THEN
         IF(IPRT.GE.1) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
         PRINT*, 'BUFRLIB: NVNWIN - NODE=0, IMMEDIATE RETURN'
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
         GOTO 100
      ENDIF

c  .... DK: Shouldn't this be before RETURN above?
      NVNWIN = 0

      DO I=1,NMAX
      INVN(I) = BMISS
      ENDDO

C  SEARCH BETWEEN INV1 AND INV2
C  ----------------------------

      DO N=INV1,INV2
      IF(INV(N,LUN).EQ.NODE) THEN
         NVNWIN = NVNWIN+1
         INVN(NVNWIN) = N
      ENDIF
      ENDDO

c  .... DK: Shouldn't this check be moved into do loop above to
c            prevent array overflow in INVN ????
      IF(NVNWIN.GT.NMAX) GOTO 900

C  EXITS
C  -----

100   RETURN
900   WRITE(BORT_STR,'("BUFRLIB: NVNWIN - THE NUMBER OF EVENTS, '//
     . 'NVNWIN (",I5,") EXCEEDS THE LIMIT, NMAX (",I5,")")') NVNWIN,NMAX
      CALL BORT(BORT_STR)
      END
      FUNCTION NWORDS(N,LUN)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    NWORDS (docblock incomplete)
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1996-10-09
C
C ABSTRACT: THIS FUNCTION ....
C
C PROGRAM HISTORY LOG:
C 1996-10-09  J. WOOLLEN -- ORIGINAL AUTHOR
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY) (INCOMPLETE)
C
C USAGE:    NWORDS (N, LUN)
C   INPUT ARGUMENT LIST:
C     N        - INTEGER: BYTE COUNT INDEX FOR BUFR MESSAGE
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C
C   OUTPUT ARGUMENT LIST:
C     NWORDS   - INTEGER: ....
C
C REMARKS:
C    THIS ROUTINE CALLS:        None
C    THIS ROUTINE IS CALLED BY: INVMRG
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)

      REAL*8 VAL

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      NWORDS = 0

      DO K=1,NINT(VAL(N,LUN))
      NWORDS = NWORDS + NINT(VAL(NWORDS+N+1,LUN))
      ENDDO

      RETURN
      END
      SUBROUTINE NXTWIN(LUN,IWIN,JWIN)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    NXTWIN (docblock incomplete)
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE ....
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2002-05-14  J. WOOLLEN -- REMOVED OLD CRAY COMPILER DIRECTIVES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY) (INCOMPLETE); OUTPUTS MORE
C                           COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL NXTWIN (LUN, IWIN, JWIN)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     IWIN     - INTEGER: ....
C     JWIN     - INTEGER: ....
C
C   OUTPUT ARGUMENT LIST:
C     IWIN     - INTEGER: ....
C     JWIN     - INTEGER: ....
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     LSTRPC
C    THIS ROUTINE IS CALLED BY: CONWIN   UFBEVN   UFBIN3   UFBRW
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)

      CHARACTER*128 BORT_STR
      REAL*8        VAL

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      IF(JWIN.EQ.NVAL(LUN)) THEN
         IWIN = 0
         GOTO 100
      ENDIF

C  FIND THE NEXT SEQUENTIAL WINDOW
C  -------------------------------

      NODE = INV(IWIN,LUN)
      IF(LSTRPC(NODE,LUN).NE.NODE) GOTO 900
      IF(VAL(JWIN,LUN).EQ.0) THEN
         IWIN = 0
      ELSE
         IWIN = JWIN
         JWIN = IWIN+VAL(IWIN,LUN)
      ENDIF

C  EXITS
C  -----

100   RETURN
900   WRITE(BORT_STR,'("BUFRLIB: NXTWIN - LISTRPC FOR NODE",I6," '//
     . '(LISTRPC=",I5,") DOES NOT EQUAL VALUE OF NODE, NOT RPC (IWIN '//
     . '=",I8,")")') NODE,LSTRPC(NODE,LUN),IWIN
      CALL BORT(BORT_STR)
      END
      SUBROUTINE OPENBF(LUNIT,IO,LUNDX)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    OPENBF
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THE FIRST, AND ONLY, TIME THIS SUBROUTINE IS CALLED, IT
C   FIGURES OUT SOME IMPORTANT INFORMATION ABOUT THE LOCAL MACHINE ON
C   WHICH THE BUFR ARCHIVE LIBRARY SOFTWARE IS BEING RUN (VIA A CALL TO
C   BUFR ARCHIVE LIBRARY SUBROUTINE WRDLEN) AND IT INITIALIZES ARRAYS
C   IN MANY BUFR ARCHIVE LIBRARY COMMON BLOCKS (VIA A CALL TO BUFR
C   ARCHIVE LIBRARY SUBROUTINE BFRINI).  EVERY TIME IS IS CALLED,
C   OPENBF THEN NORMALLY (WHEN INPUT ARGUMENT IO IS NOT 'QUIET')
C   IDENTIFIES A NEW LOGICAL UNIT TO THE BUFR ARCHIVE LIBRARY SOFTWARE
C   FOR INPUT OR OUTPUT OPERATIONS.  UP TO 32 SUCH LOGICAL UNITS CAN BE
C   CONNECTED TO THE SOFTWARE AT ANY ONE TIME.  IF IO IS PASSED IN AS
C   'QUIET', OPENBF PERFORMS ONLY ONE FUNCTION - IT SIMPLY SETS THE
C   "DEGREE OF PRINTOUT" SWITCH IPRT (IN COMMON BLOCK /QUIET/) TO THE
C   VALUE OF INPUT ARGUMENT LUNDX, OVERRIDING ITS PREVIOUS VALUE
C   {EITHER THE INITIALIZED VALUE OF ZERO (FOR LIMITED PRINTOUT) SET IN
C   THE FIRST CALL TO THIS ROUTINE, OR THE VALUE SET FROM A PREVIOUS
C   CALL TO OPENBF WITH IO = 'QUIET'}.  OPENBF THEN RETURNS WITHOUT
C   OPENING ANY FILES.  THE DEGREE OF PRINTOUT INCREASES AS IPRT
C   INCREASES FROM "-1" TO "0" TO "1" TO "2".
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  J. ATOR    -- ADDED IO='NUL' OPTION IN ORDER TO PREVENT
C                           LATER WRITING TO BUFR FILE IN LUNIT (WAS IN
C                           DECODER VERSION); ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY, UNUSUAL THINGS HAPPEN OR FOR
C                           INFORMATIONAL PURPOSES
C
C USAGE:    CALL OPENBF (LUNIT, IO, LUNDX)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C                (UNLESS IO IS 'QUIET', THEN A DUMMY)
C     IO       - CHARACTER*(*): FLAG INDICATING HOW LUNIT IS TO BE
C                USED BY THE SOFTWARE:
C                    'IN' = input operations
C                   'OUT' = output operations
C                   'APN' = same as 'OUT', except begin writing at end
C                           of file ("append")
C                   'APX' = same as 'APN', except backspace before
C                           appending
C                   'NUL' = same as 'OUT', except don't actually write
C                           to LUNIT (for use with subroutine WRITSA)
C                 'QUIET' = LUNIT is ignored, this is an indicator
C                           that the value for IPRT in COMMON block
C                           /QUIET/ is being reset (see LUNDX)
C     LUNDX    - INTEGER: IF IO IS NOT 'QUIET':
C                            FORTRAN logical unit number containing 
C                            dictionary table information to be used in
C                            reading/writing from/to LUNIT (depending
C                            on the case); may be set equal to LUNIT if
C                            dictionary table information is already
C                            embedded in LUNIT
C                         IF IO IS 'QUIET':
C                            Indicator for degree of printout:
C                              -1 = NO printout except for ABORT
C                                   messages
C                               0 = LIMITED printout (default)
C                               1 = ALL warning messages are printed
C                                   out
C                               2 = ALL warning AND informational
C                                   messages are printed out
C                            (Note: this does not change until OPENBF
C                                   is again called with IO equal to
C                                   'QUIET')
C
C   INPUT FILES:
C     UNIT "LUNIT" - BUFR FILE
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        BFRINI   BORT     DXINIT   POSAPN
C                               POSAPX   READDX   STATUS   UPC
C                               WRDLEN   WRITDX   WTSTAT
C    THIS ROUTINE IS CALLED BY: RDMGSB   UFBINX   UFBMEM   UFBTAB
C                               Also called by application programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /STBFR / IOLUN(NFILES),IOMSG(NFILES)
      COMMON /NULBFR/ NULL(NFILES)
      COMMON /QUIET / IPRT

      CHARACTER*(*) IO
      CHARACTER*128 BORT_STR
      CHARACTER*54  CPRINT(0:3)
      CHARACTER*4   BUFR
      LOGICAL       SKIPDX,APPEND

      DATA IFIRST/0/
      DATA          CPRINT/
     . 'No printout except for ABORT messages',
     . 'Limited printout (default)',
     . 'All warning messages are printed out',
     . 'All warning and informational messages are printed out'/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C     If this is the first call to this subroutine, initialize
C     IPRT in /OUIET/ as 0 (limited printout - except for abort
C     messages)

      IF(IFIRST.EQ.0) IPRT = 0

      IF(IO.EQ.'QUIET') THEN
c  .... override previous IPRT value (printout indicator)
         IF(LUNDX.LT.-1)  LUNDX = -1
         IF(LUNDX.GT. 2)  LUNDX =  2
         IF(LUNDX.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT 101, IPRT,CPRINT(IPRT+1),LUNDX,CPRINT(LUNDX+1)
101   FORMAT(' BUFRLIB: OPENBF - THE DEGREE OF PRINTOUT INDICATOR IS ',
     . 'BEING CHANGED FROM:'/15X,I3,' - ',A/25X,'to'/15X,I3,' - ',A)
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT*
         ENDIF
         IPRT = LUNDX
      ENDIF

      IF(IFIRST.EQ.0) THEN

C     If this is the first call to this subroutine, then call BUFR
C     Archive Library subroutine WRDLEN to initialize some important
C     information about the local machine, and call library routine
C     BFRINI to initialize some important variables.  Must be called
C     in this order!

         CALL WRDLEN
         CALL BFRINI
         IFIRST = 1
      ENDIF

      IF(IO.EQ.'QUIET') GOTO 100

C  SEE IF A FILE CAN BE OPENED
C  ---------------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(LUN.EQ.0) GOTO 900
      IF(IL .NE.0) GOTO 901
      NULL(LUN) = 0

C  CHECK FOR NO BUFR DATA OR NO DATA AT ALL IN AN "IN" FILE
C  --------------------------------------------------------

C  Note that we only want to do this check if LUNIT=LUNDX, in order
C  to allow for the possibility that input BUFR messages may be passed
C  to the BUFR ARCHIVE LIBRARY software via an alternative method (e.g.
C  a future call to subroutine READERME) rather than read directly from
C  LUNIT, which is the usual method.

      IF(IO.EQ.'IN' .AND. LUNIT.EQ.LUNDX) THEN
         REWIND LUNIT
         READ(LUNIT,END=200,ERR=902) MSTR

C        Note that we need to pass MSTR through subroutine UPC before
C        comparing the first 4 bytes of it to the string 'BUFR' because
C        the native machine might be EBCDIC rather than ASCII; in this
C        case MSTR, which contains the first 4 bytes of the first BUFR
C        message in LUNIT (and which thus must always be CCITT IA5
C        (i.e. ASCII) by definition, regardless of the native machine),
C        will be converted to EBCDIC, and thus the subsequent
C        comparison with the string 'BUFR' will always be valid.


         IBIT = 0
         CALL UPC(BUFR,4,MSTR,IBIT)
         IF(BUFR.NE.'BUFR') GOTO 903
      ENDIF

C  SET INITIAL OPEN DEFAULTS (CLEAR OUT A MSG CONTROL WORD PARTITION)
C  ------------------------------------------------------------------

      IF(IO.NE.'NUL') THEN
        REWIND LUNIT
      ENDIF
      NMSG (LUN) = 0
      NSUB (LUN) = 0
      MSUB (LUN) = 0
      INODE(LUN) = 0
      IDATE(LUN) = 0
      SKIPDX = .FALSE.
      APPEND = .FALSE.

C  DECIDE HOW TO SETUP THE DICTIONARY
C  ----------------------------------

      IF(IO.EQ.'IN') THEN
         CALL WTSTAT(LUNIT,LUN,-1,0)
         CALL READDX(LUNIT,LUN,LUNDX)
      ELSE IF(IO.EQ.'OUT') THEN
         CALL WTSTAT(LUNIT,LUN, 1,0)
         CALL WRITDX(LUNIT,LUN,LUNDX)
      ELSE IF(IO.EQ.'NUL') THEN
         CALL WTSTAT(LUNIT,LUN, 1,0)
         CALL READDX(LUNIT,LUN,LUNDX)
         NULL(LUN) = 1
      ELSE IF(IO.EQ.'APN' .OR. IO.EQ.'APX') THEN
         CALL WTSTAT(LUNIT,LUN, 1,0)
         CALL READDX(LUNIT,LUN,LUNDX)
         IF(IO.EQ.'APN') CALL POSAPN(LUNIT)
         IF(IO.EQ.'APX') CALL POSAPX(LUNIT)
      ELSE
         GOTO 904
      ENDIF

      GOTO 100

C  FILE OPENED FOR INPUT IS EMPTY - LET READMG (OR SIMILAR MESSAGE
C  READERS IN THE BUFR ARCHIVE LIBRARY) GIVE THE BAD NEWS LATER
C  ---------------------------------------------------------------

200   REWIND LUNIT
      IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*, 'BUFRLIB: OPENBF - INPUT BUFR FILE IN UNIT ',LUNIT,
     . ' IS EMPTY'
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
      ENDIF
      CALL WTSTAT(LUNIT,LUN,-1,0)

C  INITIALIZE THE DICTIONARY TABLE PARTITION
C  -----------------------------------------

      CALL DXINIT(LUN,0)

C  EXITS
C  -----

100   RETURN
900   WRITE(BORT_STR,'("BUFRLIB: OPENBF - THERE ARE ALREADY",I3,'//
     . '" BUFR FILES OPENED, CANNOT OPEN FILE CONNECTED TO UNIT",I4)')
     . NFILES,LUNIT
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: OPENBF - THE FILE CONNECTED TO UNIT"'//
     . ',I5," IS ALREADY OPEN")') LUNIT
      CALL BORT(BORT_STR)
902   WRITE(BORT_STR,'("BUFRLIB: OPENBF - ERROR READING INPUT FILE '//
     . 'CONNECTED TO UNIT",I4," WHEN CHECKING FOR ''BUFR'' IN FIRST 4'//
     . ' BYTES OF RECORD")') LUNIT
      CALL BORT(BORT_STR)
903   WRITE(BORT_STR,'("BUFRLIB: OPENBF - FIRST 4 BYTES READ FROM '//
     . 'RECORD IN INPUT FILE CONNECTED TO UNIT",I4," NOT ''BUFR'', '//
     . 'DOES NOT CONTAIN BUFR DATA")') LUNIT
      CALL BORT(BORT_STR)
904   CALL BORT('BUFRLIB: OPENBF - SECOND (INPUT) ARGUMENT IS NOT ONE'//
     . ' OF THE FOLLOWING: "IN", "OUT", "NUL", "APN", "APX" OR "QUIET"')
      END
      SUBROUTINE OPENBT(LUNDX,MTYP)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    OPENBT
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1998-07-08
C
C ABSTRACT: THIS IS A DUMMY SUBROUTINE WHICH ALWAYS RETURNS LUNDX = 0.
C   OPENBT MUST BE PRESENT BECAUSE IT IS CALLED BY BUFR ARCHIVE LIBRARY
C   SUBROUTINE CKTABA AS A LAST RESORT TO TRY AND FIND AN EXTERNAL
C   USER-SUPPLIED BUFR DICTIONARY TABLE FILE IN CHARACTER FORMAT FROM
C   WHICH A TABLE A MNEMONIC CAN BE LOCATED.  IF THE APPLICATION
C   PROGRAM DOES NOT HAVE AN IN-LINE VERSION OF OPENBT (OVERRIDING THIS
C   ONE), THEN THE RETURNED LUNDX = 0 WILL RESULT IN CKTABA RETURNING
C   WITHOUT FINDING A TABLE A MNEMONIC BECAUSE THERE IS NO LINK TO ANY
C   EXTERNAL BUFR TABLES.  NORMALLY, IT IS EXPECTED THAT AN IN-LINE
C   VERSION OF THIS SUBROUTINE WILL ACTUALLY FIND THE APPROPRIATE
C   EXTERNAL BUFR TABLE.
C
C PROGRAM HISTORY LOG:
C 1998-07-08  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); ADDED
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN UNUSUAL
C                           THINGS HAPPEN
C
C USAGE:    CALL OPENBT (LUNDX, MTYP)
C   INPUT ARGUMENT LIST:
C     MTYP     - INTEGER: DUMMY {IN AN APPLICATION PROGRAM (IN-LINE)
C                THIS WOULD BE THE BUFR MESSAGE TYPE}
C
C   OUTPUT ARGUMENT LIST:
C     LUNDX    - INTEGER: DUMMY, ALWAYS RETURNED AS ZERO {IN AN
C                APPLICATION PROGRAM (IN-LINE) THIS WOULD BE THE
C                FORTRAN LOGICAL UNIT NUMBER CONNECTED TO THE FILE
C                CONTAINING THE EXTERNAL BUFR TABLE}
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        None
C    THIS ROUTINE (IN BUFR
C    ARCHIVE LIBRARY):          Called by CKTABA only to allow the
C                               BUFR ARCHIVE LIBRARY to compile, CKTABA
C                               and any application programs should
C                               always call a version of OPENBT in-line
C                               in the application program.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /QUIET / IPRT

      IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*, 'BUFRLIB: OPENBT - THIS IS A DUMMY BUFRLIB ROUTINE ',
     . 'CALLED BY CKTABA OR APPL. PGM; OPENBT SHOULD BE INCL. IN-LINE ',
     . 'IN APPL. PGM'
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
      ENDIF
      LUNDX = 0
      RETURN
      END
      SUBROUTINE OPENMB(LUNIT,SUBSET,JDATE)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    OPENMB
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE OPENS AND INITIALIZES A NEW BUFR MESSAGE
C   WITHIN MEMORY.  IT SHOULD ONLY BE CALLED WHEN LOGICAL UNIT LUNIT
C   HAS BEEN OPENED FOR OUTPUT OPERATIONS.  IT IS SIMILAR TO BUFR
C   ARCHIVE LIBRARY SUBROUTINE OPENMG, HOWEVER UNLIKE OPENMG, IT WILL
C   NOT OPEN A NEW MESSAGE IF THERE IS ALREADY A BUFR MESSAGE OPEN
C   WITHIN MEMORY FOR THIS LUNIT WHICH HAS THE SAME SUBSET AND JDATE
C   VALUES (IN WHICH CASE IT DOES NOTHING AND RETURNS TO THE CALLING
C   ROUTINE/PROGRAM).  OTHERWISE, IF THERE IS ALREADY A BUFR MESSAGE
C   OPEN WITHIN MEMORY FOR THIS LUNIT BUT WHICH HAS A DIFFERENT SUBSET
C   OR JDATE VALUE, THEN THAT MESSAGE WILL BE CLOSED AND FLUSHED TO
C   LUNIT BEFORE OPENING THE NEW ONE.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"; MODIFIED TO MAKE Y2K
C                           COMPLIANT
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL OPENMB (LUNIT, SUBSET, JDATE)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     SUBSET   - CHARACTER*(*): TABLE A MNEMONIC FOR TYPE OF BUFR MESSAGE
C                BEING OPENED
C     JDATE    - INTEGER: DATE-TIME STORED WITHIN SECTION 1 OF BUFR
C                MESSAGE BEING OPENED, IN FORMAT OF EITHER YYMMDDHH OR
C                YYYYMMDDHH, DEPENDING ON DATELEN() VALUE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     CLOSMG   I4DY     MSGINI
C                               NEMTBA   STATUS   USRTPL   WTSTAT
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)

      CHARACTER*(*) SUBSET
      LOGICAL       OPEN

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  CHECK THE FILE STATUS
C  ---------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.LT.0) GOTO 901

C  GET SOME SUBSET PARTICULARS
C  ---------------------------

c  .... Given SUBSET, returns MTYP,MSTB,INOD
      CALL NEMTBA(LUN,SUBSET,MTYP,MSTB,INOD)
      OPEN = IM.EQ.0.OR.INOD.NE.INODE(LUN).OR.I4DY(JDATE).NE.IDATE(LUN)

C  MAYBE(?) OPEN A NEW OR DIFFERENT TYPE OF MESSAGE
C  ------------------------------------------------

      IF(OPEN) THEN
         CALL CLOSMG(LUNIT)
         CALL WTSTAT(LUNIT,LUN,IL, 1)
c  .... Set pos. index for new Tbl A mnem.
         INODE(LUN) = INOD
c  .... Set date for new message
         IDATE(LUN) = I4DY(JDATE)

C  INITIALIZE THE OPEN MESSAGE
C  ---------------------------

         CALL MSGINI(LUN)
         CALL USRTPL(LUN,1,1)
      ENDIF

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: OPENMB - OUTPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR OUTPUT')
901   CALL BORT('BUFRLIB: OPENMB - OUTPUT BUFR FILE IS OPEN FOR '//
     . 'INPUT, IT MUST BE OPEN FOR OUTPUT')
      END
      SUBROUTINE OPENMG(LUNIT,SUBSET,JDATE)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    OPENMG
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE OPENS AND INITIALIZES A NEW BUFR MESSAGE
C   WITHIN MEMORY.  IT SHOULD ONLY BE CALLED WHEN LOGICAL UNIT LUNIT
C   HAS BEEN OPENED FOR OUTPUT OPERATIONS.  IT IS SIMILAR TO BUFR
C   ARCHIVE LIBRARY SUBROUTINE OPENMB, HOWEVER UNLIKE OPENMB, IT WILL
C   ALWAYS OPEN A NEW MESSAGE REGARDLESS OF THE VALUES OF SUBSET AND
C   JDATE.  IF THERE IS ALREADY A BUFR MESSAGE OPEN WITHIN MEMORY FOR
C   THIS LUNIT, THEN THAT MESSAGE WILL BE CLOSED AND FLUSHED TO LUNIT
C   BEFORE OPENING THE NEW ONE.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"; MODIFIED TO MAKE Y2K
C                           COMPLIANT
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL OPENMG (LUNIT, SUBSET, JDATE)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     SUBSET   - CHARACTER*(*): TABLE A MNEMONIC FOR TYPE OF BUFR MESSAGE
C                BEING OPENED
C     JDATE    - INTEGER: DATE-TIME STORED WITHIN SECTION 1 OF BUFR
C                MESSAGE BEING OPENED, IN FORMAT OF EITHER YYMMDDHH OR
C                YYYYMMDDHH, DEPENDING ON DATELEN() VALUE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     CLOSMG   I4DY     MSGINI
C                               NEMTBA   STATUS   USRTPL   WTSTAT
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)

      CHARACTER*(*) SUBSET

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  CHECK THE FILE STATUS
C  ---------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.LT.0) GOTO 901
      IF(IM.NE.0) CALL CLOSMG(LUNIT)
      CALL WTSTAT(LUNIT,LUN,IL, 1)

C  GET SOME SUBSET PARTICULARS
C  ---------------------------

c  .... Given SUBSET, returns MTYP,MSTB,INOD
      CALL NEMTBA(LUN,SUBSET,MTYP,MSTB,INOD)
c  .... Set pos. index for new Tbl A mnem.
      INODE(LUN) = INOD
c  .... Set date for new message
      IDATE(LUN) = I4DY(JDATE)

C  INITIALIZE THE OPEN MESSAGE
C  ---------------------------

      CALL MSGINI(LUN)
      CALL USRTPL(LUN,1,1)

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: OPENMG - OUTPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR OUTPUT')
901   CALL BORT('BUFRLIB: OPENMG - OUTPUT BUFR FILE IS OPEN FOR '//
     . 'INPUT, IT MUST BE OPEN FOR OUTPUT')
      END
      SUBROUTINE OVRBS1(NVAL,MBAY,NBYT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    OVRBS1
C   PRGMMR: KEYSER           ORG: NP22       DATE: 2003-11-04
C
C ABSTRACT: THIS SUBROUTINE PACKS AND STORES THE VALUE OF THE BINARY
C   INTEGER WORD NVAL INTO BYTE NBYT OF SECTION 1 OF A BUFR MESSAGE
C   STORED IN ARRAY MBAY, OVERWRITING THE VALUE PREVIOUSLY STORED
C   THERE.  THE START OF THE BUFR MESSAGE (I.E. THE STRING "BUFR") MUST
C   BE ALIGNED ON THE FIRST FOUR BYTES OF MBAY.
C
C PROGRAM HISTORY LOG:
C 2003-11-04  D. KEYSER  -- ORIGINAL AUTHOR
C
C USAGE:    CALL OVRBS1 (NVAL, MBAY, NBYT)
C   INPUT ARGUMENT LIST:
C     NVAL     - INTEGER: INTEGER WORD TO BE PACKED
C     NBYT     - INTEGER: BYTE WITHIN SECTION 1 OF BUFR TO OVERWRITE
C
C   OUTPUT ARGUMENT LIST:
C     MBAY     - INTEGER: *-WORD PACKED BINARY ARRAY CONTAINING BUFR
C                MESSAGE WITH NVAL NOW PACKED IN BYTE NBYT OF SECTION 1
C
C REMARKS:
C    THIS ROUTINE CALLS:        PKB      WRDLEN
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      DIMENSION MBAY(*)

      DATA IFIRST / 0 /

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C     If this is the first call to this subroutine, then call subroutine
C     WRDLEN to initialize some important information about the local
C     machine, just in case subroutine OPENBF hasn't been called yet.

      IF ( IFIRST .EQ. 0 ) THEN
         CALL WRDLEN
         IFIRST = 1
      ENDIF

C     Note that there are 8 bytes within Section 0 that must be skipped.

      NBIT=8*(8+(NBYT-1))
      CALL PKB(NVAL,8,MBAY,NBIT)

      RETURN
      END
      SUBROUTINE PAD(IBAY,IBIT,IBYT,IPADB)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    PAD
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE FIRST PACKS THE VALUE FOR THE NUMBER OF
C   BITS BEING "PADDED" (WE'LL GET TO THAT LATER), STARTING WITH BIT
C   IBIT+1 AND USING EIGHT BITS IN THE PACKED ARRAY IBAY (WHICH
C   REPRESENTS A SUBSET PACKED INTO IBIT BITS).  THEN, STARTING WITH
C   IBIT+9, IT PACKS ZEROES (I.E., "PADS") TO THE SPECIFIED BIT
C   BOUNDARY (IPADB).  (NOTE: IT'S THE NUMBER OF BITS PADDED HERE THAT
C   WAS PACKED IN BITS IBIT+1 THROUGH IBIT+8 - THIS IS ACTUALLY A
C   DELAYED REPLICATION FACTOR).  IPADB MUST BE A MULTIPLE OF EIGHT AND
C   REPRESENTS THE BIT BOUNDARY ON WHICH THE PACKED SUBSET IN IBAY
C   SHOULD END AFTER PADDING.  FOR EXAMPLE, IF IPABD IS "8", THEN THE
C   NUMBER OF BITS IN IBAY ACTUALLY CONSUMED BY PACKED DATA (INCLUDING
C   THE PADDING) WILL BE A MULTIPLE OF EIGHT.  IF IPADB IS "16", IT
C   WILL BE A MULTIPLE OF SIXTEEN.  IN EITHER (OR ANY) CASE, THIS
C   ENSURES THAT THE PACKED SUBSET WILL ALWAYS END ON A FULL BYTE
C   BOUNDARY.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL PAD (IBAY, IBIT, IBYT, IPADB)
C   INPUT ARGUMENT LIST:
C     IBAY     - INTEGER: *-WORD PACKED BINARY ARRAY NOT YET PADDED
C     IBIT     - INTEGER: BIT POINTER WITHIN IBAY TO START PADDING FROM
C     IPADB    - INTEGER: BIT BOUNDARY TO PAD TO (MUST BE A MULTIPLE OF
C                8)
C
C   OUTPUT ARGUMENT LIST:
C     IBAY     - INTEGER: *-WORD PACKED BINARY ARRAY NOW PADDED
C     IBIT     - INTEGER: NUMBER OF BITS WITHIN IBAY CONTAINING PACKED
C                DATA (INCLUDING PADDING, MUST BE A MULTIPLE OF 8)
C     IBYT     - INTEGER: NUMBER OF BYTES WITHIN IBAY CONTAINING PACKED
C                DATA (INCLUDING PADDING) (I.E., IBIT/8)
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     PKB
C    THIS ROUTINE IS CALLED BY: MSGUPD
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*128 BORT_STR
      DIMENSION     IBAY(*)

C----------------------------------------------------------------------
C----------------------------------------------------------------------

C  PAD THE SUBSET TO AN IPADB BIT BOUNDARY
C  ----------------------------------------

      IPAD = IPADB - MOD(IBIT+8,IPADB)
c  .... First pack the # of bits being padded this is a delayed
c       replication factor
      CALL PKB(IPAD,8,IBAY,IBIT)
c  .... Now pad with zeroes to the bit bdry
      CALL PKB(0,IPAD,IBAY,IBIT)
      IBYT = IBIT/8

      IF(MOD(IBIT,IPADB).NE.0) GOTO 900
      IF(MOD(IBIT,8    ).NE.0) GOTO 901

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: PAD - THE INPUT BIT BOUNDARY TO PAD '//
     . 'TO (",I8,") IS NOT A MULTIPLE OF 8")') IPADB
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: PAD - THE NUMBER OF BITS IN A PACKED'//
     . ' SUBSET AFTER PADDING (",I8,") IS NOT A MULTIPLE OF 8")') IBIT
      CALL BORT(BORT_STR)
      END
      SUBROUTINE PARSEQ(STR,TAGS,MTAG,NTAG)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    PARSEQ
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE PARSES A STRING CONTAINING ONE OR MORE
C   MNEMONICS INTO AN ARRAY OF MNEMONICS.  THE MNEMONICS WITHIN THE
C   STRING MUST BE SEPARATED BY ONE OR MORE BLANK CHARACTERS.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY; CHANGED CALL FROM BORT TO BORT2
C
C USAGE:    CALL PARSEQ (STR, TAGS, MTAG, NTAG)
C   INPUT ARGUMENT LIST:
C     STR      - CHARACTER*(*): STRING
C     MTAG     - INTEGER: MAXIMUM NUMBER OF MNEMONICS TO BE PARSED
C                FROM STRING
C
C   OUTPUT ARGUMENT LIST:
C     TAGS     - CHARACTER*(*): MTAG-WORD ARRAY OF MNEMONICS (FIRST
C                NTAG WORDS FILLED)
C     NTAG     - INTEGER: NUMBER OF MNEMONICS RETURNED
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT2
C    THIS ROUTINE IS CALLED BY: PARUSR   READLC   SEQSDX   UFBSEQ
C                               UFBTAB   UFBTAM   WRITLC
C                               Normally not called by any application
C                               programs but it could be.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*(*) STR,TAGS(MTAG)
      CHARACTER*128 BORT_STR1,BORT_STR2
      CHARACTER*80  ASTR
      LOGICAL       WORD

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      ASTR = STR
      LSTR = LEN(STR)
      LTAG = LEN(TAGS(1))
      IF(LSTR.GT.80) GOTO 900
      NTAG = 0
      NCHR = 0
      WORD = .FALSE.

      DO I=1,LSTR

      IF(.NOT.WORD .AND. STR(I:I).NE.' ') THEN
         NTAG = NTAG+1
         IF(NTAG.GT.MTAG) GOTO 901
         TAGS(NTAG) = ' '
      ENDIF

      IF(WORD .AND. STR(I:I).EQ.' ') NCHR = 0
      WORD = STR(I:I).NE.' '

      IF(WORD) THEN
         NCHR = NCHR+1
         IF(NCHR.GT.LTAG) GOTO 902
         TAGS(NTAG)(NCHR:NCHR) = STR(I:I)
      ENDIF

      ENDDO

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR1,'("BUFRLIB: PARSEQ - INPUT STRING (",A,") HAS ")')
     . STR
      WRITE(BORT_STR2,'(18X,"LENGTH (",I4,"), > LIMIT OF 80 CHAR.")')
     . LSTR
      CALL BORT2(BORT_STR1,BORT_STR2)
901   WRITE(BORT_STR1,'("BUFRLIB: PARSEQ - INPUT STRING (",A,") '//
     . 'CONTAINS",I4)') STR,NTAG
      WRITE(BORT_STR2,'(18X,"MNEMONICS, THIS EXCEEDS THE LIMIT {",I4,'//
     . '" - THIRD (INPUT) ARGUMENT}")') MTAG
      CALL BORT2(BORT_STR1,BORT_STR2)
902   WRITE(BORT_STR1,'("BUFRLIB: PARSEQ - INPUT STRING (",A,") ")') STR
      WRITE(BORT_STR2,'(18X,"CONTAINS A PARSED MNEMONIC WITH LENGTH '//
     . 'EXCEEDING THE MAXIMIM OF",I4," CHARACTERS")') LTAG
      CALL BORT2(BORT_STR1,BORT_STR2)
      END
      SUBROUTINE PARUSR(STR,LUN,I1,IO)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    PARUSR
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE INITATES THE PROCESS TO PARSE OUT MNEMONICS
C   (NODES) FROM A USER-SPECIFIED CHARACTER STRING, AND SEPARATES THEM
C   INTO STORE AND CONDITION NODES.  INFORMATION ABOUT THE STRING
C   "PIECES" (I.E., THE MNEMONICS) IS STORED IN ARRAYS IN COMMON BLOCK
C   /USRSTR/.  CONDITION NODES ARE SORTED IN THE ORDER EXPECTED IN THE
C   INTERNAL JUMP/LINK TABLES AND SEVERAL CHECKS ARE PERFORMED ON THE
C   NODES.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"; IMPROVED MACHINE
C                           PORTABILITY
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY; CHANGED CALL FROM
C                           BORT TO BORT2; RESPONDED TO CHANGE IN
C                           PARUTG (WHICH THIS ROUTINE CALLS) TO NO
C                           LONGER EXPECT AN ALTERNATE RETURN TO A
C                           STATEMENT NUMBER IN THIS ROUTINE WHICH
C                           CALLED BORT (BORT IS NOW CALLED IN PARUTG)
C
C USAGE:    CALL PARUSR (STR, LUN, I1, IO)
C   INPUT ARGUMENT LIST:
C     STR      - CHARACTER*(*): STRING OF BLANK-SEPARATED MNEMONICS
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     I1       - INTEGER: A NUMBER GREATER THAN OR EQUAL TO THE NUMBER
C                OF BLANK-SEPARATED MNEMONICS IN STR
C     IO       - INTEGER: STATUS INDICATOR FOR BUFR FILE ASSOCIATED
C                WITH LUN:
C                       0 = input file
C                       1 = output file
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT2    LSTRPC   PARSEQ   PARUTG
C    THIS ROUTINE IS CALLED BY: STRING
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /USRSTR/ NNOD,NCON,NODS(20),NODC(10),IVLS(10),KONS(10)
      COMMON /ACMODE/ IAC

      CHARACTER*(*) STR
      CHARACTER*128 BORT_STR1,BORT_STR2
      CHARACTER*80  UST
      CHARACTER*20  UTG(30)
      LOGICAL       BUMP

      DATA MAXUSR /30/
      DATA MAXNOD /20/
      DATA MAXCON /10/

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      UST  = STR
      IF(LEN(STR).GT.80) GOTO 900

      NCON = 0
      NNOD = 0

C  PARSE OUT STRING PIECES(S) (UTG's or MNEMONICS)
C  -----------------------------------------------

      CALL PARSEQ(UST,UTG,MAXUSR,NTOT)

      DO N=1,NTOT

C  DETERMINE IF THIS UTG IS A CONDITION NODE OR A STORE NODE
C  ---------------------------------------------------------

      CALL PARUTG(LUN,IO,UTG(N),NOD,KON,VAL)
      IF(KON.NE.0) THEN
c  .... it is a condition node
         NCON = NCON+1
         IF(NCON.GT.MAXCON) GOTO 901
         NODC(NCON) = NOD
         KONS(NCON) = KON
         IVLS(NCON) = NINT(VAL)
      ELSE
c  .... it is a store node
         NNOD = NNOD+1
         IF(NNOD.GT.MAXNOD) GOTO 902
         NODS(NNOD) = NOD
      ENDIF
      ENDDO

C  SORT CONDITION NODES IN JUMP/LINK TABLE ORDER
C  ---------------------------------------------

      DO I=1,NCON
      DO J=I+1,NCON
      IF(NODC(I).GT.NODC(J)) THEN
         NOD     = NODC(I)
         NODC(I) = NODC(J)
         NODC(J) = NOD

         KON     = KONS(I)
         KONS(I) = KONS(J)
         KONS(J) = KON

         VAL     = IVLS(I)
         IVLS(I) = IVLS(J)
         IVLS(J) = VAL
      ENDIF
      ENDDO
      ENDDO

C  CHECK ON SPECIAL RULES FOR CONDITIONAL NODES THAT ARE BUMP NODES
C  ----------------------------------------------------------------

      BUMP = .FALSE.

      DO N=1,NCON
      IF(KONS(N).EQ.5) THEN
         IF(IO.EQ.0)   GOTO 903
         IF(N.NE.NCON) GOTO 904
         BUMP = .TRUE.
      ENDIF
      ENDDO

C  CHECK STORE NODE COUNT AND ALIGNMENT
C  ------------------------------------

      IF(.NOT.BUMP .AND. NNOD.EQ.0) GOTO 905
      IF(NNOD.GT.I1)                GOTO 906

      IRPC = -1
      DO I=1,NNOD
      IF(NODS(I).GT.0) THEN
         IF(IRPC.LT.0) IRPC = LSTRPC(NODS(I),LUN)
         IF(IRPC.NE.LSTRPC(NODS(I),LUN).AND.IAC.EQ.0) GOTO 907
      ENDIF
      ENDDO

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR1,'("BUFRLIB: PARUSR - INPUT STRING (",A,") HAS ")')
     . STR
      WRITE(BORT_STR2,'(18X,"LENGTH (",I4,"), > LIMIT OF 80 CHAR.")')
     . LEN(STR)
      CALL BORT2(BORT_STR1,BORT_STR2)
901   WRITE(BORT_STR1,'("BUFRLIB: PARUSR - THE NUMBER OF CONDITION '//
     . 'NODES IN INPUT STRING")')
      WRITE(BORT_STR2,'(18X,A,") EXCEEDS THE MAXIMUM (",I3,")")')
     . STR,MAXCON
      CALL BORT2(BORT_STR1,BORT_STR2)
902   WRITE(BORT_STR1,'("BUFRLIB: PARUSR - THE NUMBER OF STORE NODES '//
     . 'IN INPUT STRING")')
       WRITE(BORT_STR2,'(18X,A,") EXCEEDS THE MAXIMUM (",I3,")")')
     . STR,MAXNOD
      CALL BORT2(BORT_STR1,BORT_STR2)
903   WRITE(BORT_STR1,'("BUFRLIB: PARUSR - BUMP NODE (^ IN INPUT '//
     . 'STRING ",A)') STR
      WRITE(BORT_STR2,'(18X,"IS SPECIFIED FOR A BUFR FILE OPEN FOR '//
     . 'INPUT, THE BUFR FILE MUST BE OPEN FOR OUTPUT")')
      CALL BORT2(BORT_STR1,BORT_STR2)
904   WRITE(BORT_STR1,'("BUFRLIB: PARUSR - INPUT STRING (",A,") '//
     . 'CONTAINS")') STR
      WRITE(BORT_STR2,'(18X,"CONDITIONAL NODES IN ADDITION TO BUMP '//
     . 'NODE - THE BUMP MUST BE ON THE INNER NODE")')
      CALL BORT2(BORT_STR1,BORT_STR2)
905   WRITE(BORT_STR1,'("BUFRLIB: PARUSR - INPUT STRING (",A,") HAS")')
     . STR
      WRITE(BORT_STR2,'(18X,"NO STORE NODES")')
      CALL BORT2(BORT_STR1,BORT_STR2)
906   WRITE(BORT_STR1,'("BUFRLIB: PARUSR - INPUT STRING (",A,")")') STR
      WRITE(BORT_STR2,'(18X,"HAS",I5," STORE NODES (MNEMONICS) - THE '//
     . 'LIMIT {THIRD (INPUT) ARGUMENT} IS",I5)') NNOD,I1
      CALL BORT2(BORT_STR1,BORT_STR2)
907   WRITE(BORT_STR1,'("BUFRLIB: PARUSR - INPUT STRING (",A,") '//
     . 'CONTAINS")') STR
      WRITE(BORT_STR2,'(18X,"STORE NODES (MNEMONICS) THAT ARE IN MORE'//
     . ' THAN ONE REPLICATION GROUP")')
      CALL BORT2(BORT_STR1,BORT_STR2)
      END
      SUBROUTINE PARUTG(LUN,IO,UTG,NOD,KON,VAL)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    PARUTG
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE PARSES A USER-SPECIFIED TAG (MNEMONIC)
C   (UTG) THAT REPRESENTS A VALUE EITHER BEING DECODED FROM A BUFR FILE
C   (IF IT IS BEING READ) OR ENCODED INTO A BUFR FILE (IF IT IS BEING
C   WRITTEN).  THIS SUBROUTINE FIRST CHECKS TO SEE IF THE TAG CONTAINS
C   A CONDITION CHARACTER ('=', '!', '<', '>' OR '^').  IF IT DOES NOT,
C   NOTHING HAPPENS AT THIS POINT.  IF IT DOES, THEN THE TYPE OF
C   CONDITION CHARACTER IS NOTED AND THE TAG IS STRIPPED OF ALL
C   CHARACTERS AT AND BEYOND THE CONDITION CHARACTER.  IN EITHER EVENT,
C   THE RESULTANT TAG IS CHECKED AGAINST THOSE IN THE INTERNAL JUMP/
C   LINK SUBSET TABLE (IN COMMON BLOCK /TABLES/).  IF FOUND, THE NODE
C   ASSOCIATED WITH THE TAG IS RETURNED (AND IT IS EITHER A "CONDITION"
C   NODE OR A "STORE" NODE DEPENDING OF THE PRESENCE OR ABSENCE OF A
C   CONDITION CHARACTER IN UTG).  OTHERWISE THE NODE IS RETURNED AS
C   ZERO.  IF THE TAG REPRESENTS A CONDITION NODE, THEN THE CONDITION
C   VALUE (NUMERIC CHARACTERS BEYOND THE CONDITION CHARACTER IN THE
C   USER-SPECIFIED TAG INPUT HERE) IS RETURNED.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY); OUTPUTS MORE COMPLETE DIAGNOSTIC
C                           INFO WHEN ROUTINE TERMINATES ABNORMALLY;
C                           CHANGED CALL FROM BORT TO BORT2 IN SOME
C                           CASES; REPLACED PREVIOUS "RETURN 1"
C                           STATEMENT WITH "GOTO 900" (AND CALL TO
C                           BORT) SINCE THE ONLY ROUTINE THAT CALLS
C                           THIS ROUTINE, PARUSR, USED THIS ALTERNATE
C                           RETURN TO GO TO A STATEMENT WHICH CALLED
C                           BORT
C
C USAGE:    CALL PARUTG (LUN, IO, UTG, NOD, KON, VAL)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     IO       - INTEGER: STATUS INDICATOR FOR BUFR FILE ASSOCIATED
C                WITH LUN:
C                       0 = input file
C                       1 = output file
C     UTG      CHARACTER*20: USER-SUPPLIED TAG REPRESENTING A VALUE TO
C              BE ENCODED/DECODED TO/FROM BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     NOD      - INTEGER: POSITIONAL INDEX IN INTERNAL JUMP/LINK SUBSET
C                TABLE FOR TAG
C                       0 = tag not found in table
C     KON      - INTEGER: INDICATOR FOR TYPE OF CONDITION CHARACTER
C                FOUND IN UTG:
C                      0 = no condition character found (NOD is a store
C                          node)
C                      1 = character '=' found
C                      2 = character '!' found
C                      3 = character '<' found
C                      4 = character '>' found
C                      5 = character '^' found
C                      (1-5 means NOD is a condition node, and
C                       specifically 5 is a "bump" node)
C     VAL      - REAL: CONDITION VALUE ASSOCIATED WITH CONDITION
C                CHARACTER FOUND IN UTG
C                      0 = UTG does not have a condition character
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     BORT2    STRNUM
C    THIS ROUTINE IS CALLED BY: PARUSR
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)
      COMMON /UTGPRM/ PICKEY

      CHARACTER*128 BORT_STR1,BORT_STR2
      CHARACTER*20  UTG,ATAG
      CHARACTER*10  TAG
      CHARACTER*3   TYP,ATYP,BTYP
      CHARACTER*1   COND(5)
      DIMENSION     BTYP(8),IOK(8)
      LOGICAL       PICKEY

      DATA NCHK   / 8/
      DATA BTYP   /'SUB','SEQ','REP','RPC','RPS','DRB','DRP','DRS'/
      DATA IOK    /  -1 ,  -1 ,  -1 ,  -1 ,  -1 ,  -1 ,   1 ,   0 /
      DATA LTG    /20/

C----------------------------------------------------------------------
      PICKEY = .FALSE.
      COND(1) = '='
      COND(2) = '!'
      COND(3) = '<'
      COND(4) = '>'
      COND(5) = '^'
      NCOND   = 5
C----------------------------------------------------------------------

      ATAG  = ' '
      ATYP  = ' '
      KON   = 0
      NOD   = 0
      VAL   = 0

C  PARSE UTG, SAVING INTO ATAG ONLY CHARACTERS PRIOR TO CONDITION CHAR.
C  --------------------------------------------------------------------

      DO I=1,LTG
      IF(UTG(I:I).EQ.' ') GOTO 1
      DO J=1,NCOND
      IF(UTG(I:I).EQ.COND(J)) THEN
         KON = J
         ICV = I+1
         GOTO 1
      ENDIF
      ENDDO
      ATAG(I:I) = UTG(I:I)
      ENDDO

C  FIND THE NODE ASSOCIATED WITH ATAG IN THE SUBSET TABLE
C  ------------------------------------------------------

1     INOD = INODE(LUN)
      DO NOD=INOD,ISC(INOD)
      IF(ATAG.EQ.TAG(NOD)) GOTO 2
      ENDDO

C  ATAG NOT FOUND IN SUBSET TABLE
C  ------------------------------

c  .... DK: PICKEY always FALSE, why is it in here?
      IF(KON.EQ.0 .AND. (IO.EQ.0.OR.ATAG.EQ.'NUL'.OR..NOT.PICKEY)) THEN
ccccc IF(KON.EQ.0) THEN
         NOD = 0
         GOTO 100
      ELSE
c  .... DK: Will cond. chars. only be in mnemonics being written?
         GOTO 900
      ENDIF

C  ATAG IS FOUND IN SUBSET TABLE, MAKE SURE IT HAS A VALID NODE TYPE
C  -----------------------------------------------------------------

2     IF(KON.EQ.5) THEN
c  .... Cond. char "^" must be assoc. with a delayed replication
c       sequence (this is a "bump" node) (Note: This is obsolete but
c       remains for "old" programs using the BUFR ARCHIVE LIBRARY)
         IF(TYP(NOD-1).NE.'DRP' .AND. TYP(NOD-1).NE.'DRS') GOTO 901
      ELSE
         ATYP = TYP(NOD)
         DO I=1,NCHK
         IF(ATYP.EQ.BTYP(I) .AND. IO.GT.IOK(I)) GOTO 902
         ENDDO
      ENDIF

C  IF CONDITION NODE, GET CONDITION VALUE WHICH IS A NUMBER FOLLOWING IT
C  ---------------------------------------------------------------------

      IF(KON.NE.0) THEN
         CALL STRNUM(UTG(ICV:LTG),NUM)
c  .... DK: The only cond. char. I've ever seen used is "^", and there
c           never were any numbers after it - I don't know what the
c           number would mean here and I don't know what any of the
c           other cond. char. mean
         IF(NUM.LT.0) GOTO 903
         VAL = NUM
      ENDIF

C  EXITS
C  -----

100   RETURN
900   WRITE(BORT_STR1,'("BUFRLIB: PARUTG - TRYING TO WRITE A MNEMONIC'//
     . ' (",A,") WHICH DOES NOT EXIST IN SUBSET TABLE")') ATAG
      WRITE(BORT_STR2,'(18X,"(UPON INPUT, IT CONTAINED THE CONDITION '//
     . 'CHARACTER ",A,")")') UTG(ICV-1:ICV-1)
      CALL BORT2(BORT_STR1,BORT_STR2)
901   WRITE(BORT_STR1,'("BUFRLIB: PARUTG - BUMP NODE (MNEMONIC ",A,")'//
     . ' MUST REFER TO A DELAYED REPLICATION SEQUENCE, HERE TYPE IS "'//
     . ',A)') ATAG,TYP(NOD-1)
      CALL BORT(BORT_STR1)
902   WRITE(BORT_STR1,'("BUFRLIB: PARUTG - ILLEGAL NODE TYPE: ",A," '//
     . 'FOR MNEMONIC ",A)') ATYP,ATAG
      CALL BORT(BORT_STR1)
903   WRITE(BORT_STR1,'("BUFRLIB: PARUTG - CONDITION VALUE IN '//
     . 'MNEMONIC ",A," ILLEGAL BECAUSE ALL OTHER CHARACTERS IN '//
     . 'MNEMONIC MUST BE NUMERIC")') UTG
      CALL BORT(BORT_STR1)
      END
      SUBROUTINE PKB(NVAL,NBITS,IBAY,IBIT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    PKB
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE PACKS AN INTEGER VALUE (NVAL) INTO NBITS
C   BITS OF A AN INTEGER ARRAY (IBAY), STARTING WITH BIT IBIT+1.  ON
C   OUTPUT, IBIT IS UPDATED TO POINT TO THE LAST BIT THAT WAS PACKED.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  J. WOOLLEN -- BIG-ENDIAN/LITTLE-ENDIAN INDEPENDENT (WAS
C                           IN DECODER VERSION)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION
C
C USAGE:    CALL PKB (NVAL, NBITS, IBAY, IBIT)
C   INPUT ARGUMENT LIST:
C     NVAL     - INTEGER: INTEGER TO BE PACKED
C     NBITS    - INTEGER: NUMBER OF BITS OF IBAY WITHIN WHICH TO PACK
C                NVAL
C     IBAY     - INTEGER: *-WORD PACKED BINARY ARRAY NOT YET CONTAINING
C                PACKED NVAL
C     IBIT     - INTEGER: BIT POINTER WITHIN IBAY TO START PACKING FROM
C
C   OUTPUT ARGUMENT LIST:
C     IBAY     - INTEGER: *-WORD PACKED BINARY ARRAY NOW CONTAINING
C                PACKED NVAL
C     IBIT     - INTEGER: BIT POINTER WITHIN IBAY INDICATING LAST BIT
C                THAT WAS PACKED
C
C REMARKS:
C    THIS SUBROUTINE IS THE INVERSE OF BUFR ARCHIVE LIBRARY ROUTINE
C    UPB.
C
C    THIS ROUTINE CALLS:        IREV
C    THIS ROUTINE IS CALLED BY: CMSGINI  COMPRES  CPYUPD   DXMINI
C                               MINIMG   MSGINI   MSGUPD   MSGWRT
C                               MVB      OVRBS1   PAD      STANDARD
C                               SUBUPD   WRCMPS   WRITDX   WRITST
C                               WRTREE   XMSGINI
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)

      DIMENSION IBAY(*)

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      NWD  = IBIT/NBITW + 1
      NBT  = MOD(IBIT,NBITW)
      IVAL = NVAL
      IF(ISHFT(IVAL,-NBITS).GT.0) IVAL = -1
      INT = ISHFT(IVAL,NBITW-NBITS)
      INT = ISHFT(INT,-NBT)
      MSK = ISHFT(  -1,NBITW-NBITS)
      MSK = ISHFT(MSK,-NBT)
      IBAY(NWD) = IREV(IOR(IAND(IREV(IBAY(NWD)),NOT(MSK)),INT))
c  .... big-endian only form commented out
ccccc IBAY(NWD) = IOR(IAND(IBAY(NWD),NOT(MSK)),INT)
      IF(NBT+NBITS.GT.NBITW) THEN

C        There are less than NBITS bits remaining within the current
C        word (i.e. array member) of IBAY, so store as many bits as
C        will fit within the current word and then store the remaining
C        bits within the next word.

         INT = ISHFT(IVAL,2*NBITW-(NBT+NBITS))
         MSK = ISHFT(  -1,2*NBITW-(NBT+NBITS))
         IBAY(NWD+1) = IREV(IOR(IAND(IREV(IBAY(NWD+1)),NOT(MSK)),INT))
c  .... big-endian only form commented out
ccccc    IBAY(NWD+1) = IOR(IAND(IBAY(NWD+1),NOT(MSK)),INT)
      ENDIF

      IBIT = IBIT + NBITS

      RETURN
      END
      SUBROUTINE PKC(CHR,NCHR,IBAY,IBIT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    PKC
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE PACKS A CHARACTER STRING (CHR) CONTAINING
C   NCHR CHARACTERS INTO NCHR BYTES OF AN INTEGER ARRAY (IBAY),
C   STARTING WITH BIT IBIT+1.  ON OUTPUT, IBIT IS UPDATED TO POINT TO
C   THE LAST BIT THAT WAS PACKED.  NOTE THAT THERE IS NO GUARANTEE THAT
C   THE NCHR CHARACTERS WILL BE ALIGNED ON BYTE BOUNDARIES WHEN PACKED
C   WITHIN IBAY.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  J. WOOLLEN -- BIG-ENDIAN/LITTLE-ENDIAN INDEPENDENT (WAS
C                           IN DECODER VERSION)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY; CHANGED CALL FROM BORT TO BORT2
C
C USAGE:    CALL PKC (CHR, NCHR, IBAY, IBIT)
C   INPUT ARGUMENT LIST:
C     CHR      - CHARACTER*(*): CHARACTER STRING TO BE PACKED
C     NCHR     - INTEGER: NUMBER OF BYTES OF IBAY WITHIN WHICH TO PACK
C                CHR (I.E., THE NUMBER OF CHARACTERS IN CHR)
C     IBIT     - INTEGER: BIT POINTER WITHIN IBAY TO START PACKING FROM
C
C   OUTPUT ARGUMENT LIST:
C     IBAY     - INTEGER: *-WORD PACKED BINARY ARRAY NOW CONTAINING
C                PACKED CHR
C     IBIT     - INTEGER: BIT POINTER WITHIN IBAY INDICATING LAST BIT
C                THAT WAS PACKED
C
C REMARKS:
C    THIS SUBROUTINE IS THE INVERSE OF BUFR ARCHIVE LIBRARY ROUTINE
C    UPC.
C
C    THIS ROUTINE CALLS:        BORT2    IPKM     IREV     IUPM
C    THIS ROUTINE IS CALLED BY: CMSGINI  COMPRES  DXMINI   MSGINI
C                               MSGWRT   STANDARD WRCMPS   WRITDX
C                               WRITLC   WRITST   WRTREE   XMSGINI
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /CHARAC/ IASCII,IATOE(0:255),IETOA(0:255)
      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)

      CHARACTER*(*) CHR
      CHARACTER*128 BORT_STR1,BORT_STR2
      CHARACTER*1   CVAL(8)
      DIMENSION     IBAY(*),IVAL(2)
      EQUIVALENCE   (CVAL,IVAL)

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      IF(NCHR.GT.LEN(CHR)) GOTO 900
      LB = IORD(NBYTW)

C     LB now points to the "low-order" (i.e. least significant) byte
C     within a machine word.

      IVAL(1) = 0
      NBIT = 8

      DO I=1,NCHR
      CVAL(LB) = CHR(I:I)

C     If the machine is EBCDIC, then translate character CVAL(LB) from
C     EBCDIC to ASCII.

      IF(IASCII.EQ.0) CALL IPKM(CVAL(LB),1,IETOA(IUPM(CVAL(LB),8)))

      NWD  = IBIT/NBITW + 1
      NBT  = MOD(IBIT,NBITW)
      INT = ISHFT(IVAL(1),NBITW-NBIT)
      INT = ISHFT(INT,-NBT)
      MSK = ISHFT(  -1,NBITW-NBIT)
      MSK = ISHFT(MSK,-NBT)
      IBAY(NWD) = IREV(IOR(IAND(IREV(IBAY(NWD)),NOT(MSK)),INT))
c big-endian only form commented out
ccccc IBAY(NWD) = IOR(IAND(IBAY(NWD),NOT(MSK)),INT)
      IF(NBT+NBIT.GT.NBITW) THEN

C        This character will not fit within the current word (i.e.
C        array member) of IBAY, because there are less than 8 bits of
C        space left.  Store as many bits as will fit within the current
C        word and then store the remaining bits within the next word.

         INT = ISHFT(IVAL(1),2*NBITW-(NBT+NBIT))
         MSK = ISHFT(  -1,2*NBITW-(NBT+NBIT))
         IBAY(NWD+1) = IREV(IOR(IAND(IREV(IBAY(NWD+1)),NOT(MSK)),INT))
c big-endian only form commented out
ccccc    IBAY(NWD+1) = IOR(IAND(IBAY(NWD+1),NOT(MSK)),INT)
      ENDIF
      IBIT = IBIT + NBIT
      ENDDO

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR1,'("BUFRLIB: PKC - THE INPUT CHARACTER STRING ("'//
     . ',A,") IS SHORTER (HAS FEWER CHARACTERS)")') CHR
      WRITE(BORT_STR2,'(18X,"THAN THE NUMBER OF CHARACTERS FROM IT '//
     . 'THAT ARE TO BE PACKED (",I3,")")') NCHR
      CALL BORT2(BORT_STR1,BORT_STR2)
      END
      SUBROUTINE PKTDD(ID,LUN,IDN,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    PKTDD
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE STORES INFORMATION ABOUT A "CHILD"
C   MNEMONIC WITHIN THE INTERNAL BUFR TABLE D ENTRY (IN COMMON BLOCK
C   /TABABD/) FOR A TABLE D SEQUENCE ("PARENT") MNEMONIC WHEN THE
C   "CHILD" MNEMONIC IS CONTAINED WITHIN THE SEQUENCE REPRESENTED BY
C   THE "PARENT" MNEMONIC (AS DETERMINED WITHIN BUFR ARCHIVE LIBRARY
C   SUBROUTINE SEQSDX).
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1995-06-28  J. WOOLLEN -- INCREASED THE SIZE OF INTERNAL BUFR TABLE
C                           ARRAYS IN ORDER TO HANDLE BIGGER FILES
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; ADDED MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN UNUSUAL THINGS HAPPEN
C
C USAGE:    CALL PKTDD (ID, LUN, IDN, IRET)
C   INPUT ARGUMENT LIST:
C     ID       - INTEGER: POSITIONAL INDEX OF PARENT MNEMONIC WITHIN
C                INTERNAL BUFR TABLE D ARRAY TABD(*,*)
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     IDN      - INTEGER: BIT-WISE REPRESENTATION OF FXY VALUE
C                CORRESPONDING TO CHILD MNEMONIC
C                       0 = delete all information about all child
C                           mnemonics from within TABD(ID,LUN)
C
C   OUTPUT ARGUMENT LIST:
C     IRET     - INTEGER: TOTAL NUMBER OF CHILD MNEMONICS STORED THUS
C                FAR (INCLUDING IDN) FOR THE PARENT MNEMONIC GIVEN BY
C                TABD(ID,LUN)
C                       0 = information was cleared from TABD(ID,LUN)
C                           because input IDN value was 0
C                      -1 = bad counter value or maximum number of
C                           child mnemonics already stored for this
C                           parent mnemonic
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        IPKM     IUPM
C    THIS ROUTINE IS CALLED BY: DXINIT   RDBFDX   SEQSDX
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MAXTBA=50)
      PARAMETER (MAXTBB=250)
      PARAMETER (MAXTBD=250)

      COMMON /TABABD/ NTBA(0:NFILES),NTBB(0:NFILES),NTBD(0:NFILES),
     .                MTAB(MAXTBA,NFILES),IDNA(MAXTBA,NFILES,2),
     .                IDNB(MAXTBB,NFILES),IDND(MAXTBD,NFILES),
     .                TABA(MAXTBA,NFILES),TABB(MAXTBB,NFILES),
     .                TABD(MAXTBD,NFILES)
      COMMON /DXTAB / MAXDX,IDXV,NXSTR(10),LDXA(10),LDXB(10),LDXD(10),
     .                LD30(10),DXSTR(10)
      COMMON /QUIET / IPRT

      CHARACTER*600 TABD
      CHARACTER*128 TABB
      CHARACTER*128 TABA
      CHARACTER*56  DXSTR

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      LDD = LDXD(IDXV+1)+1

C     LDD points to the byte within TABD(ID,LUN) which contains (in
C     packed integer format) a count of the number of child mnemonics
C     stored thus far for this parent mnemonic.

C  ZERO THE COUNTER IF IDN IS ZERO
C  -------------------------------

      IF(IDN.EQ.0) THEN
         CALL IPKM(TABD(ID,LUN)(LDD:LDD),1,0)
         IRET = 0
         GOTO 100
      ENDIF

C  UPDATE THE STORED DESCRIPTOR COUNT FOR THIS TABLE D ENTRY
C  ---------------------------------------------------------

      ND = IUPM(TABD(ID,LUN)(LDD:LDD),8)

C     ND is the (unpacked) count of the number of child mnemonics
C     stored thus far for this parent mnemonic.

      IF(ND.LT.0 .OR. ND.EQ.250) THEN
      IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
         IF(ND.LT.0) THEN
            PRINT*, 'BUFRLIB: PKTDD - BAD COUNTER VALUE (=',ND,
     .       ') - RETURN WITH IRET = -1'
         ELSE
            PRINT*, 'BUFRLIB: PKTDD - MAXIMUM NUMBER OF CHILD ',
     .       'MNEMONICS (250) ALREADY STORED FOR THIS PARENT MNEMONIC',
     .       ' - RETURN WITH IRET = -1'
         ENDIF
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
      ENDIF
         IRET = -1
         GOTO 100
      ELSE
         ND = ND+1
         CALL IPKM(TABD(ID,LUN)(LDD:LDD),1,ND)
         IRET = ND
      ENDIF

C  PACK AND STORE THE DESCRIPTOR
C  -----------------------------

      IDM = LDD+1 + (ND-1)*2

C     IDM points to the starting byte within TABD(ID,LUN) at which
C     the IDN value for this child mnemonic will be stored (as a
C     packed integer of width = 2 bytes).

      CALL IPKM(TABD(ID,LUN)(IDM:IDM),2,IDN)

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE POSAPN(LUNIT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    POSAPN
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE READS AND COUNTS BUFR MESSAGES IN ORDER TO
C   POSITION FOR APPEND.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL POSAPN (LUNIT)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   INPUT FILES:
C     UNIT "LUNIT" - BUFR FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     LMSG
C    THIS ROUTINE IS CALLED BY: OPENBF
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MXMSGL=20000)

      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)

      CHARACTER*8 SEC0
      DIMENSION   MBAY(MXMSGL/4)

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IMSG = 8/NBYTW+1
      REWIND LUNIT
      IREC = 0

1     READ(LUNIT,ERR=2,END=2) SEC0,(MBAY(I),I=IMSG,LMSG(SEC0))
      IREC = IREC+1
      GOTO 1

2     REWIND LUNIT
      DO J=1,IREC
      READ(LUNIT,ERR=900,END=901) SEC0,(MBAY(I),I=IMSG,LMSG(SEC0))
      ENDDO

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: POSAPN - ERROR READING A BUFR MESSAGE')
901   CALL BORT('BUFRLIB: POSAPN - FAILURE TO READ TO END-OF-'//
     . '(BUFR)FILE')
      END
      SUBROUTINE POSAPX(LUNIT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    POSAPX
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE READS TO THE END OF THE FILE AND BACKSPACES
C   IN ORDER TO POSITION FOR APPEND.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL POSAPX (LUNIT)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   INPUT FILES:
C     UNIT "LUNIT" - BUFR FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     LMSG
C    THIS ROUTINE IS CALLED BY: OPENBF
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MXMSGL=20000)

      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)

      CHARACTER*8 SEC0
      DIMENSION   MBAY(MXMSGL/4)

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IMSG = 8/NBYTW+1
      REWIND LUNIT
      IREC = 0

C  TRY TO READ TO THE END OF THE FILE
C  ----------------------------------

1     READ(LUNIT,ERR=3,END=2) SEC0,(MBAY(I),I=IMSG,LMSG(SEC0))
      IREC = IREC+1
      GOTO 1

C  IF SUCCESSFUL BACKSPACE FOR APPENDING AND RETURN
C  ------------------------------------------------

2     BACKSPACE LUNIT
      GOTO 100

C  IF AN I/O ERROR IS ENCOUNTERED REREAD THE GOOD RECORDS, BACKSPACE
C   FOR APPPENDING AND RETURN
C  -----------------------------------------------------------------

3     REWIND LUNIT
      DO J=1,IREC
      READ(LUNIT,ERR=900,END=2) SEC0,(MBAY(I),I=IMSG,LMSG(SEC0))
      ENDDO

C  EXITS
C  -----

c  .... DK: Is there a problem if code gets to this RETURN via
c           falling through from loop above (coming from goto 100
c           statement above is ok I can see that) ?
100   RETURN
900   CALL BORT('BUFRLIB: POSAPX - ERROR READING A BUFR MESSAGE')
      END
      SUBROUTINE RCSTPL(LUN)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    RCSTPL
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE STORES THE SUBSET TEMPLATE INTO INTERNAL
C   SUBSET ARRAYS IN COMMON BLOCKS /USRINT/ AND /USRBIT/.  THIS IS IN
C   PREPARATION FOR THE ACTUAL UNPACKING OF THE SUBSET IN BUFR ARCHIVE
C   LIBRARY SUBROUTINE RDTREE.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1998-10-27  J. WOOLLEN -- MODIFIED TO CORRECT PROBLEMS CAUSED BY IN-
C                           LINING CODE WITH FPP DIRECTIVES
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2002-05-14  J. WOOLLEN -- REMOVED OLD CRAY COMPILER DIRECTIVES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); MAXRCR (MAXIMUM
C                           NUMBER OF RECURSION LEVELS) INCREASED FROM
C                           50 TO 100  (WAS IN VERIFICATION VERSION);
C                           UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY; COMMENTED OUT
C                           HARDWIRE OF VTMP TO "BMISS" (10E10) WHEN IT
C                           IS > 10E9 (CAUSED PROBLEMS ON SOME FOREIGN
C                           MACHINES)
C
C USAGE:    CALL RCSTPL (LUN)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     UPBB
C    THIS ROUTINE IS CALLED BY: RDTREE   READ2C
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)
      PARAMETER (MAXRCR=100)
      PARAMETER (MXMSGL=20000)

      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /USRBIT/ NBIT(MAXJL),MBIT(MAXJL)
      COMMON /USRTMP/ ITMP(MAXJL,MAXRCR),VTMP(MAXJL,MAXRCR)

      CHARACTER*128 BORT_STR
      CHARACTER*10  TAG
      CHARACTER*3   TYP
      DIMENSION     NBMP(2,MAXRCR),NEWN(2,MAXRCR)
      DIMENSION     KNX(MAXRCR)
      REAL*8        VAL,VTMP
ccccccREAL*8        BMISS

ccccccDATA BMISS /10E10/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  SET THE INITIAL VALUES FOR THE TEMPLATE
C  ---------------------------------------

c  .... Positional index of Table A mnem.
      INV(1,LUN) = INODE(LUN)
      VAL(1,LUN) = 0
      NBMP(1,1) = 1
      NBMP(2,1) = 1
      NODI = INODE(LUN)
      NODE = INODE(LUN)
      MBMP = 1
      KNVN = 1
      NR   = 0

      DO I=1,MAXRCR
      KNX(I) = 0
      ENDDO

C  SET UP THE PARAMETERS FOR A LEVEL OF RECURSION
C  ----------------------------------------------

10    CONTINUE

      NR = NR+1
      IF(NR.GT.MAXRCR) GOTO 900
      NBMP(1,NR) = 1
      NBMP(2,NR) = MBMP

      N1 = ISEQ(NODE,1)
      N2 = ISEQ(NODE,2)
      IF(N1.EQ.0         ) GOTO 901
      IF(N2-N1+1.GT.MAXJL) GOTO 902
      NEWN(1,NR) = 1
      NEWN(2,NR) = N2-N1+1

      DO N=1,NEWN(2,NR)
      NN = JSEQ(N+N1-1)
      ITMP(N,NR) = NN
      VTMP(N,NR) = VALI(NN)
ccccccIF(VTMP(N,NR).GT.10E9) VTMP(N,NR) = BMISS
      ENDDO

C  STORE NODES AT SOME RECURSION LEVEL
C  -----------------------------------

20    DO I=NBMP(1,NR),NBMP(2,NR)
      IF(KNX(NR).EQ.0000) KNX(NR) = KNVN
      IF(I.GT.NBMP(1,NR)) NEWN(1,NR) = 1
      DO J=NEWN(1,NR),NEWN(2,NR)
      KNVN = KNVN+1
      NODE = ITMP(J,NR)
c  .... INV is positional index in internal jump/link table for packed
c       subset element KNVN in MBAY
      INV(KNVN,LUN) = NODE
c  .... Actual unpacked subset values (VAL) are init. here (numbers as
c      10E10, msg)
      VAL(KNVN,LUN) = VTMP(J,NR)
c  .... MBIT is the bit in MBAY pointing to where the packed subset
c       element KNVN begins
      MBIT(KNVN) = MBIT(KNVN-1)+NBIT(KNVN-1)
c  .... NBIT is the number of bits in MBAY occupied by packed subset
c       element KNVN
      NBIT(KNVN) = IBT(NODE)
      IF(ITP(NODE).EQ.1) THEN
         CALL UPBB(MBMP,NBIT(KNVN),MBIT(KNVN),MBAY(1,LUN))
         NEWN(1,NR) = J+1
         NBMP(1,NR) = I
         GOTO 10
      ENDIF
      ENDDO
      NEW = KNVN-KNX(NR)
      VAL(KNX(NR)+1,LUN) = VAL(KNX(NR)+1,LUN) + NEW
      KNX(NR) = 0
      ENDDO

C  CONTINUE AT ONE RECURSION LEVEL BACK
C  ------------------------------------

      IF(NR-1.NE.0) THEN
         NR = NR-1
         GOTO 20
      ENDIF

C  FINALLY STORE THE LENGTH OF (NUMBER OF ELEMENTS IN) SUBSET TEMPLATE
C  -------------------------------------------------------------------

      NVAL(LUN) = KNVN

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: RCSTPL - THE NUMBER OF RECURSION '//
     . 'LEVELS EXCEEDS THE LIMIT (",I3,")")') MAXRCR
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: RCSTPL - UNSET EXPANSION SEGMENT ",A)')
     . TAG(NODI)
      CALL BORT(BORT_STR)
902   WRITE(BORT_STR,'("BUFRLIB: RCSTPL - TEMPLATE ARRAY OVERFLOW, '//
     . 'EXCEEDS THE LIMIT (",I6,") (",A,")")') MAXJL,TAG(NODI)
      CALL BORT(BORT_STR)
      END
      SUBROUTINE RDBFDX(LUNIT,LUN)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    RDBFDX
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE READS BUFR TABLE (DICTIONARY) MESSAGES FROM
C   AN INPUT BUFR FILE AND COPIES THEM INTO INTERNAL MEMORY (ARRAYS IN
C   COMMON BLOCK /TABABD/).  IT IS ASSUMED THERE IS AT LEAST ONE
C   DICTIONARY MESSAGE AT THE BEGINNING OF THE FILE.  THIS SUBROUTINE
C   PERFORMS A FUNCTION SIMILAR TO BUFR ARCHIVE LIBRARY SUBROUTINE
C   RDUSDX, EXECPT THAT RDUSDX READS FROM AN EXTERNAL FILE CONTAINING A
C   USER-SUPPLIED BUFR DICTIONARY TABLE IN CHARACTER FORMAT.  SEE
C   DOCBLOCK IN RDUSDX FOR A DESCRIPTION OF THE ARRAYS THAT ARE FILLED
C   IN COMMON BLOCK /TABABD/.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1995-06-28  J. WOOLLEN -- INCREASED THE SIZE OF INTERNAL BUFR TABLE
C                           ARRAYS IN ORDER TO HANDLE BIGGER FILES
C 1996-12-17  J. WOOLLEN -- FIXED FOR SOME MVS COMPILER'S TREATMENT OF
C                           INTERNAL READS (INCREASES PORTABILITY)
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"; CORRECTED SOME MINOR ERRORS
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL RDBFDX (LUNIT, LUN)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C                (ASSOCIATED WITH FILE CONNECTED TO LOGICAL UNIT LUNIT)
C
C   INPUT FILES:
C     UNIT "LUNIT" - BUFR FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     CAPIT    CHRTRN   CHRTRNA
C                               DIGIT    DXINIT   IDN30    IFXY
C                               IUPM     LMSG     MAKESTAB NENUAA
C                               NENUBD   PKTDD
C    THIS ROUTINE IS CALLED BY: READDX
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MAXTBA=50)
      PARAMETER (MAXTBB=250)
      PARAMETER (MAXTBD=250)
      PARAMETER (MXMSGL=20000)

      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)
      COMMON /TABABD/ NTBA(0:NFILES),NTBB(0:NFILES),NTBD(0:NFILES),
     .                MTAB(MAXTBA,NFILES),IDNA(MAXTBA,NFILES,2),
     .                IDNB(MAXTBB,NFILES),IDND(MAXTBD,NFILES),
     .                TABA(MAXTBA,NFILES),TABB(MAXTBB,NFILES),
     .                TABD(MAXTBD,NFILES)
      COMMON /DXTAB / MAXDX,IDXV,NXSTR(10),LDXA(10),LDXB(10),LDXD(10),
     .                LD30(10),DXSTR(10)

      CHARACTER*600 TABD
      CHARACTER*128 BORT_STR
      CHARACTER*128 TABB,TABB1,TABB2
      CHARACTER*128 TABA
      CHARACTER*56  DXSTR
      CHARACTER*50  DXCMP
      CHARACTER*24  UNIT
      CHARACTER*8   SEC0,NEMO
      CHARACTER*6   NUMB,CIDN
      CHARACTER*1   MOCT(MXMSGL)
      DIMENSION     MBAY(MXMSGL/4),LDXBD(10),LDXBE(10)
      EQUIVALENCE   (MBAY(1),MOCT(1))
      LOGICAL       DIGIT

      DATA LDXBD /38,70,8*0/
      DATA LDXBE /42,42,8*0/

C-----------------------------------------------------------------------
      JA(I) = IA+1+LDA*(I-1)
      JB(I) = IB+1+LDB*(I-1)
C-----------------------------------------------------------------------

C  INITIALIZE THE DICTIONARY TABLE CONTROL WORD PARTITION ARRAYS
C  -------------------------------------------------------------

      CALL DXINIT(LUN,0)
      REWIND LUNIT
      IDX = 0

C  CLEAR THE MESSAGE BUFFER
C  ------------------------

1     DO I=1,MXMSGL/4
      MBAY(I) = 0
      ENDDO

      IMSG = 8/NBYTW+1

C  READ A MESSAGE
C  --------------

      READ(LUNIT,ERR=900,END=2) SEC0,(MBAY(I),I=IMSG,LMSG(SEC0))
c  .... IDX counts the number of dictionary messages read
      IDX = IDX+1

C  GET SECTION START OCTETS (I1, I2, I3, I4) & LENGTHS (L1, L2, L3, L4)
C  --------------------------------------------------------------------

c  .... DK: Won't there be problem SOON if READ above hit E-O-F?
2     I1 = 8
      L1 = IUPM(MOCT(I1+1),24)
      I2 = I1+L1
      L2 = IUPM(MOCT(I2+1),24)*IUPM(MOCT(I1+8),1)
      I3 = I2+L2
      L3 = IUPM(MOCT(I3+1),24)
      I4 = I3+L3
      L4 = IUPM(MOCT(I4+1),24)

C  SEE IF THIS IS A BUFR DICTIONARY MESSAGE - CHECK FOR RECOGNIZABLE
C   DICTIONARY VERSION (I.E., MESSAGE TYPE 11)
C  -----------------------------------------------------------------

c  .... DK: If file contained only dcty messages would logic get here?
c           READ above would go to stmt 2 for sure.  If made it here,
c           the read below would go to stmt 908.  (Note also IDX was not
c           incr. by 1 above if E-O-F, so loop below misses last dcty
c           msg (???))
      IF(IUPM(MOCT(I1+9),8).NE.11) THEN

C  IF NOT DICTIONARY MESSAGE, REWIND FILE AND READ THROUGH ALL
C   DICTIONARY MESSAGES AGAIN SO NEXT READ WILL GET DATA
C  -----------------------------------------------------------

         REWIND LUNIT
         DO NDX=1,IDX-1
         READ(LUNIT,ERR=908,END=908) SEC0,(MBAY(I),I=IMSG,LMSG(SEC0))
         ENDDO
c  ....  Will now construct COMMON block /TABLES/
         CALL MAKESTAB
         GOTO 100
      ENDIF

C  THIS IS A DICTIONARY MESSAGE, CONTINUE ONWARD
C  ---------------------------------------------

c  .... IDXS should be 2 (dcty subtype=1)
      IDXS = IUPM(MOCT(I1+10),8)+1
c  .... (never?)
      IF(IDXS.GT.IDXV+1) IDXS = IUPM(MOCT(I1+12),8)+1
      IF(LDXA(IDXS).EQ.0) GOTO 901
      IF(LDXB(IDXS).EQ.0) GOTO 901
      IF(LDXD(IDXS).EQ.0) GOTO 901
      L30 = LD30(IDXS)

      DXCMP = ' '
      CALL CHRTRN(DXCMP,MOCT(I3+8),NXSTR(IDXS))
      IF(DXCMP.NE.DXSTR(IDXS)) GOTO 902

C  SECTION 4 - READ DEFINITIONS FOR TABLES A, B AND D
C  --------------------------------------------------

      LDA  = LDXA (IDXS)
      LDB  = LDXB (IDXS)
      LDD  = LDXD (IDXS)
      LDBD = LDXBD(IDXS)
      LDBE = LDXBE(IDXS)

      IA = I4+5
      LA = IUPM(MOCT(IA),8)
      IB = JA(LA+1)
      LB = IUPM(MOCT(IB),8)
      ID = JB(LB+1)
      LD = IUPM(MOCT(ID),8)

C  TABLE A
C  -------

      DO I=1,LA
      N = NTBA(LUN)+1
      IF(N.GT.NTBA(0)) GOTO 903
      CALL CHRTRNA(TABA(N,LUN),MOCT(JA(I)),LDA)
      NUMB = '   '//TABA(N,LUN)(1:3)
      NEMO = TABA(N,LUN)(4:11)
      CALL NENUAA(NEMO,NUMB,LUN)
      NTBA(LUN) = N

      IF(DIGIT(NEMO(3:8))) THEN
c  .... Message type and subtype obtained directly from Table A mnemo.
         READ(NEMO,'(2X,2I3)') MTYP,MSBT
         IDNA(N,LUN,1) = MTYP
         IDNA(N,LUN,2) = MSBT
      ELSE
c  .... Message type obtained from Y value of Table A sequence descr.
c       Message subtype hardwired to ZERO
         READ(NUMB(4:6),'(I3)') IDNA(N,LUN,1)
         IDNA(N,LUN,2) = 0
      ENDIF
      ENDDO

C  TABLE B
C  -------

      DO I=1,LB
      N = NTBB(LUN)+1
      IF(N.GT.NTBB(0)) GOTO 904
      CALL CHRTRNA(TABB1,MOCT(JB(I)     ),LDBD)
      CALL CHRTRNA(TABB2,MOCT(JB(I)+LDBD),LDBE)
      TABB(N,LUN) = TABB1(1:LDXBD(IDXV+1))//TABB2(1:LDXBE(IDXV+1))
      NUMB = TABB(N,LUN)(1:6)
      NEMO = TABB(N,LUN)(7:14)
      UNIT = TABB(N,LUN)(71:94)
      CALL CAPIT(UNIT)
      TABB(N,LUN)(71:94) = UNIT
      CALL NENUBD(NEMO,NUMB,LUN)
      IDNB(N,LUN) = IFXY(NUMB)
      NTBB(LUN) = N
      ENDDO

C  TABLE D
C  -------

      DO I=1,LD
      N = NTBD(LUN)+1
      IF(N.GT.NTBD(0)) GOTO 905
      CALL CHRTRNA(TABD(N,LUN),MOCT(ID+1),LDD)
      NUMB = TABD(N,LUN)(1:6)
      NEMO = TABD(N,LUN)(7:14)
      CALL NENUBD(NEMO,NUMB,LUN)
      IDND(N,LUN) = IFXY(NUMB)
      ND = IUPM(MOCT(ID+LDD+1),8)
      IF(ND.GT.250) GOTO 906
      DO J=1,ND
      NDD = ID+LDD+2 + (J-1)*L30
      CALL CHRTRNA(CIDN,MOCT(NDD),L30)
      IDN = IDN30(CIDN,L30)
      CALL PKTDD(N,LUN,IDN,IRET)
      IF(IRET.LT.0) GOTO 907
      ENDDO
      ID = ID+LDD+1 + ND*L30
      IF(IUPM(MOCT(ID+1),8).EQ.0) ID = ID+1
      NTBD(LUN) = N
      ENDDO

C  GOTO READ THE NEXT MESSAGE
C  --------------------------

      GOTO 1

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: RDBFDX - ERROR READING A BUFR DICTIONARY '//
     . 'MESSAGE')
901   CALL BORT('BUFRLIB: RDBFDX - UNEXPECTED DICTIONARY MESSAGE '//
     . 'SUBTYPE OR LOCAL VERSION NUMBER (E.G., L.V.N. HIGHER THAN '//
     . 'KNOWN)')
902   CALL BORT('BUFRLIB: RDBFDX - UNEXPECTED DICTIONARY MESSAGE '//
     . 'CONTENTS')
903   WRITE(BORT_STR,'("BUFRLIB: RDBFDX - NUMBER OF TABLE A ENTRIES '//
     . 'IN BUFR TABLE EXCEEDS THE LIMIT (",I4,")")') NTBA(0)
      CALL BORT(BORT_STR)
904   WRITE(BORT_STR,'("BUFRLIB: RDBFDX - NUMBER OF TABLE B ENTRIES '//
     . 'IN BUFR TABLE EXCEEDS THE LIMIT (",I4,")")') NTBB(0)
      CALL BORT(BORT_STR)
905   WRITE(BORT_STR,'("BUFRLIB: RDBFDX - NUMBER OF TABLE D ENTRIES '//
     . 'IN BUFR TABLE EXCEEDS THE LIMIT (",I4,")")') NTBD(0)
      CALL BORT(BORT_STR)
906   WRITE(BORT_STR,'("BUFRLIB: RDBFDX - NUMBER OF DESCRIPTORS IN '//
     . 'TABLE D ENTRY ",A," IN BUFR TABLE (",I4,") EXCEEDS THE LIMIT '//
     . ' (250)")') NEMO,ND
      CALL BORT(BORT_STR)
907   CALL BORT('BUFRLIB: RDBFDX - BAD RETURN FROM BUFRLIB ROUTINE '//
     . 'PKTDD, SEE PREVIOUS WARNING MESSAGE')
908   CALL BORT('BUFRLIB: RDBFDX - ERROR OR E-O-F POSITIONING READ TO'//
     . ' FIRST DATA MESSAGE AFTER DCTY MESSAGES (FILE CONTAINS ONLY '//
     . 'DCTY MSGS?)')
      END
      SUBROUTINE RDCMPS(LUN)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    RDCMPS
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2000-09-19
C
C ABSTRACT: THIS SUBROUTINE UNCOMPRESSES AND UNPACKS THE NEXT SUBSET
C   FROM THE INTERNAL COMPRESSED MESSAGE BUFFER (ARRAY MBAY IN COMMON
C   BLOCK /BITBUF/) AND STORES THE UNPACKED SUBSET WITHIN THE INTERNAL
C   ARRAY VAL(*,LUN) IN COMMON BLOCK /USRINT/.
C
C PROGRAM HISTORY LOG:
C 2000-09-19  J. WOOLLEN -- ORIGINAL AUTHOR
C 2002-05-14  J. WOOLLEN -- IMPROVED GENERALITY, PREVIOUSLY RDCMPS
C                           WOULD NOT RECOGNIZE COMPRESSED DELAYED
C                           REPLICATION AS A LEGITIMATE DATA STRUCTURE
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED HISTORY DOCUMENTATION
C
C USAGE:    CALL RDCMPS (LUN)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C
C REMARKS:
C    THIS ROUTINE CALLS:        UPB      UPC      USRTPL
C    THIS ROUTINE IS CALLED BY: READSB
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)

      CHARACTER*10 TAG
      CHARACTER*8  CREF,CVAL
      CHARACTER*3  TYP
      EQUIVALENCE  (CVAL,RVAL)
      REAL*8       VAL,RVAL,UPS,TEN

      DATA TEN/10/

C-----------------------------------------------------------------------
C     Statement function to compute BUFR "missing value" for field
C     of length LBIT bits (all bits "on"):

      LPS(LBIT) = MAX(2**(LBIT)-1,1)

C     Statement function to decode the encoded BUFR value IVAL according
C     to the scale and reference values that are stored within index NODE
C     of the internal arrays ISC(*) and IRF(*):

      UPS(NODE) = (IVAL+IRF(NODE))*TEN**(-ISC(NODE))
C-----------------------------------------------------------------------

C  SETUP THE SUBSET TEMPLATE
C  -------------------------

      CALL USRTPL(LUN,1,1)

C  UNCOMPRESS A SUBSET INTO THE VAL ARRAY ACCORDING TO TABLE B
C  -----------------------------------------------------------

      NSBS = NSUB(LUN)

C     Note that we are going to unpack the (NSBS)th subset from within
C     the current BUFR message.

      IBIT = MBYT(LUN)

C     Loop through each element of the subset.

      N = 0

1     DO N=N+1,NVAL(LUN)
      NODE = INV(N,LUN)
      NBIT = IBT(NODE)
      ITYP = ITP(NODE)

C     In each of the following code blocks, the "local reference value"
C     for the element is determined first, followed by the 6-bit value
C     which indicates how many bits are used to store the increment
C     (i.e. offset) from this "local reference value".  Then, we jump
C     ahead to where this increment is stored for this particular subset,
C     unpack it, and add it to the "local reference value" to determine
C     the final uncompressed value for this element from this subset.

C     Note that, if an element has the same final uncompressed value
C     for each subset in the message, then the encoding rules for BUFR
C     compression dictate that the "local reference value" will be equal
C     to this value, the 6-bit increment length indicator will have
C     a value of zero, and the actual increments themselves will be
C     omitted from the message.

      IF(ITYP.EQ.1.OR.ITYP.EQ.2) THEN

C        This is a numeric element.

         CALL UPB(LREF,NBIT,MBAY(1,LUN),IBIT)
         CALL UPB(LINC,   6,MBAY(1,LUN),IBIT)
         JBIT = IBIT + LINC*(NSBS-1)
         CALL UPB(NINC,LINC,MBAY(1,LUN),JBIT)
         IF(NINC.EQ.LPS(LINC)) NINC = LPS(NBIT)
         IVAL = LREF+NINC
         if(ityp.eq.1) then
            call usrtpl(lun,n,ival)
            goto 1
         endif
         IF(IVAL.LT.LPS(NBIT)) VAL(N,LUN) = UPS(NODE)
         IBIT = IBIT + LINC*MSUB(LUN)
      ELSEIF(ITYP.EQ.3) THEN

C        This is a character element.

         CALL UPC(CREF,NBIT/8,MBAY(1,LUN),IBIT)
         CALL UPB(LINC,   6,MBAY(1,LUN),IBIT)
         JBIT = IBIT + LINC*(NSBS-1)*8
         CALL UPC(CVAL,LINC,MBAY(1,LUN),JBIT)
         VAL(N,LUN) = RVAL
         IBIT = IBIT + 8*LINC*MSUB(LUN)
      ENDIF
      ENDDO

      RETURN
      END
      SUBROUTINE RDMEMM(IMSG,SUBSET,JDATE,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    RDMEMM
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE READS A PARTICULAR BUFR MESSAGE FROM
C   INTERNAL MEMORY (ARRAY MSGS IN COMMON BLOCK /MSGMEM/) INTO A
C   MESSAGE BUFFER (ARRAY MBAY IN COMMON BLOCK /BITBUF/).  IT IS
C   IDENTICAL TO BUFR ARCHIVE LIBRARY SUBROUTINE READMM EXCEPT IT DOES
C   NOT ADVANCE THE VALUE OF IMSG PRIOR TO RETURNING TO CALLING
C   PROGRAM.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"; MODIFIED TO MAKE Y2K
C                           COMPLIANT
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI); THE MAXIMUM
C                           NUMBER OF BYTES REQUIRED TO STORE ALL
C                           MESSAGES INTERNALLY WAS INCREASED FROM 4
C                           MBYTES TO 8 MBYTES
C 2000-09-19  J. WOOLLEN -- REMOVED MESSAGE DECODING LOGIC THAT HAD
C                           BEEN REPLICATED IN THIS AND OTHER READ
C                           ROUTINES AND CONSOLIDATED IT INTO A NEW
C                           ROUTINE CKTABA, CALLED HERE, WHICH IS
C                           ENHANCED TO ALLOW COMPRESSED AND STANDARD
C                           BUFR MESSAGES TO BE READ; MAXIMUM MESSAGE
C                           LENGTH INCREASED FROM 10,000 TO 20,000
C                           BYTES
C 2001-08-15  D. KEYSER  -- PARAMETER MAXMEM (THE MAXIMUM NUMBER OF
C                           BYTES REQUIRED TO STORE ALL MESSAGES
C                           INTERNALLY) WAS INCREASED FROM 8 MBYTES TO
C                           16 MBYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- PARAMETER MAXMSG (THE MAXIMUM NUMBER OF
C                           BUFR MESSAGES WHICH CAN BE STORED
C                           INTERNALLY) INCREASED FROM 50000 TO 200000;
C                           UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY OR UNUSUAL THINGS
C                           HAPPEN
C
C USAGE:    CALL RDMEMM (IMSG, SUBSET, JDATE, IRET)
C   INPUT ARGUMENT LIST:
C     IMSG     - INTEGER: POINTER TO BUFR MESSAGE NUMBER (RECORD) IN
C                         STORAGE
C                       0 = resets the memory file
C
C   OUTPUT ARGUMENT LIST:
C     SUBSET   - CHARACTER*8: TABLE A MNEMONIC FOR TYPE OF BUFR MESSAGE
C                BEING READ
C     JDATE    - INTEGER: DATE-TIME STORED WITHIN SECTION 1 OF BUFR
C                MESSAGE BEING READ, IN FORMAT OF EITHER YYMMDDHH OR
C                YYYYMMDDHH, DEPENDING ON DATELEN() VALUE
C     IRET     - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = IMSG is either zero or greater than the
C                           number of messages in memory
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    NOTE THAT UFBMEM IS CALLED PRIOR TO THIS TO STORE THE BUFR
C    MESSAGES INTO INTERNAL MEMORY.
C
C    THIS ROUTINE CALLS:        BORT     CKTABA   STATUS   WTSTAT
C    THIS ROUTINE IS CALLED BY: UFBMMS   UFBMNS   UFBRMS   UFBTAM
C                               Also called by application programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXMSG=200000,MAXMEM=16000000)
      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /MSGMEM/ MUNIT,MLAST,MSGP(0:MAXMSG),MSGS(MAXMEM)
      COMMON /QUIET / IPRT

      CHARACTER*8 SUBSET

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  CHECK THE MESSAGE REQUEST AND FILE STATUS
C  -----------------------------------------

      CALL STATUS(MUNIT,LUN,IL,IM)
      CALL WTSTAT(MUNIT,LUN,IL, 1)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      IRET = 0

      IF(IMSG.EQ.0 .OR.IMSG.GT.MSGP(0)) THEN
         CALL WTSTAT(MUNIT,LUN,IL,0)
         IF(IPRT.GE.1) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
            IF(IMSG.EQ.0)  THEN
               PRINT*, 'BUFRLIB: RDMEMM - REQUESTED MEMORY MESSAGE ',
     .          'NUMBER {FIRST (INPUT) ARGUMENT} IS 0, RETURN WITH ',
     .          'IRET = -1'
            ELSE
               PRINT*, 'BUFRLIB: RDMEMM - REQ. MEMORY MESSAGE NO. {',
     .          IMSG,' - {1ST (INPUT) ARG.} > NO. OF MESSAGES IN ',
     .          'MEMORY (',MSGP(0),'), RETURN WITH IRET = -1'
            ENDIF
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
         IRET = -1
         GOTO 100
      ENDIF

C  READ MEMORY MESSAGE NUMBER IMSG INTO A MESSAGE BUFFER
C  -----------------------------------------------------

      IPTR = MSGP(IMSG)
      IF(IMSG.LT.MSGP(0)) LPTR = MSGP(IMSG+1)-IPTR
      IF(IMSG.EQ.MSGP(0)) LPTR = MLAST-IPTR+1
      IPTR = IPTR-1

      DO I=1,LPTR
      MBAY(I,LUN) = MSGS(IPTR+I)
      ENDDO

C  PARSE THE MESSAGE SECTION CONTENTS
C  ----------------------------------

      CALL CKTABA(LUN,SUBSET,JDATE,JRET)
      NMSG(LUN) = IMSG

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: RDMEMM - INPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: RDMEMM - INPUT BUFR FILE IS OPEN FOR '//
     . 'OUTPUT, IT MUST BE OPEN FOR INPUT')
      END
      SUBROUTINE RDMEMS(ISUB,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    RDMEMS
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE READS A PARTICULAR SUBSET FROM A BUFR
C   MESSAGE IN INTERNAL MEMORY (ARRAY MBAY IN COMMON BLOCK /BITBUF/)
C   INTO INTERNAL SUBSET ARRAYS BASED ON THE SUBSET NUMBER IN THE
C   MESSAGE.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1998-10-27  J. WOOLLEN -- MODIFIED TO CORRECT PROBLEMS CAUSED BY IN-
C                           LINING CODE WITH FPP DIRECTIVES
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2001-08-15  D. KEYSER  -- PARAMETER MAXMEM (THE MAXIMUM NUMBER OF
C                           BYTES REQUIRED TO STORE ALL MESSAGES
C                           INTERNALLY) WAS INCREASED FROM 8 MBYTES TO
C                           16 MBYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- PARAMETER MAXMSG (THE MAXIMUM NUMBER OF
C                           BUFR MESSAGES WHICH CAN BE STORED
C                           INTERNALLY) INCREASED FROM 50000 TO 200000;
C                           UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY OR UNUSUAL THINGS
C                           HAPPEN
C
C USAGE:    CALL RDMEMS (ISUB, IRET)
C   INPUT ARGUMENT LIST:
C     ISUB     - INTEGER: POINTER TO SUBSET NUMBER TO READ IN BUFR
C                MESSAGE
C
C   OUTPUT ARGUMENT LIST:
C     IRET     - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = ISUB is greater than the number of subsets
C                           in memory
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     IUPB     READSB   STATUS
C    THIS ROUTINE IS CALLED BY: UFBMMS   UFBMNS   UFBRMS
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXMSG=200000,MAXMEM=16000000)
      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      CHARACTER*128 BORT_STR

      COMMON /MSGMEM/ MUNIT,MLAST,MSGP(0:MAXMSG),MSGS(MAXMEM)
      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /UNPTYP/ MSGUNP(NFILES)
      COMMON /QUIET / IPRT

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  CHECK THE MESSAGE REQUEST AND FILE STATUS
C  -----------------------------------------

      CALL STATUS(MUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      IF(IM.EQ.0) GOTO 902
      IF(NSUB(LUN).NE.0) GOTO 903

      IF(ISUB.GT.MSUB(LUN)) THEN
         IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
         PRINT*, 'BUFRLIB: RDMEMS - REQ. SUBSET NO. {',ISUB,' - FIRST ',
     .    '(INPUT) ARGUMENT} > NO. OF SUBSETS IN MEMORY MESSAGE (',
     .    MSUB(LUN),'), RETURN WITH IRET = -1'
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
         IRET = -1
         GOTO 100
      ENDIF

      MBYM = MBYT(LUN)
      NBYT = 0

C  POSITION TO SUBSET NUMBER ISUB IN MEMORY MESSAGE
C  ------------------------------------------------

      IF(MSGUNP(LUN).EQ.0) THEN
         NSUB(LUN) = ISUB-1
         DO I=1,ISUB-1
         MBYT(LUN) = MBYT(LUN) + IUPB(MBAY(1,LUN),MBYT(LUN)+1,16)
         ENDDO
      ELSEIF(MSGUNP(LUN).EQ.1) THEN
c  .... message with "standard" Section 3
         DO I=1,ISUB-1
         CALL READSB(MUNIT,IRET)
         ENDDO
      ELSEIF(MSGUNP(LUN).EQ.2) THEN
c  .... compressed message
         NSUB(LUN) = ISUB-1
      ENDIF

C  NOW READ SUBSET NUMBER ISUB FROM MEMORY MESSAGE
C  -----------------------------------------------

      CALL READSB(MUNIT,IRET)
c  .... This should have already been accounted for with stmt. 902 or
c       IRET = -1 above
      IF(IRET.NE.0) GOTO 904

C  RESET SUBSET POINTER BACK TO ZERO (BEGINNING OF MESSAGE) AND RETURN
C  -------------------------------------------------------------------

      MBYT(LUN) = MBYM
      NSUB(LUN) = 0

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: RDMEMS - INPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: RDMEMS - INPUT BUFR FILE IS OPEN FOR '//
     . 'OUTPUT, IT MUST BE OPEN FOR INPUT')
902   CALL BORT('BUFRLIB: RDMEMS - A MEMORY MESSAGE MUST BE OPEN IN '//
     . 'INPUT BUFR FILE, NONE ARE')
903   WRITE(BORT_STR,'("BUFRLIB: RDMEMS - UPON ENTRY, SUBSET POINTER '//
     . 'IN MEMORY MESSAGE IS NOT AT BEGINNING (",I3," SUBSETS HAVE '//
     . 'BEEN READ, SHOULD BE 0)")') NSUB(LUN)
      CALL BORT(BORT_STR)
904   CALL BORT('BUFRLIB: RDMEMS - CALL TO ROUTINE READSB RETURNED '//
     . 'WITH IRET = -1 (EITHER MEMORY MESSAGE NOT OPEN OR ALL '//
     . 'SUBSETS IN MESSAGE READ')
      END
      SUBROUTINE RDMGSB(LUNIT,IMSG,ISUB)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    RDMGSB
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2003-11-04
C
C ABSTRACT: THIS SUBROUTINE OPENS A BUFR FILE IN LOGICAL UNIT LUNIT FOR
C   INPUT OPERATIONS, THEN READS A PARTICULAR SUBSET INTO INTERNAL
C   SUBSET ARRAYS FROM A PARTICULAR BUFR MESSAGE IN A MESSAGE BUFFER.
C   THIS IS BASED ON THE SUBSET NUMBER IN THE MESSAGE AND THE MESSAGE
C   NUMBER IN THE BUFR FILE.  THE MESSAGE NUMBER DOES NOT INCLUDE THE
C   DICTIONARY MESSAGES AT THE BEGINNING OF THE FILE.
C
C PROGRAM HISTORY LOG:
C 2003-11-04  J. WOOLLEN -- ORIGINAL AUTHOR (WAS IN VERIFICATION
C                           VERSION BUT MAY HAVE BEEN IN THE PRODUCTION
C                           VERSION AT ONE TIME AND THEN REMOVED)
C 2003-11-04  D. KEYSER  -- INCORPORATED INTO "UNIFIED" BUFR ARCHIVE
C                           LIBRARY; UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL RDMGSB (LUNIT, IMSG, ISUB)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     IMSG     - INTEGER: POINTER TO BUFR MESSAGE NUMBER TO READ IN
C                BUFR FILE
C     ISUB     - INTEGER: POINTER TO SUBSET NUMBER TO READ IN BUFR
C                MESSAGE
C
C   INPUT FILES:
C     UNIT "LUNIT" - BUFR FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     OPENBF   READMG   READSB
C                               STATUS   UPB
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)

      CHARACTER*128 BORT_STR
      CHARACTER*8   SUBSET

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  OPEN THE FILE AND SKIP TO MESSAGE # IMSG
C  ----------------------------------------

      CALL OPENBF(LUNIT,'IN',LUNIT)
      CALL STATUS(LUNIT,LUN,IL,IM)

      DO I=1,IMSG-1
      READ(LUNIT,ERR=900,END=901)
      ENDDO

      CALL READMG(LUNIT,SUBSET,JDATE,IRET)
      IF(IRET.NE.0) GOTO 901

C  POSITION AT SUBSET # ISUB
C  -------------------------

      DO I=1,ISUB-1
      IF(NSUB(LUN).GT.MSUB(LUN)) GOTO 902
      IBIT = MBYT(LUN)*8
      CALL UPB(NBYT,16,MBAY(1,LUN),IBIT)
      MBYT(LUN) = MBYT(LUN) + NBYT
      NSUB(LUN) = NSUB(LUN) + 1
      ENDDO

      CALL READSB(LUNIT,IRET)
      IF(IRET.NE.0) GOTO 902

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: RDMGSB - ERROR READING MESSAGE '//
     . '(RECORD) NUMBER",I5," IN INPUT BUFR FILE CONNECTED TO UNIT",'//
     . 'I4)')  I,LUNIT
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: RDMGSB - HIT END OF FILE BEFORE '//
     . 'READING REQUESTED MESSAGE NO.",I5," IN BUFR FILE CONNECTED TO'//
     . ' UNIT",I4)')  IMSG,LUNIT
      CALL BORT(BORT_STR)
902   WRITE(BORT_STR,'("BUFRLIB: RDMGSB - ALL SUBSETS READ BEFORE '//
     . 'READING REQ. SUBSET NO.",I3," IN REQ. MSG NO.",I5," IN BUFR '//
     . 'FILE CONNECTED TO UNIT",I4)') ISUB,IMSG,LUNIT
      CALL BORT(BORT_STR)
      END
      SUBROUTINE RDTREE(LUN)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    RDTREE
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE UNPACKS THE NEXT SUBSET FROM THE INTERNAL
C   UNCOMPRESSED MESSAGE BUFFER (ARRAY MBAY IN COMMON BLOCK /BITBUF/)
C   AND STORES THE UNPACKED SUBSET WITHIN THE INTERNAL ARRAY VAL(*,LUN)
C   IN COMMON BLOCK /USRINT/.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-10-27  J. WOOLLEN -- MODIFIED TO CORRECT PROBLEMS CAUSED BY IN-
C                           LINING CODE WITH FPP DIRECTIVES
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2003-11-04  J. WOOLLEN -- FIXED A BUG WHICH COULD ONLY OCCUR WHEN
C                           THE LAST ELEMENT IN A SUBSET IS A CHARACTER
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY)
C
C USAGE:    CALL RDTREE (LUN)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C
C REMARKS:
C    THIS ROUTINE CALLS:        RCSTPL   UPBB     UPC
C    THIS ROUTINE IS CALLED BY: READSB
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /USRBIT/ NBIT(MAXJL),MBIT(MAXJL)

      CHARACTER*10 TAG
      CHARACTER*8  CVAL
      CHARACTER*3  TYP
      DIMENSION    IVAL(MAXJL)
      EQUIVALENCE  (CVAL,RVAL)
      REAL*8       VAL,RVAL,UPS,TEN

      DATA TEN/10./

C-----------------------------------------------------------------------
C     Statement function to compute BUFR "missing value" for field
C     of length IBT(NODE)) bits (all bits "on"):

      MPS(NODE) = 2**(IBT(NODE))-1

C     Statement function to decode the unpacked BUFR value IVAL according
C     to the scale and reference values that are stored within index NODE
C     of the internal arrays ISC(*) and IRF(*):

      UPS(NODE) = (IVAL(N)+IRF(NODE))*TEN**(-ISC(NODE))
C-----------------------------------------------------------------------

C  CYCLE THROUGH A SUBSET SETTING UP THE TEMPLATE
C  ----------------------------------------------

      MBIT(1) = IBIT
      NBIT(1) = 0
      CALL RCSTPL(LUN)

C  UNPACK A SUBSET INTO THE USER ARRAY IVAL
C  ----------------------------------------

      DO N=1,NVAL(LUN)
      CALL UPBB(IVAL(N),NBIT(N),MBIT(N),MBAY(1,LUN))
      ENDDO

C  LOOP THROUGH EACH ELEMENT OF THE SUBSET, CONVERTING THE UNPACKED
C   INTEGERS TO THE PROPER TYPES
C  ----------------------------------------------------------------

      DO N=1,NVAL(LUN)
      NODE = INV(N,LUN)
      IF(ITP(NODE).EQ.1) THEN
c  .... unpacked value is a numeric REPLICATION FACTOR
         VAL(N,LUN) = IVAL(N)
      ELSEIF(ITP(NODE).EQ.2) THEN
c  .... unpacked value is a NUMBER
         IF(IVAL(N).LT.MPS(NODE)) VAL(N,LUN) = UPS(NODE)
      ENDIF
      ENDDO

C  SPECIAL TREATMENT FOR UNPACKED CHARACTERS
C  -----------------------------------------

c  .... DK: Why couldn't this be done in the DO-LOOP above?
      DO N=1,NVAL(LUN)
      NODE = INV(N,LUN)
      IF(ITP(NODE).EQ.3) THEN
         CVAL = ' '
         KBIT = MBIT(N)
         CALL UPC(CVAL,NBIT(N)/8,MBAY(1,LUN),KBIT)
         VAL(N,LUN) = RVAL
      ENDIF
      ENDDO

      IBIT = NBIT(NVAL(LUN))+MBIT(NVAL(LUN))

      RETURN
      END
      SUBROUTINE RDUSDX(LUNDX,LUN)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    RDUSDX
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE READS AND PARSES A FILE CONTAINING A USER-
C   SUPPLIED BUFR DICTIONARY TABLE IN CHARACTER FORMAT, AND THEN STORES
C   THIS INFORMATION INTO INTERNAL ARRAYS IN COMMON BLOCK /TABABD/ (SEE
C   REMARKS FOR CONTENTS OF INTERNAL ARRAYS).  THIS SUBROUTINE PERFORMS
C   A FUNCTION SIMILAR TO BUFR ARCHIVE LIBRARY SUBROUTINE RDBFDX,
C   EXECPT THAT RDBFDX READS THE BUFR TABLE DIRECTLY FROM MESSAGES AT
C   BEGINNING OF AN INPUT BUFR FILE.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1995-06-28  J. WOOLLEN -- INCREASED THE SIZE OF INTERNAL BUFR TABLE
C                           ARRAYS IN ORDER TO HANDLE BIGGER FILES
C 1996-12-17  J. WOOLLEN -- FIXED FOR SOME MVS COMPILER'S TREATMENT OF
C                           INTERNAL READS (INCREASES PORTABILITY)
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"; CORRECTED SOME MINOR ERRORS
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY; CHANGED CALL FROM BORT TO BORT2
C
C USAGE:    CALL RDUSDX (LUNDX, LUN)
C   INPUT ARGUMENT LIST:
C     LUNDX    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR USER-
C                SUPPLIED BUFR DICTIONARY TABLE IN CHARACTER FORMAT
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C
C   INPUT FILES:
C     UNIT "LUNDX" - USER-SUPPLIED BUFR DICTIONARY TABLE IN CHARACTER
C                    FORMAT
C
C REMARKS:
C    CONTENTS OF INTERNAL ARRAYS WRITTEN INTO COMMON BLOCK /TABABD/:
C
C     For Table A entries:
C        NTBA(LUN)     - INTEGER: Number of Table A entries (note that
C                        NTBA(0) contains the maximum number of such
C                        entries as set within subroutine BFRINI)
C        TABA(N,LUN)   - CHARACTER*128: Table A entries, where
C                        N=1,2,3,...,NTBA(LUN)
C        IDNA(N,LUN,1) - INTEGER: Message type corresponding to
C                        TABA(N,LUN)
C        IDNA(N,LUN,2) - INTEGER: Message subtype corresponding to
C                        TABA(N,LUN)
C
C     For Table B entries:
C        NTBB(LUN)     - INTEGER: Number of Table B entries (note that
C                        NTBB(0) contains the maximum number of such
C                        entries as set within subroutine BFRINI)
C        TABB(N,LUN)   - CHARACTER*128: Table B entries, where
C                        N=1,2,3,...,NTBB(LUN)
C        IDNB(N,LUN)   - INTEGER: Bit-wise representation of the FXY
C                        value corresponding to TABB(N,LUN)
C
C     For Table D entries:
C        NTBD(LUN)     - INTEGER: Number of Table D entries (note that
C                        NTBD(0) contains the maximum number of such
C                        entries as set within subroutine BFRINI)
C        TABD(N,LUN)   - CHARACTER*600: Table D entries, where
C                        N=1,2,3,...,NTBD(LUN)
C        IDND(N,LUN)   - INTEGER: Bit-wise representation of the FXY
C                        value corresponding to TABD(N,LUN)
C
C
C    THIS ROUTINE CALLS:        BORT2    DIGIT    DXINIT   ELEMDX
C                               IFXY     MAKESTAB NEMOCK   NENUAA
C                               NENUBD   NUMBCK   SEQSDX
C    THIS ROUTINE IS CALLED BY: CKTABA   READDX
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MAXTBA=50)
      PARAMETER (MAXTBB=250)
      PARAMETER (MAXTBD=250)

      COMMON /TABABD/ NTBA(0:NFILES),NTBB(0:NFILES),NTBD(0:NFILES),
     .                MTAB(MAXTBA,NFILES),IDNA(MAXTBA,NFILES,2),
     .                IDNB(MAXTBB,NFILES),IDND(MAXTBD,NFILES),
     .                TABA(MAXTBA,NFILES),TABB(MAXTBB,NFILES),
     .                TABD(MAXTBD,NFILES)

      CHARACTER*600 TABD
      CHARACTER*128 BORT_STR1,BORT_STR2
      CHARACTER*128 TABB
      CHARACTER*128 TABA
      CHARACTER*80  CARD
      CHARACTER*8   NEMO
      CHARACTER*6   NUMB
      LOGICAL       DIGIT

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  INITIALIZE THE DICTIONARY TABLE CONTROL WORD PARTITION ARRAYS
C   WITH APRIORI TABLE B AND D ENTRIES
C  --------------------------------------------------------------

      CALL DXINIT(LUN,1)
      REWIND LUNDX

C  READ USER CARDS UNTIL THERE ARE NO MORE
C  ---------------------------------------

1     READ(LUNDX,'(A80)',END=200) CARD

C  REREAD IF NOT A DEFINITION CARD
C  -------------------------------

c  .... This is a comment line
      IF(CARD(1: 1).EQ.       '*') GOTO 1
c  .... This is a separation line
      IF(CARD(3:10).EQ.'--------') GOTO 1
c  .... This is a blank line
      IF(CARD(3:10).EQ.'        ') GOTO 1
c  .... This is a header line
      IF(CARD(3:10).EQ.'MNEMONIC') GOTO 1
c  .... This is a header line
      IF(CARD(3:10).EQ.'TABLE  D') GOTO 1
c  .... This is a header line
      IF(CARD(3:10).EQ.'TABLE  B') GOTO 1

C  PARSE A DESCRIPTOR DEFINITION CARD
C  ----------------------------------

      IF(CARD(12:12).EQ.'|' .AND. CARD(21:21).EQ.'|') THEN

c  .... NEMO is the 8-character mnemonic name
         NEMO = CARD(3:10)
         IRET=NEMOCK(NEMO)
         IF(IRET.EQ.-1) GOTO 900
         IF(IRET.EQ.-2) GOTO 901

c  .... NEMB is the 6-character FXY value corresponding to NEMO
         NUMB = CARD(14:19)
         IRET=NUMBCK(NUMB)
         IF(IRET.EQ.-1) GOTO 902
         IF(IRET.EQ.-2) GOTO 903
         IF(IRET.EQ.-3) GOTO 904
         IF(IRET.EQ.-4) GOTO 905

C  TABLE A DESCRIPTOR FOUND
C  ------------------------

         IF(NUMB(1:1).EQ.'A') THEN

            N = NTBA(LUN)+1
            IF(N.GT.NTBA(0)) GOTO 906
            CALL NENUAA(NEMO,NUMB,LUN)
c  .... Y value from descriptor
            TABA(N,LUN)( 1: 3) = NUMB(4:6)
c  .... Mnemonic
            TABA(N,LUN)( 4:11) = NEMO
c  .... Description
            TABA(N,LUN)(13:67) = CARD(23:77)
            NTBA(LUN) = N

            IF(DIGIT(NEMO(3:8))) THEN
c  .... Message type & subtype obtained directly from Table A menmonic
               READ(NEMO,'(2X,2I3)') MTYP,MSBT
               IDNA(N,LUN,1) = MTYP
               IDNA(N,LUN,2) = MSBT
            ELSE
c  .... Message type obtained from Y value of Table A seq. descriptor
c       Message subtype hardwired to ZERO
               READ(NUMB(4:6),'(I3)') IDNA(N,LUN,1)
               IDNA(N,LUN,2) = 0
            ENDIF
c  .... Replace "A" with "3" so Table D descriptor  will be found in
c       card as well (below)
            NUMB(1:1) = '3'

         ENDIF

C  TABLE B DESCRIPTOR FOUND
C  ------------------------

         IF(NUMB(1:1).EQ.'0') THEN

            N = NTBB(LUN)+1
            IF(N.GT.NTBB(0)) GOTO 907
            CALL NENUBD(NEMO,NUMB,LUN)
c  .... Integer representation of FXY descriptor
            IDNB(N,LUN) = IFXY(NUMB)
c  .... Character representation of FXY descriptor
            TABB(N,LUN)( 1: 6) = NUMB
c  .... Mnemonic
            TABB(N,LUN)( 7:14) = NEMO
c  .... Description
            TABB(N,LUN)(16:70) = CARD(23:77)
            NTBB(LUN) = N
            GOTO 1

         ENDIF

C  TABLE D DESCRIPTOR FOUND
C  ------------------------

         IF(NUMB(1:1).EQ.'3') THEN

            N = NTBD(LUN)+1
            IF(N.GT.NTBD(0)) GOTO 908
            CALL NENUBD(NEMO,NUMB,LUN)
c  .... Integer representation of FXY descriptor
            IDND(N,LUN) = IFXY(NUMB)
c  .... Character representation of FXY descriptor
            TABD(N,LUN)( 1: 6) = NUMB
c  .... Mnemonic
            TABD(N,LUN)( 7:14) = NEMO
c  .... Description
            TABD(N,LUN)(16:70) = CARD(23:77)
            NTBD(LUN) = N
            GOTO 1

         ENDIF

c  .... DK: This should never happen because GOTO 902 from above will
c           occur first
         GOTO 902

      ENDIF

C  PARSE A SEQUENCE DEFINITION CARD
C  --------------------------------

      IF(CARD(12:12).EQ.'|' .AND. CARD(19:19).NE.'|') THEN
         CALL SEQSDX(CARD,LUN)
         GOTO 1
      ENDIF

C  PARSE AN ELEMENT DEFINITION CARD
C  --------------------------------

      IF(CARD(12:12).EQ.'|' .AND. CARD(19:19).EQ.'|') THEN
         CALL ELEMDX(CARD,LUN)
         GOTO 1
      ENDIF

C  CAN'T FIGURE OUT WHAT KIND OF CARD IT IS
C  ----------------------------------------

      GOTO 909

C  NORMAL ENDING
C  -------------

200   CALL MAKESTAB

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR1,'("BUFRLIB: RDUSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"MNEMONIC ",A," IN USER DICTIONARY IS NOT'//
     . ' BETWEEN 1 AND 8 CHARACTERS")') NEMO
      CALL BORT2(BORT_STR1,BORT_STR2)
901   WRITE(BORT_STR1,'("BUFRLIB: RDUSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"MNEMONIC ",A," IN USER DICTIONARY HAS '//
     . 'INVALID CHARACTERS")') NEMO
      CALL BORT2(BORT_STR1,BORT_STR2)
902   WRITE(BORT_STR1,'("BUFRLIB: RDUSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"DESCRIPTOR NUMBER ",A," IN USER '//
     . 'DICTIONARY HAS AN INVALID FIRST CHARACTER (F VALUE) - MUST BE'//
     . ' A, 0 OR 3")') NUMB
      CALL BORT2(BORT_STR1,BORT_STR2)
903   WRITE(BORT_STR1,'("BUFRLIB: RDUSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"DESCRIPTOR NUMBER ",A," IN USER '//
     . 'DICTIONARY HAS NON-NUMERIC VALUES IN CHARACTERS 2-6 (X AND Y '//
     . 'VALUES)")') NUMB
      CALL BORT2(BORT_STR1,BORT_STR2)
904   WRITE(BORT_STR1,'("BUFRLIB: RDUSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"DESCRIPTOR NUMBER ",A," IN USER '//
     . 'DICTIONARY HAS INVALID NUMBER IN CHARACTERS 2-3 (X VALUE) - '//
     . 'MUST BE BETWEEN 00 AND 63")') NUMB
      CALL BORT2(BORT_STR1,BORT_STR2)
905   WRITE(BORT_STR1,'("BUFRLIB: RDUSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"DESCRIPTOR NUMBER ",A," IN USER '//
     . 'DICTIONARY HAS INVALID NUMBER IN CHARACTERS 4-6 (Y VALUE) - '//
     . 'MUST BE BETWEEN 000 AND 255")') NUMB
      CALL BORT2(BORT_STR1,BORT_STR2)
906   WRITE(BORT_STR1,'("BUFRLIB: RDUSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"THE NUMBER OF TABLE A ENTRIES IN USER '//
     . 'DICTIONARY EXCEEDS THE LIMIT (",I4,")")') NTBA(0)
      CALL BORT2(BORT_STR1,BORT_STR2)
907   WRITE(BORT_STR1,'("BUFRLIB: RDUSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"THE NUMBER OF TABLE B ENTRIES IN USER '//
     . 'DICTIONARY EXCEEDS THE LIMIT (",I4,")")') NTBB(0)
      CALL BORT2(BORT_STR1,BORT_STR2)
908   WRITE(BORT_STR1,'("BUFRLIB: RDUSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"THE NUMBER OF TABLE D ENTRIES IN USER '//
     . 'DICTIONARY EXCEEDS THE LIMIT (",I4,")")') NTBD(0)
      CALL BORT2(BORT_STR1,BORT_STR2)
909   WRITE(BORT_STR1,'("BUFRLIB: RDUSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"THIS CARD HAS A BAD FORMAT - IT IS NOT '//
     . 'RECOGNIZED BY THIS SUBROUTINE")')
      CALL BORT2(BORT_STR1,BORT_STR2)
      END
      SUBROUTINE READ2C(LUN,MROW,MATX,CATX,ITYP,IWID,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    READ2C
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2003-11-04
C
C ABSTRACT: THIS SUBROUTINE READS A SUBSET INTO COMPRESSION MAXTRIX
C   ARRAYS IN PREPARATION FOR GENERATING COMPRESSED BUFR MESSAGES.
C
C PROGRAM HISTORY LOG:
C 2003-11-04  J. WOOLLEN -- ORIGINAL AUTHOR (WAS IN-LINE IN PROGRAM
C                           BUFR_COMPRESS)
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY OR UNUSUAL THINGS HAPPEN
C
C USAGE:    CALL READ2C (LUN, MROW, MATX, CATX, ITYP, IWID, IRET)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     MROW     - INTEGER: NUMBER OF ROWS IN COMPRESSION MATRIX
C
C   OUTPUT ARGUMENT LIST:
C     MATX     - INTEGER: MROW-WORD COMPRESSION MATRIX ARRAY CONTAINING
C                NUMERIC ELEMENTS FOR A SUBSET
C     CATX     - CHARACTER*8: MROW-WORD COMPRESSION MATRIX ARRAY
C                CONTAINING CHARACTER ELEMENTS FOR A SUBSET
C     ITYP     - INTEGER: MROW-WORD COMPRESSION MATRIX ARRAY CONTAINING
C                SUBSET ELEMENT TYPES (E.G., NUMBER, REPLICATION
C                FACTOR, CHARACTER, ETC.)
C     IWID     - INTEGER: MROW-WORD COMPRESSION MAXTRIX CONTAINING
C                SUBSET ELEMENT BIT WIDTHS
C     IRET     - INTEGER: NUMBER OF ELEMENTS IN SUBSET TEMPLATE
C                      -1 = there are no more subsets in the BUFR
C                           message
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     RCSTPL   UPB      UPC
C    THIS ROUTINE IS CALLED BY: COMPRES
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$
 
      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /USRBIT/ NBIT(MAXJL),MBIT(MAXJL)
      COMMON /REDWRT/ READIT,WRITIT
      COMMON /QUIET / IPRT
 
      CHARACTER*128 BORT_STR
      CHARACTER*10  TAG
      CHARACTER*8   CATX(MROW),SUBSET
      CHARACTER*3   TYP
      DIMENSION     MATX(MROW),ITYP(MROW),IWID(MROW)
      REAL*8        VAL
      LOGICAL       READIT,WRITIT,RCOPY
 
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IF(NSUB(LUN).EQ.0) READIT = .TRUE.
      RCOPY = READIT
 
C  SEE IF THERE IS ANOTHER SUBSET - IF SO READ IT
C  ----------------------------------------------
 
      IF(READIT) THEN
         IF(NSUB(LUN).EQ.MSUB(LUN)) THEN
            IRET = -1
            GOTO 100
         ELSE
            IBIT = MBYT(LUN)*8
            CALL UPB(NBYT,16,MBAY(1,LUN),IBIT)
            MBIT(1) = IBIT
            NBIT(1) = 0
            CALL RCSTPL(LUN)
            IF(NVAL(LUN).GT.MROW) GO TO 900
            MBYT(LUN) = MBYT(LUN) + NBYT
            NSUB(LUN) = NSUB(LUN) + 1
            DO I=1,NVAL(LUN)
            NODE = INV(I,LUN)
            ITYP(I) = ITP(NODE)
            IWID(I) = IBT(NODE)
            IF(IPRT.GE.2) THEN
            if(ityp(i).eq.1) print*,'typ=1 ',tag(node) 
            ENDIF
            ENDDO
         ENDIF
      ELSE
         READIT = .TRUE.
      ENDIF
 
C  STORE THE DATA FROM THIS SUBSET
C  -------------------------------

      SUBSET = TAG(INODE(LUN))

      DO I=1,NVAL(LUN)
      LBIT = MBIT(I)
ccccc IF(ITYP(I).EQ.1) THEN
ccccc    node = inv(i,lun)
ccccc    print*,tag(node),' ',itp(node),nsub(lun),msub(lun),rcopy
ccccc    PRINT*,'INCOMPRESSABLE MESSAGE TYPE ',SUBSET
ccccc    IRET = -2
ccccc    GOTO 100
      IF(ITYP(I).EQ.1.OR.ITYP(I).EQ.2) THEN
         CALL UPB(MATX(I),NBIT(I),MBAY(1,LUN),LBIT)
      ELSEIF(ITYP(I).EQ.3) THEN
         CALL UPC(CATX(I),NBIT(I)/8,MBAY(1,LUN),LBIT)
      ENDIF
      ENDDO
 
      IRET = NVAL(LUN)

C  EXITS
C  -----

100   RETURN
900   WRITE(BORT_STR,'("BUFRLIB: READ2C - NO. OF ROWS IN COMPRESSION '//
     . 'MATRIX (",I6,") TOO SMALL (< NO. OF ELEMENTS IN SUBSET,",I6,'//
     . '"), MSG TYPE ",A8)') MROW,NVAL(LUN),SUBSET
      CALL BORT(BORT_STR)
      END
      SUBROUTINE READDX(LUNIT,LUN,LUNDX)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    READDX
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE GENERATES INTERNAL ARRAYS CONTAINING BUFR
C   DICTIONARY TABLES WHICH ARE NEEDED TO READ, WRITE, INITIALIZE OR
C   APPEND A BUFR FILE.  THE INFORMATION USED TO CREATE THE INTERNAL
C   DICTIONARY TABLE ARRAYS (IN COMMON BLOCK /TABABD/) AND THE
C   DICTIONARY MESSAGE CONTROL WORD PARTITION ARRAYS (IN COMMON BLOCK
C   /MSGCWD/) (WHICH ARE ALWAYS THEN ASSOCIATED WITH THE BUFR FILE IN
C   LUNIT) MAY COME FROM AN EXTERNAL, USER-SUPPLIED, BUFR DICTIONARY
C   TABLE FILE IN CHARACTER FORMAT (I.E., A BUFR MNEMONIC TABLE), FROM
C   THE BUFR FILE BEING ACTED UPON (IN WHICH CASE THE FILE MUST BE
C   OPENED FOR INPUT PROCESSING AND POSITIONED AT A DICTIONARY TABLE
C   MESSAGE SOMEWHERE IN THE FILE), OR FROM ANOTHER CURRENTLY OPENED
C   AND DEFINED BUFR FILE.  IN THIS LATTER CASE, THE BUFR FILE WOULD
C   MOST LIKELY BE OPENED FOR INPUT, HOWEVER THERE IS NOTHING
C   PREVENTING THE USE OF A FILE OPEN FOR OUTPUT AS LONG AS IT IS
C   ASSOCIATED WITH INTERNAL DICTIONARY ARRAYS THAT CAN BE USED.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY OR FOR INFORMATIONAL
C                           PURPOSES
C
C USAGE:    CALL READDX (LUNIT, LUN, LUNDX)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C                BEING READ, WRITTEN, INITIALIZED OR APPENDED
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C                (ASSOCIATED WITH FILE CONNECTED TO LOGICAL UNIT LUNIT)
C     LUNDX    - INTEGER: FORTRAN LOGICAL UNIT NUMBER CONTAINING
C                DICTIONARY TABLE INFORMATION TO BE USED IN READING/
C                WRITING FROM/TO LUNIT (DEPENDING ON THE CASE); MAY BE
C                SET EQUAL TO LUNIT IF DICTIONARY TABLE INFORMATION IS
C                ALREADY EMBEDDED IN LUNIT (BUT ONLY IF LUNIT IS BEING
C                READ)
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     CPBFDX   RDBFDX   RDUSDX
C                               STATUS
C    THIS ROUTINE IS CALLED BY: OPENBF   WRITDX
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /QUIET/ IPRT

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  GET THE BUFR STATUS OF UNIT LUNDX
C  ---------------------------------

      CALL STATUS(LUNDX,LUD,ILDX,IMDX)

C  READ A DICTIONARY TABLE FROM THE INDICATED SOURCE
C  -------------------------------------------------

      IF (LUNIT.EQ.LUNDX) THEN
c  .... Source is input BUFR file in LUNIT
         IF(IPRT.GE.2) PRINT100,LUNDX
         REWIND LUNIT
         CALL RDBFDX(LUNIT,LUN)
      ELSEIF(ILDX.EQ.-1) THEN
c  .... Source is input BUFR file in LUNDX
c       BUFR file in LUNIT may be in- or output
         IF(IPRT.GE.2) PRINT101,LUNDX,LUNIT
         CALL CPBFDX(LUD,LUN)
      ELSEIF(ILDX.EQ.1) THEN
c  .... Source is output BUFR file in LUNDX
c       BUFR file in LUNIT may be in- or output
         IF(IPRT.GE.2) PRINT102,LUNDX,LUNIT
         CALL CPBFDX(LUD,LUN)
      ELSEIF(ILDX.EQ.0) THEN
c  .... Source is user-suppl char. tbl in LUNDX
c       BUFR file in LUNIT may be in- or output
         IF(IPRT.GE.2) PRINT103,LUNDX
         REWIND LUNDX
         CALL RDUSDX(LUNDX,LUN)
      ELSE
         GOTO 900
      ENDIF

100   FORMAT(/17('+'),'BUFR ARCHIVE LIBRARY',20('+')/'BUFRLIB: READDX ',
     . '- READING BUFR DICTIONARY TABLE FROM INPUT BUFR FILE IN UNIT ',
     . I2,' INTO INTERNAL ARRAYS'/17('+'),'BUFR ARCHIVE LIBRARY',20('+')
     . /)
101   FORMAT(/17('+'),'BUFR ARCHIVE LIBRARY',20('+')/'BUFRLIB: READDX ',
     . '- COPYING BUFR DCTY TBL FROM INTERNAL ARRAYS ASSOC. W/ INPUT ',
     . 'FILE IN UNIT ',I2,' TO THOSE ASSOC. W/ FILE IN UNIT ',I2/
     . 17('+'),'BUFR ARCHIVE LIBRARY',20('+')/)
102   FORMAT(/17('+'),'BUFR ARCHIVE LIBRARY',20('+')/'BUFRLIB: READDX ',
     . '- COPYING BUFR DCTY TBL FROM INTERNAL ARRAYS ASSOC. W/ OUTPUT ',
     . 'FILE IN UNIT ',I2,' TO THOSE ASSOC. W/ FILE IN UNIT ',I2/
     . 17('+'),'BUFR ARCHIVE LIBRARY',20('+')/)
103   FORMAT(/17('+'),'BUFR ARCHIVE LIBRARY',20('+')/'BUFRLIB: READDX ',
     . '- READING BUFR DICTIONARY TABLE FROM USER-SUPPLIED TEXT FILE ',
     . 'IN UNIT ',I2,' INTO INTERNAL ARRAYS'/17('+'),'BUFR ARCHIVE ',
     . 'LIBRARY',20('+')/)

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: READDX - CANNOT DETERMINE SOURCE OF '//
     . 'INPUT DICTIONARY TABLE')
      END
      SUBROUTINE READERM(LUNIT,SUBSET,JDATE,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    READERM
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE READS THE NEXT BUFR MESSAGE FROM LOGICAL
C   UNIT NUMBER LUNIT INTO A MESSAGE BUFFER (ARRAY MBAY IN COMMON
C   BLOCK /BITBUF/), WHICH SHOULD ITSELF HAVE ALREADY BEEN OPENED FOR
C   INPUT OPERATIONS.  IT IS SIMILAR TO BUFR ARCHIVE LIBRARY SUBROUTINE
C   READMG BUT IS DESIGNED TO READ FOREIGN (NON-NCEP) BUFR MESSAGES
C   WHICH MAY NOT BE PADDED.  THIS SUBROUTINE DOES NOT WORK PROPERLY ON
C   ALL PLATFORMS (E.G., IBM) AND SHOULD BE REPLACED WITH BUFR ARCHIVE
C   LIBRARY SUBROUTINE READIBM IN ALL APPLICATION PROGRAMS.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"; IMPROVED MACHINE
C                           PORTABILITY
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI); INCREASED THE
C                           THE MAXIMUM NUMBER OF POSSIBLE DESCRIPTORS
C                           IN A SUBSET FROM 1000 TO 3000
C 2000-09-19  J. WOOLLEN -- REMOVED MESSAGE DECODING LOGIC THAT HAD
C                           BEEN REPLICATED IN THIS AND OTHER READ
C                           ROUTINES AND CONSOLIDATED IT INTO A NEW
C                           ROUTINE CKTABA, CALLED HERE, WHICH IS
C                           ENHANCED TO ALLOW COMPRESSED AND STANDARD
C                           BUFR MESSAGES TO BE READ (ROUTINE UNCMPS,
C                           WHICH HAD BEEN CALLED BY THIS AND OTHER
C                           ROUTINES IS NOW OBSOLETE AND HAS BEEN
C                           REMOVED FROM THE BUFRLIB; MAXIMUM MESSAGE
C                           LENGTH INCREASED FROM 10,000 TO 20,000
C                           BYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY AND FOR INFORMATIONAL
C                           PURPOSES
C
C USAGE:    CALL READERM (LUNIT, SUBSET, JDATE, IRET)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     SUBSET   - CHARACTER*8: TABLE A MNEMONIC FOR TYPE OF BUFR MESSAGE
C                BEING READ
C     JDATE    - INTEGER: DATE-TIME STORED WITHIN SECTION 1 OF BUFR
C                MESSAGE BEING READ, IN FORMAT OF EITHER YYMMDDHH OR
C                YYYYMMDDHH, DEPENDING ON DATELEN() VALUE
C     IRET     - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = there are no more BUFR messages in LUNIT
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     CKTABA   IRDERM   STATUS
C                               WTSTAT
C    THIS ROUTINE IS CALLED BY: IREADERM
C                               Also called by application programs.
C                               SHOULD BE REPLACED WITH READIBM IN
C                               ALL APPLICATION PROGRAMS!!
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)
      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /QUIET / IPRT

      CHARACTER*8 SUBSET

      DATA IFIRST/0/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IF(IFIRST.EQ.0) THEN
         IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT 101
101   FORMAT(' BUFRLIB: READERM - THIS ROUTINE DOES NOT WORK PROPERLY ',
     . 'ON ALL PLATFORMS - USE READIBM INSTEAD')
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
         IFIRST = 1
      ENDIF

      IRET = 0

C  CHECK THE FILE STATUS
C  ---------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      CALL WTSTAT(LUNIT,LUN,IL, 1)

C  READ A MESSAGE INTO A MESSAGE BUFFER
C  ------------------------------------

1     IF(IRDERM(LUNIT,MBAY(1,LUN)).NE.0) GOTO 200

C  PARSE THE MESSAGE SECTION CONTENTS
C  ----------------------------------

      CALL CKTABA(LUN,SUBSET,JDATE,IRET)
      IF(IRET.NE.0) GOTO 1
      GOTO 100

C  EOF ON ATTEMPTED READ
C  ---------------------

200   CALL WTSTAT(LUNIT,LUN,IL,0)
      INODE(LUN) = 0
      IDATE(LUN) = 0
      SUBSET = ' '
      JDATE = 0
      IRET = -1

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: READERM - INPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: READERM - INPUT BUFR FILE IS OPEN FOR '//
     . 'OUTPUT, IT MUST BE OPEN FOR INPUT')
      END
      SUBROUTINE READERME(MESG,LUNIT,SUBSET,JDATE,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    READERME
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1995-06-28
C
C ABSTRACT: THIS SUBROUTINE READS INFORMATION FROM A BUFR DATA MESSAGE
C   ALREADY IN MEMORY, PASSED IN AS AN INPUT ARGUMENT.  IT IS SIMILAR
C   TO BUFR ARCHIVE LIBRARY SUBROUTINE READMG EXCEPT, INSTEAD OF
C   READING BUFR MESSAGES DIRECTLY FROM A BUFR FILE THAT IS PHYSICALLY
C   STORED ON THE LOCAL SYSTEM AND INTERFACED TO THE SOFTWARE VIA A
C   LOGICAL UNIT NUMBER, IT READS BUFR MESSAGES DIRECTLY FROM A MEMORY
C   ARRAY WITHIN THE APPLICATION PROGRAM ITSELF.  THIS PROVIDES USERS
C   WITH GREATER FLEXIBILITY FROM AN INPUT/OUTPUT PERSPECTIVE.
C   READERME CAN BE USED IN ANY CONTEXT IN WHICH READMG MIGHT OTHERWISE
C   BE USED.  IF THIS MESSAGE IS NOT A BUFR MESSAGE, THEN AN
C   APPROPRIATE CALL IS MADE TO BUFR ARCHIVE LIBRARY SUBROUTINE BORT.
C
C PROGRAM HISTORY LOG:
C 1995-06-28  J. WOOLLEN -- ORIGINAL AUTHOR (FOR ERS DATA)
C 1997-07-29  J. WOOLLEN -- MODIFIED TO PROCESS GOES SOUNDINGS FROM
C                           NESDIS
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"; MODIFIED TO MAKE Y2K
C                           COMPLIANT; IMPROVED MACHINE PORTABILITY
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI); INCREASED THE
C                           MAXIMUM NUMBER OF POSSIBLE DESCRIPTORS IN A
C                           SUBSET FROM 1000 TO 3000
C 2000-09-19  J. WOOLLEN -- REMOVED MESSAGE DECODING LOGIC THAT HAD
C                           BEEN REPLICATED IN THIS AND OTHER READ
C                           ROUTINES AND CONSOLIDATED IT INTO A NEW
C                           ROUTINE CKTABA, CALLED HERE, WHICH IS
C                           ENHANCED TO ALLOW COMPRESSED AND STANDARD
C                           BUFR MESSAGES TO BE READ (ROUTINE UNCMPS,
C                           WHICH HAD BEEN CALLED BY THIS AND OTHER
C                           ROUTINES IS NOW OBSOLETE AND HAS BEEN
C                           REMOVED FROM THE BUFRLIB; MAXIMUM MESSAGE
C                           LENGTH INCREASED FROM 10,000 TO 20,000
C                           BYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL READERME (MESG, LUNIT, SUBSET, JDATE, IRET)
C   INPUT ARGUMENT LIST:
C     MESG     - INTEGER: *-WORD PACKED BINARY ARRAY CONTAINING BUFR
C                MESSAGE
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     SUBSET   - CHARACTER*8: TABLE A MNEMONIC FOR TYPE OF BUFR MESSAGE
C                BEING READ
C     JDATE    - INTEGER: DATE-TIME STORED WITHIN SECTION 1 OF BUFR
C                MESSAGE BEING READ, IN FORMAT OF EITHER YYMMDDHH OR
C                YYYYMMDDHH, DEPENDING ON DATELEN() VALUE
C     IRET     - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = unrecognized Table A message type
C                      11 = this is a BUFR table (dictionary) message
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     CKTABA   LMSG     STATUS
C                               WTSTAT
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)
      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)

      CHARACTER*8 SUBSET,SEC0
      DIMENSION   MESG(*),IEC0(2)
      EQUIVALENCE (SEC0,IEC0)

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IRET = 0

C  CHECK THE FILE STATUS
C  ---------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      CALL WTSTAT(LUNIT,LUN,IL, 1)

C  READ A MESSAGE INTO A MESSAGE BUFFER
C  ------------------------------------

      IEC0(1) = MESG(1)
      IEC0(2) = MESG(2)
      DO I=1,LMSG(SEC0)
      MBAY(I,LUN) = MESG(I)
      ENDDO
      IF(SEC0(1:4).NE.'BUFR') GOTO 902

C  PARSE THE MESSAGE SECTION CONTENTS
C  ----------------------------------

      CALL CKTABA(LUN,SUBSET,JDATE,IRET)

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: READERME - INPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: READERME - INPUT BUFR FILE IS OPEN FOR '//
     . 'OUTPUT, IT MUST BE OPEN FOR INPUT')
902   CALL BORT('BUFRLIB: READERME - FIRST 4 BYTES READ FROM RECORD'//
     . ' NOT "BUFR", DOES NOT CONTAIN BUFR DATA')
      END
      SUBROUTINE READERS(LUNIT,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    READERS
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1996-10-09
C
C ABSTRACT: THIS SUBROUTINE NOW SIMPLY CALLS BUFR ARCHIVE LIBRARY
C   SUBROUTINE READSB, USING THE SAME INPUT AND OUTPUT PARAMETERS (SEE
C   READSB FOR DETAILS).  IT HAD BEEN DIFFERENT THAN READSB AT ONE TIME
C   (SEE PROGRAM HISTORY LOG BELOW) AND MAY STILL BE CALLED BY SOME
C   APPLICATION CODES (THUS THE NEED TO RETAIN IT IN THE BUFR ARCHIVE
C   LIBRARY).
C
C PROGRAM HISTORY LOG:
C 1996-10-09  J. WOOLLEN -- ORIGINAL AUTHOR (WAS USED TO READ ERS
C                           SCATTEROMETER DATA WHICH WAS IN COMPRESSED
C                            BUFR MESSAGES)
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2000-09-19  J. WOOLLEN -- CHANGED TO BECOME AN ENTRY POINT AT THE TOP
C                           OF READSB (ESSENTIALLY AN ALIAS TO READSB)
C                           SINCE READSB CAN NOW HANDLE COMPRESSED BUFR
C                           MESSAGES (THUS READERS NO LONGER CALLS
C                           BUFRLIB ROUTINE RDTRER, AND RDTRER HAS BEEN
C                           REMOVED FROM THE BUFRLIB)
C 2002-05-14  J. WOOLLEN -- CHANGED FROM AN ENTRY POINT TO INCREASE
C                           PORTABILITY TO OTHER PLATFORMS, NOW SIMPLY
C                           CALLS READSB SINCE THE PREVIOUS
C                           IMPLEMENTATION HAD ALREADY MADE IT AN ALIAS
C                           TO READSB
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO FOR
C                           INFORMATIONAL PURPOSES
C
C USAGE:    CALL READERS (LUNIT, IRET)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     IRET     - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = there are no more subsets in the BUFR
C                           message
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        READSB
C    THIS ROUTINE IS CALLED BY: IREADERS
C                               Also called by application programs
C                               (although they should change to call
C                               READSB instead).
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /QUIET / IPRT

      DATA IFIRST/0/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IF(IFIRST.EQ.0) THEN
         IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT 101
101   FORMAT(' BUFRLIB: READERS - THIS ROUTINE SIMPLY CALLS READSB, ',
     . 'REPLACE IT WITH READSB')
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT*
         ENDIF
         IFIRST = 1
      ENDIF

      CALL READSB(LUNIT,IRET)
      RETURN
      END
      SUBROUTINE READFT(LUNIT,SUBSET,JDATE,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    READFT
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1996-10-09
C
C ABSTRACT: THIS SUBROUTINE READS THE NEXT BUFR MESSAGE FROM LOGICAL
C   UNIT NUMBER LUNIT INTO A MESSAGE BUFFER (ARRAY MBAY IN COMMON BLOCK
C   /BITBUF/), WHICH SHOULD ITSELF HAVE ALREADY BEEN OPENED FOR INPUT
C   OPERATIONS.  IT IS IDENTICAL TO BUFR ARCHIVE LIBRARY SUBROUTINE
C   READMG EXCEPT IT DOES NOT CALL BUFR ARCHIVE LIBRARY SUBROUTINE BORT
C   IF THERE IS AN I/O ERROR READING A MESSAGE, INSTEAD IT RETURNS WITH
C   IRET = -1 AND TREATS IT THE SAME AS AN END-OF-FILE.
C
C PROGRAM HISTORY LOG:
C 1996-10-09  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"; MODIFIED TO MAKE Y2K
C                           COMPLIANT
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI); MODIFIED WITH
C                           SEMANTIC ADJUSTMENTS TO AMELIORATE COMPILER
C                           COMPLAINTS FROM LINUX BOXES (INCREASES
C                           PORTABILITY)
C 2000-09-19  J. WOOLLEN -- REMOVED MESSAGE DECODING LOGIC THAT HAD
C                           BEEN REPLICATED IN THIS AND OTHER READ
C                           ROUTINES AND CONSOLIDATED IT INTO A NEW
C                           ROUTINE CKTABA, CALLED HERE, WHICH IS
C                           ENHANCED TO ALLOW COMPRESSED AND STANDARD
C                           BUFR MESSAGES TO BE READ; MAXIMUM MESSAGE
C                           LENGTH INCREASED FROM 10,000 TO 20,000
C                           BYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL READFT (LUNIT, SUBSET, JDATE, IRET)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     SUBSET   - CHARACTER*8: TABLE A MNEMONIC FOR TYPE OF BUFR MESSAGE
C                BEING READ
C     JDATE    - INTEGER: DATE-TIME STORED WITHIN SECTION 1 OF BUFR
C                MESSAGE BEING READ, IN FORMAT OF EITHER YYMMDDHH OR
C                YYYYMMDDHH, DEPENDING ON DATELEN() VALUE
C     IRET     - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = there are no more BUFR messages in LUNIT or
C                           I/O error reading BUFR message
C
C   INPUT FILES:
C     UNIT "LUNIT" - BUFR FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     CHRTRNA  CKTABA   LMSG
C                               STATUS   WTSTAT
C    THIS ROUTINE IS CALLED BY: IREADFT
C                               Also called by application programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)
      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)

      CHARACTER*8 SEC0,SUBSET
      CHARACTER*4 BUFR
      CHARACTER*1 CEC0(8)
      DIMENSION   IEC0(2)
      EQUIVALENCE (SEC0,IEC0,CEC0)

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IRET = 0

C  CHECK THE FILE STATUS
C  ---------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      CALL WTSTAT(LUNIT,LUN,IL, 1)
      IMSG = 8/NBYTW+1

C  READ A MESSAGE INTO A MESSAGE BUFFER - SKIP DICTIONARY MESSAGES
C  ---------------------------------------------------------------

1     SEC0 = ' '
      READ(LUNIT,ERR=200,END=200) SEC0,(MBAY(I,LUN),I=IMSG,LMSG(SEC0))

C     Confirm that the first 4 bytes of SEC0 contain 'BUFR' encoded in
C     CCITT IA5 (i.e. ASCII).

      CALL CHRTRNA(BUFR,CEC0,4)
      IF(BUFR.NE.'BUFR') GOTO 200

C     Copy SEC0 into the front of MBAY so that MBAY now contains the
C     entire BUFR message.

      DO I=1,IMSG-1
      MBAY(I,LUN) = IEC0(I)
      ENDDO

C  PARSE THE MESSAGE SECTION CONTENTS
C  ----------------------------------

      CALL CKTABA(LUN,SUBSET,JDATE,IRET)
      IF(IRET.NE.0) GOTO 1
      GOTO 100

C  EOF OR ERROR ON ATTEMPTED READ
C  ------------------------------

200   CALL WTSTAT(LUNIT,LUN,IL,0)
      INODE(LUN) = 0
      IDATE(LUN) = 0
      SUBSET = ' '
      JDATE = 0
      IRET = -1

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: READFT - INPUT BUFR FILE IS CLOSED, IT MUST'//
     . ' BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: READFT - INPUT BUFR FILE IS OPEN FOR OUTPUT'//
     . ', IT MUST BE OPEN FOR INPUT')
      END
      SUBROUTINE READIBM(LUNIT,SUBSET,JDATE,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    READIBM
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1999-11-18
C
C ABSTRACT: THIS SUBROUTINE READS THE NEXT BUFR MESSAGE FROM LOGICAL
C   UNIT NUMBER LUNIT INTO A MESSAGE BUFFER (ARRAY MBAY IN COMMON BLOCK
C   /BITBUF/), WHICH SHOULD ITSELF HAVE ALREADY BEEN OPENED FOR INPUT
C   OPERATIONS.  IT IS SIMILAR TO BUFR ARCHIVE LIBRARY SUBROUTINE
C   READMG BUT IS DESIGNED TO READ FOREIGN (NON-NCEP) BUFR MESSAGES
C   WHICH MAY NOT BE PADDED.  THIS SUBROUTINE WORKS PROPERLY ON ALL
C   PLATFORMS.  APPLICATION PROGRAMS SHOULD REPLACE CALLS TO THE BUFR
C   ARCHIVE LIBRARY SUBROUTINE ROUTINE READERM (WHICH PERFORMS A
C   SIMILAR FUNCTION) WITH CALLS TO THIS SUBROUTINE BECAUSE READERM
C   DOES NOT WORK PROPERLY ON ALL PLATFORMS (E.G., NCEP IBM-SP).
C
C PROGRAM HISTORY LOG:
C 1999-11-18  J. WOOLLEN -- ORIGINAL AUTHOR (DESIGNED TO REPLACE
C                           EXISTING ROUTINE READERM)
C 2000-09-19  J. WOOLLEN -- REMOVED MESSAGE DECODING LOGIC THAT HAD
C                           BEEN REPLICATED IN THIS AND OTHER READ
C                           ROUTINES AND CONSOLIDATED IT INTO A NEW
C                           ROUTINE CKTABA, CALLED HERE, WHICH IS
C                           ENHANCED TO ALLOW COMPRESSED AND STANDARD
C                           BUFR MESSAGES TO BE READ (ROUTINE UNCMPS,
C                           WHICH HAD BEEN CALLED BY THIS AND OTHER
C                           ROUTINES IS NOW OBSOLETE AND HAS BEEN
C                           REMOVED FROM THE BUFRLIB; MAXIMUM MESSAGE
C                           LENGTH INCREASED FROM 10,000 TO 20,000
C                           BYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL READIBM (LUNIT, SUBSET, JDATE, IRET)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     SUBSET   - CHARACTER*8: TABLE A MNEMONIC FOR TYPE OF BUFR MESSAGE
C                BEING READ
C     JDATE    - INTEGER: DATE-TIME STORED WITHIN SECTION 1 OF BUFR
C                MESSAGE BEING READ, IN FORMAT OF EITHER YYMMDDHH OR
C                YYYYMMDDHH, DEPENDING ON DATELEN() VALUE
C     IRET     - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = there are no more BUFR messages in LUNIT
C
C   INPUT FILES:
C     UNIT "LUNIT" - BUFR FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     CKTABA   IUPM     LMSG
C                               STATUS   WTSTAT
C    THIS ROUTINE IS CALLED BY: IREADIBM
C                               Also called by application programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)
      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)

      CHARACTER*8 SEC0,SUBSET
      CHARACTER*1 CBAY(8*MXMSGL/4)
      DIMENSION   JBAY(MXMSGL/4)
      EQUIVALENCE (CBAY(1),JBAY(1))
      EQUIVALENCE (CBAY(1),SEC0)

C-----------------------------------------------------------------------
      LBMG(SEC0) = IUPM(SEC0(5:7),24)
C-----------------------------------------------------------------------

      IRET = 0

C  CHECK THE FILE STATUS
C  ---------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      CALL WTSTAT(LUNIT,LUN,IL,1)

C  READ A MESSAGE INTO A MESSAGE BUFFER - SKIP DICTIONARY MESSAGES
C  ---------------------------------------------------------------

1     SEC0 = ' '
      READ(LUNIT,ERR=902,END=200) SEC0,(CBAY(I),I=9,LBMG(SEC0))
      DO I=1,8
      CBAY(I) = SEC0(I:I)
      ENDDO
      DO I=1,LMSG(SEC0)
      MBAY(I,LUN) = JBAY(I)
      ENDDO

C  PARSE THE MESSAGE SECTION CONTENTS
C  ----------------------------------

      CALL CKTABA(LUN,SUBSET,JDATE,IRET)
      IF(IRET.NE.0) GOTO 1
      GOTO 100

C  EOF ON ATTEMPTED READ
C  ---------------------

200   CALL WTSTAT(LUNIT,LUN,IL,0)
      INODE(LUN) = 0
      IDATE(LUN) = 0
      SUBSET = ' '
      JDATE = 0
      IRET = -1

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: READIBM - INPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: READIBM - INPUT BUFR FILE IS OPEN FOR '//
     . 'OUTPUT, IT MUST BE OPEN FOR INPUT')
902   CALL BORT('BUFRLIB: READIBM - ERROR READING A BUFR MESSAGE')
      END
      SUBROUTINE READLC(LUNIT,CHR,STR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    READLC
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2003-11-04
C
C ABSTRACT: THIS SUBROUTINE RETURNS A CHARACTER DATA ELEMENT ASSOCIATED
C   WITH A PARTICULAR SUBSET MNEMONIC FROM THE INTERNAL MESSAGE BUFFER
C   (ARRAY MBAY IN COMMON BLOCK /BITBUF/).  IT IS DESIGNED TO BE USED
C   TO RETURN CHARACTER ELEMENTS GREATER THAN THE USUAL LENGTH OF EIGHT
C   BYTES.  IT CURRENTLY WILL NOT WORK FOR COMPRESSED BUFR MESSAGES.
C
C PROGRAM HISTORY LOG:
C 2003-11-04  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY OR UNUSUAL THINGS HAPPEN
C
C USAGE:    CALL READLC (LUNIT, CHR, STR)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     STR      - CHARACTER*(*): STRING (I.E., MNEMONIC)
C
C   OUTPUT ARGUMENT LIST:
C     CHR      - CHARACTER*(*): UNPACKED CHARACTER STRING (I.E.,
C                CHARACTER DATA ELEMENT GREATER THAN EIGHT BYTES)
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     PARSEQ   STATUS   UPC
C    THIS ROUTINE IS CALLED BY: UFDUMP
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /USRBIT/ NBIT(MAXJL),MBIT(MAXJL)
      COMMON /UNPTYP/ MSGUNP(NFILES)
      COMMON /QUIET / IPRT

      CHARACTER*(*) CHR,STR
      CHARACTER*128 BORT_STR
      CHARACTER*10  TAG,TGS(100)
      CHARACTER*8   CTAG
      CHARACTER*3   TYP
      REAL*8        VAL

      DATA MAXTG /100/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  CHECK THE FILE STATUS
C  ---------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      IF(IM.EQ.0) GOTO 902

C  CHECK FOR TAGS (MNEMONICS) IN INPUT STRING (THERE CAN ONLY BE ONE)
C  ------------------------------------------------------------------

      CALL PARSEQ(STR,TGS,MAXTG,NTG)
      IF(NTG.GT.1) GOTO 903
      CTAG = TGS(1)
      CHR = ' '

C  FIND THE TAG IN THE SUBSET OR RETURN A BLANK STRING
C  ---------------------------------------------------

      DO N=1,NVAL(LUN)
      NOD = INV(N,LUN)
      IF(CTAG.EQ.TAG(NOD)) GOTO 1
      ENDDO
      IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT*, 'BUFRLIB: READLC - MNEMONIC ',CTAG,' NOT LOCATED IN ',
     .        'REPORT SUBSET - RETURN WITH BLANK STRING FOR CHARACTER ',
     .        'DATA ELEMENT'
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT*
      ENDIF
      GOTO 100
1     IF(ITP(NOD).NE.3) GOTO 904

C  DECIPHER THE LONG CHARACTER
C  ---------------------------

      IF(MSGUNP(LUN).EQ.0.OR.MSGUNP(LUN).EQ.1) THEN
         NCHR = NBIT(N)/8
         KBIT = MBIT(N)
         CALL UPC(CHR,NCHR,MBAY(1,LUN),KBIT)
      ELSEIF(MSGUNP(LUN).EQ.2) THEN
c  .... compressed message
         GOTO 905
      ELSE
         GOTO 906
      ENDIF

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: READLC - INPUT BUFR FILE IS CLOSED, IT MUST'//
     . ' BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: READLC - INPUT BUFR FILE IS OPEN FOR '//
     . 'OUTPUT, IT MUST BE OPEN FOR INPUT')
902   CALL BORT('BUFRLIB: READLC - A MESSAGE MUST BE OPEN IN INPUT '//
     . 'BUFR FILE, NONE ARE')
903   WRITE(BORT_STR,'("BUFRLIB: READLC - THERE CANNOT BE MORE THAN '//
     . 'ONE MNEMONIC IN THE INPUT STRING (",A,") (HERE THERE ARE ",'//
     . 'I3,")")') STR,NTG
      CALL BORT(BORT_STR)
904   WRITE(BORT_STR,'("BUFRLIB: READLC - MNEMONIC ",A," DOES NOT '//
     . 'REPRESENT A CHARACTER ELEMENT (ITP=",I2,")")') CTAG,ITP(NOD)
      CALL BORT(BORT_STR)
905   CALL BORT('BUFRLIB: READLC - NOT ENABLED FOR COMPRESSED BUFR '//
     . 'MESSAGES')
906   WRITE(BORT_STR,'("BUFRLIB: READLC - MESSAGE UNPACK TYPE",I3,'//
     . '" IS NOT RECOGNIZED")') MSGUNP
      CALL BORT(BORT_STR)
      END
      SUBROUTINE READMG(LUNIT,SUBSET,JDATE,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    READMG
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE READS THE NEXT BUFR MESSAGE FROM LOGICAL
C   UNIT NUMBER LUNIT INTO A MESSAGE BUFFER (ARRAY MBAY IN COMMON BLOCK
C   /BITBUF/), WHICH SHOULD ITSELF HAVE ALREADY BEEN OPENED FOR INPUT
C   OPERATIONS.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1996-11-25  J. WOOLLEN -- MODIFIED TO EXIT GRACEFULLY WHEN THE BUFR
C                           FILE IS POSITIONED AFTER AN "END-OF-FILE"
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"; MODIFIED TO MAKE Y2K
C                           COMPLIANT
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI); MODIFIED WITH
C                           SEMANTIC ADJUSTMENTS TO AMELIORATE COMPILER
C                           COMPLAINTS FROM LINUX BOXES (INCREASES
C                           PORTABILITY)
C 2000-09-19  J. WOOLLEN -- REMOVED MESSAGE DECODING LOGIC THAT HAD
C                           BEEN REPLICATED IN THIS AND OTHER READ
C                           ROUTINES AND CONSOLIDATED IT INTO A NEW
C                           ROUTINE CKTABA, CALLED HERE, WHICH IS
C                           ENHANCED TO ALLOW COMPRESSED AND STANDARD
C                           BUFR MESSAGES TO BE READ; MAXIMUM MESSAGE
C                           LENGTH INCREASED FROM 10,000 TO 20,000
C                           BYTES
C 2002-05-14  J. WOOLLEN -- REMOVED ENTRY POINT DATELEN (IT BECAME A
C                           SEPARATE ROUTINE IN THE BUFRLIB TO INCREASE
C                           PORTABILITY TO OTHER PLATFORMS)
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL READMG (LUNIT, SUBSET, JDATE, IRET)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     SUBSET   - CHARACTER*8: TABLE A MNEMONIC FOR TYPE OF BUFR MESSAGE
C                BEING READ
C     JDATE    - INTEGER: DATE-TIME STORED WITHIN SECTION 1 OF BUFR
C                MESSAGE BEING READ, IN FORMAT OF EITHER YYMMDDHH OR
C                YYYYMMDDHH, DEPENDING ON DATELEN() VALUE
C     IRET     - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = there are no more BUFR messages in LUNIT
C
C   INPUT FILES:
C     UNIT "LUNIT" - BUFR FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     CKTABA   CHRTRNA  LMSG
C                               STATUS   WTSTAT
C    THIS ROUTINE IS CALLED BY: COMPRES  IREADMG  READNS   READTJ
C                               RDMGSB   UFBINX   UFBTAB
C                               Also called by application programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)
      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)

      CHARACTER*8 SEC0,SUBSET
      CHARACTER*4 BUFR
      CHARACTER*1 CEC0(8)
      DIMENSION   IEC0(2)
      EQUIVALENCE (SEC0,IEC0,CEC0)

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IRET = 0

C  CHECK THE FILE STATUS
C  ---------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      CALL WTSTAT(LUNIT,LUN,IL,1)
      IMSG = 8/NBYTW+1

C  READ A MESSAGE INTO A MESSAGE BUFFER - SKIP DICTIONARY MESSAGES
C  ---------------------------------------------------------------

1     SEC0 = ' '
      READ(LUNIT,ERR=902,END=200) SEC0,(MBAY(I,LUN),I=IMSG,LMSG(SEC0))

C     Confirm that the first 4 bytes of SEC0 contain 'BUFR' encoded in
C     CCITT IA5 (i.e. ASCII).

      CALL CHRTRNA(BUFR,CEC0,4)
      IF(BUFR.NE.'BUFR') GOTO 200

C     Copy SEC0 into the front of MBAY so that MBAY now contains the
C     entire BUFR message.

      DO I=1,IMSG-1
      MBAY(I,LUN) = IEC0(I)
      ENDDO

C  PARSE THE MESSAGE SECTION CONTENTS
C  ----------------------------------

      CALL CKTABA(LUN,SUBSET,JDATE,IRET)
      IF(IRET.NE.0) GOTO 1
      GOTO 100

C  EOF ON ATTEMPTED READ
C  ---------------------

200   CALL WTSTAT(LUNIT,LUN,IL,0)
      INODE(LUN) = 0
      IDATE(LUN) = 0
      SUBSET = ' '
      JDATE = 0
      IRET = -1

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: READMG - INPUT BUFR FILE IS CLOSED, IT MUST'//
     . ' BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: READMG - INPUT BUFR FILE IS OPEN FOR OUTPUT'//
     . ', IT MUST BE OPEN FOR INPUT')
902   CALL BORT('BUFRLIB: READMG - ERROR READING A BUFR MESSAGE')
      END
      SUBROUTINE READMM(IMSG,SUBSET,JDATE,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    READMM
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1999-11-18
C
C ABSTRACT: THIS SUBROUTINE READS A PARTICULAR BUFR MESSAGE FROM
C   INTERNAL MEMORY (ARRAY MSGS IN COMMON BLOCK /MSGMEM/) INTO A
C   MESSAGE BUFFER (ARRAY MBAY IN COMMON BLOCK /BITBUF/).  IT IS
C   IDENTICAL TO BUFR ARCHIVE LIBRARY SUBROUTINE RDMEMM EXCEPT IT
C   ADVANCES THE VALUE OF IMSG BY ONE PRIOR TO RETURNING TO CALLING
C   PROGRAM.
C
C PROGRAM HISTORY LOG:
C 1999-11-18  J. WOOLLEN -- ORIGINAL AUTHOR
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2001-08-15  D. KEYSER  -- PARAMETER MAXMEM (THE MAXIMUM NUMBER OF
C                           BYTES REQUIRED TO STORE ALL MESSAGES
C                           INTERNALLY) WAS INCREASED FROM 8 MBYTES TO
C                           16 MBYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- PARAMETER MAXMSG (THE MAXIMUM NUMBER OF
C                           BUFR MESSAGES WHICH CAN BE STORED
C                           INTERNALLY) INCREASED FROM 50000 TO 200000;
C                           UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY OR UNUSUAL THINGS
C                           HAPPEN
C
C USAGE:    CALL READMM (IMSG, SUBSET, JDATE, IRET)
C   INPUT ARGUMENT LIST:
C     IMSG     - INTEGER: POINTER TO BUFR MESSAGE NUMBER (RECORD) IN
C                STORAGE
C
C   OUTPUT ARGUMENT LIST:
C     IMSG     - INTEGER: POINTER TO BUFR MESSAGE NUMBER (RECORD) IN
C                STORAGE
C     SUBSET   - CHARACTER*8: TABLE A MNEMONIC FOR TYPE OF BUFR MESSAGE
C                BEING READ
C     JDATE    - INTEGER: DATE-TIME STORED WITHIN SECTION 1 OF BUFR
C                MESSAGE BEING READ, IN FORMAT OF EITHER YYMMDDHH OR
C                YYYYMMDDHH, DEPENDING ON DATELEN() VALUE
C     IRET     - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = IMSG is either zero or greater than the
C                           number of messages in memory
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    NOTE THAT UFBMEM IS CALLED PRIOR TO THIS TO STORE THE BUFR
C    MESSAGES INTO INTERNAL MEMORY.
C
C    THIS ROUTINE CALLS:        BORT     CKTABA   STATUS   WTSTAT
C    THIS ROUTINE IS CALLED BY: IREADMM
C                               Also called by application programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXMSG=200000,MAXMEM=16000000)
      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /MSGMEM/ MUNIT,MLAST,MSGP(0:MAXMSG),MSGS(MAXMEM)
      COMMON /QUIET / IPRT

      CHARACTER*8 SUBSET

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  CHECK THE MESSAGE REQUEST AND FILE STATUS
C  -----------------------------------------

      CALL STATUS(MUNIT,LUN,IL,IM)
      CALL WTSTAT(MUNIT,LUN,IL, 1)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      IRET = 0

      IF(IMSG.EQ.0 .OR.IMSG.GT.MSGP(0)) THEN
         CALL WTSTAT(MUNIT,LUN,IL,0)
         IF(IPRT.GE.1) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
            IF(IMSG.EQ.0)  THEN
               PRINT*, 'BUFRLIB: READMM - REQUESTED MEMORY MESSAGE ',
     .          'NUMBER {FIRST (INPUT) ARGUMENT} IS 0, RETURN WITH ',
     .          'IRET = -1'
            ELSE
               PRINT*, 'BUFRLIB: READMM - REQ. MEMORY MESSAGE NO. {',
     .          IMSG,' - {1ST (INPUT) ARG.} > NO. OF MESSAGES IN ',
     .          'MEMORY (',MSGP(0),'), RETURN WITH IRET = -1'
            ENDIF
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
         IRET = -1
         GOTO 100
      ENDIF

C  READ MESSAGE# IMSG INTO A MESSAGE BUFFER
C  ----------------------------------------

      IPTR = MSGP(IMSG)
      IF(IMSG.LT.MSGP(0)) LPTR = MSGP(IMSG+1)-IPTR
      IF(IMSG.EQ.MSGP(0)) LPTR = MLAST-IPTR+1
      IPTR = IPTR-1

      DO I=1,LPTR
      MBAY(I,LUN) = MSGS(IPTR+I)
      ENDDO

C  PARSE THE MESSAGE SECTION CONTENTS
C  ----------------------------------

      CALL CKTABA(LUN,SUBSET,JDATE,JRET)
      NMSG(LUN) = IMSG
      IMSG = IMSG+1

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: READMM - INPUT BUFR FILE IS CLOSED, IT MUST'//
     . ' BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: READMM - INPUT BUFR FILE IS OPEN FOR OUTPUT'//
     . ', IT MUST BE OPEN FOR INPUT')
      END
      SUBROUTINE READNS(LUNIT,SUBSET,JDATE,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    READNS
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE SHOULD ONLY BE CALLED WHEN LOGICAL UNIT
C   LUNIT HAS BEEN OPENED FOR INPUT OPERATIONS.  IT READS THE NEXT
C   SUBSET FROM LOGICAL UNIT NUMBER LUNIT INTO INTERNAL SUBSET ARRAYS.
C   BUFR MESSAGES IN LUNIT MAY BE EITHER COMPRESSED OR UNCOMPRESSED.
C   THIS SUBROUTINE IS ACTUALLY A COMBINATION OF BUFR ARCHIVE LIBRARY
C   SUBROUTINES READMG AND READSB.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY); OUTPUTS MORE COMPLETE DIAGNOSTIC
C                           INFO WHEN ROUTINE TERMINATES ABNORMALLY
C
C USAGE:    CALL READNS (LUNIT, SUBSET, JDATE, IRET)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     SUBSET   - CHARACTER*8: TABLE A MNEMONIC FOR BUFR MESSAGE
C                CONTAINING SUBSET BEING READ
C     JDATE    - INTEGER: DATE-TIME STORED WITHIN SECTION 1 OF BUFR
C                MESSAGE CONTAINING SUBSET BEING READ, IN FORMAT OF
C                EITHER YYMMDDHH OR YYYYMMDDHH, DEPENDING ON DATELEN()
C                VALUE
C     IREADNS  - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = there are no more subsets in the BUFR file
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     READMG   READSB   STATUS
C    THIS ROUTINE IS CALLED BY: IREADNS
C                               Also called by application programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)

      CHARACTER*10 TAG
      CHARACTER*8  SUBSET
      CHARACTER*3  TYP

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  REFRESH THE SUBSET AND JDATE PARAMETERS
C  ---------------------------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      SUBSET = TAG(INODE(LUN))
      JDATE  = IDATE(LUN)

C  READ THE NEXT SUBSET IN THE BUFR FILE
C  -------------------------------------

1     CALL READSB(LUNIT,IRET)
      IF(IRET.NE.0) THEN
         CALL READMG(LUNIT,SUBSET,JDATE,IRET)
         IF(IRET.EQ.0) GOTO 1
      ENDIF

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: READNS - INPUT BUFR FILE IS CLOSED, IT MUST'//
     . ' BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: READNS - INPUT BUFR FILE IS OPEN FOR OUTPUT'//
     . ', IT MUST BE OPEN FOR INPUT')
      END
      SUBROUTINE READSB(LUNIT,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    READSB
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE SHOULD ONLY BE CALLED WHEN LOGICAL UNIT
C   LUNIT HAS BEEN OPENED FOR INPUT OPERATIONS.  IT READS A SUBSET FROM
C   A BUFR MESSAGE INTO INTERNAL SUBSET ARRAYS.  THE BUFR MESSAGE MUST
C   HAVE BEEN PREVIOUSLY READ FROM UNIT LUNIT USING BUFR ARCHIVE
C   LIBRARY SUBROUTINE READMG OR READERME AND MAY BE EITHER COMPRESSED
C   OR UNCOMPRESSED.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2000-09-19  J. WOOLLEN -- ADDED CALL TO NEW ROUTINE RDCMPS ALLOWING
C                           SUBSETS TO NOW BE DECODED FROM COMPRESSED
C                           BUFR MESSAGES; MAXIMUM MESSAGE LENGTH
C                           INCREASED FROM 10,000 TO 20,000 BYTES
C 2002-05-14  J. WOOLLEN -- CORRECTED ERROR RELATING TO CERTAIN
C                           FOREIGN FILE TYPES; REMOVED OLD CRAY
C                           COMPILER DIRECTIVES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL READSB (LUNIT, IRET)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     IRET     - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = there are no more subsets in the BUFR
C                           message
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     RDCMPS   RDTREE   STATUS
C                               UPB
C    THIS ROUTINE IS CALLED BY: IREADSB  RDMEMS   READERS  READNS
C                               RDMGSB   UFBINX
C                               Also called by application programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /UNPTYP/ MSGUNP(NFILES)

      CHARACTER*128 BORT_STR

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IRET = 0

C  CHECK THE FILE STATUS
C  ---------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      IF(IM.EQ.0) THEN
         IRET = -1
         GOTO 100
      ENDIF

C  SEE IF THERE IS ANOTHER SUBSET IN THE MESSAGE
C  ---------------------------------------------

      IF(NSUB(LUN).EQ.MSUB(LUN)) THEN
         IRET = -1
         GOTO 100
      ELSE
         NSUB(LUN) = NSUB(LUN) + 1
      ENDIF

C  READ THE NEXT SUBSET AND RESET THE POINTERS
C  -------------------------------------------

      IF(MSGUNP(LUN).EQ.0) THEN
         IBIT = MBYT(LUN)*8
         CALL UPB(NBYT,16,MBAY(1,LUN),IBIT)
         CALL RDTREE(LUN)
         MBYT(LUN) = MBYT(LUN) + NBYT
      ELSEIF(MSGUNP(LUN).EQ.1) THEN
c  .... message with "standard" Section 3
         IBIT = MBYT(LUN)
         CALL RDTREE(LUN)
         MBYT(LUN) = IBIT
      ELSEIF(MSGUNP(LUN).EQ.2) THEN
c  .... compressed message
         CALL RDCMPS(LUN)
      ELSE
         GOTO 902
      ENDIF

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: READSB - INPUT BUFR FILE IS CLOSED, IT MUST'//
     . ' BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: READSB - INPUT BUFR FILE IS OPEN FOR OUTPUT'//
     . ', IT MUST BE OPEN FOR INPUT')
902   WRITE(BORT_STR,'("BUFRLIB: READSB - MESSAGE UNPACK TYPE",I3,"IS'//
     . ' NOT RECOGNIZED")') MSGUNP
      CALL BORT(BORT_STR)
      END
      SUBROUTINE READTJ(LUNIT,SUBSET,JDATE,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    READTJ
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1996-12-11
C
C ABSTRACT: THIS SUBROUTINE NOW SIMPLY CALLS BUFR ARCHIVE LIBRARY
C   SUBROUTINE READMG, USING THE SAME INPUT AND OUTPUT PARAMETERS (SEE
C   READMG FOR DETAILS).  IT HAD BEEN DIFFERENT THAN READMG AT ONE TIME
C   (SEE REMARKS BELOW) AND MAY STILL BE CALLED BY SOME APPLICATION
C   CODES (THUS THE NEED TO RETAIN IT IN THE BUFR ARCHIVE LIBRARY).
C
C PROGRAM HISTORY LOG:
C 1996-12-11  J. WOOLLEN -- ORIGINAL AUTHOR (SEE REMARKS)
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"; MODIFIED TO MAKE Y2K
C                           COMPLIANT
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI); MODIFIED WITH
C                           SEMANTIC ADJUSTMENTS TO AMELIORATE COMPILER
C                           COMPLAINTS FROM LINUX BOXES (INCREASES
C                           PORTABILITY)
C 2000-09-19  J. WOOLLEN -- REMOVED MESSAGE DECODING LOGIC THAT HAD
C                           BEEN REPLICATED IN THIS AND OTHER READ
C                           ROUTINES AND CONSOLIDATED IT INTO A NEW
C                           ROUTINE CKTABA, CALLED HERE, WHICH IS
C                           ENHANCED TO ALLOW COMPRESSED AND STANDARD
C                           BUFR MESSAGES TO BE READ; MAXIMUM MESSAGE
C                           LENGTH INCREASED FROM 10,000 TO 20,000
C                           BYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); NOW
C                           JUST CALLS READMG RATHER THAN BEING A CLONE
C                           OF IT; OUTPUTS MORE COMPLETE DIAGNOSTIC
C                           INFO FOR INFORMATIONAL PURPOSES
C
C USAGE:    CALL READTJ (LUNIT, SUBSET, JDATE, IRET)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     SUBSET   - CHARACTER*8: TABLE A MNEMONIC FOR TYPE OF BUFR MESSAGE
C                BEING READ
C     JDATE    - INTEGER: DATE-TIME STORED WITHIN SECTION 1 OF BUFR
C                MESSAGE BEING READ, IN FORMAT OF EITHER YYMMDDHH OR
C                YYYYMMDDHH, DEPENDING ON DATELEN() VALUE
C     IRET     - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = there are no more BUFR messages in LUNIT
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    ORININALLY THIS WAS A SPECIFIC DATABASE INGEST MESSAGE READER
C    ADDED TO THE LIBRARY IN ORDER TO ATTACH DIFFERENT BUFR TABLES IF
C    THE MESSAGE TYPE WAS NOT RECOGNIZED IN THE CURRENT ONES.  IT
C    WORKED WITH, WHAT WAS THEN, USER ROUTINE ROUTINE OPENBT WHICH
C    SPECIFIES THE LOCATION(S) OF DIFFERENT TABLES.  WHEN THE MESSAGE
C    DECODING LOGIC IN READMG AND READTJ (AMONG OTHER ROUTINES) WAS
C    CONSOLIDATED (2000-09-19), THIS ROUTINE BECAME IDENTICAL TO
C    READMG.
C
C
C    THIS ROUTINE CALLS:        READMG
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs (although they should change
C                               to call READMG instead).
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*8 SUBSET

      COMMON /QUIET / IPRT

      DATA IFIRST/0/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IF(IFIRST.EQ.0) THEN
         IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT 101
101   FORMAT(' BUFRLIB: READTJ - THIS ROUTINE SIMPLY CALLS READMG, ',
     . 'REPLACE IT WITH READMG')
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT*
         ENDIF
         IFIRST = 1
      ENDIF

      CALL READMG (LUNIT, SUBSET, JDATE, IRET)
      RETURN
      END
      SUBROUTINE REWNBF(LUNIT,ISR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    REWNBF
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2003-11-04
C
C ABSTRACT: THIS SUBROUTINE, DEPENDING ON THE VALUE OF ISR, WILL
C   EITHER:
C        1) STORE THE CURRENT PARAMETERS ASSOCIATED WITH A BUFR FILE
C   CONNECTED TO LUNIT (READ/WRITE POINTERS, ETC.), SET THE FILE STATUS
C   TO READ, THEN REWIND THE BUFR FILE AND POSITION IT SUCH THAT THE
C   NEXT BUFR MESSAGE READ WILL BE THE FIRST MESSAGE IN THE FILE
C   CONTAINING ACTUAL SUBSETS WITH DATA; OR
C        2) RESTORE THE BUFR FILE CONNECTED TO LUNIT TO THE PARAMETERS
C   IT HAD PRIOR TO 1) ABOVE USING THE INFORMATION SAVED IN 1) ABOVE.
C
C   THIS ALLOWS INFORMATION TO BE EXTRACTED FROM A PARTICULAR SUBSET IN
C   A BUFR FILE WHICH IS IN THE MIDST OF BEING READ FROM OR WRITTEN TO
C   BY AN APPLICATION PROGRAM.  NOTE THAT FOR A PARTICULAR BUFR FILE 1)
C   ABOVE MUST PRECEDE 2) ABOVE.  AN APPLICATION PROGRAM MIGHT FIRST
C   CALL THIS SUBROUTINE WITH ISR = 0, THEN CALL EITHER BUFR ARCHIVE
C   LIBRARY SUBROUTINE RDMGSB OR UFBINX TO GET INFO FROM A SUBSET, THEN
C   CALL THIS ROUTINE AGAIN WITH ISR = 1 TO RESTORE THE POINTERS IN THE
C   BUFR FILE TO THEIR ORIGINAL LOCATION.  ALSO, BUFR ARCHIVE LIBRARY
C   SUBROUTINE UFBTAB WILL CALL THIS ROUTINE IF THE BUFR FILE IT IS
C   ACTING UPON IS ALREADY OPEN FOR INPUT OR OUTPUT.
C
C PROGRAM HISTORY LOG:
C 2003-11-04  J. WOOLLEN -- ORIGINAL AUTHOR (WAS IN VERIFICATION
C                           VERSION BUT MAY HAVE BEEN IN THE PRODUCTION
C                           VERSION AT ONE TIME AND THEN REMOVED)
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL REWNBF (LUNIT, ISR)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     ISR      - INTEGER: SWITCH:
C                       0 = store current parameters associated with
C                           BUFR file, set file status to read, rewind
C                           file such that next message read is first
C                           message containing subset data
C                       1 = restore BUFR file with parameters saved
C                           from the previous call to this routine with
C                           ISR=0
C
C   INPUT FILES:
C     UNIT "LUNIT" - BUFR FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     I4DY     MOVA2I   STATUS
C                               WTSTAT
C    THIS ROUTINE IS CALLED BY: UFBINX   UFBTAB
C                               Also called by application programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /BUFRSR/ JUNN,JILL,JIMM,JBIT,JBYT,JMSG,JSUB,KSUB,JNOD,JDAT,
     .                JSR(NFILES),JBAY(MXMSGL/4)

      CHARACTER*128 BORT_STR
      CHARACTER*20  MSTR

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  TRY TO TRAP BAD CALL PROBLEMS
C  -----------------------------

      IF(ISR.EQ.0) THEN
         CALL STATUS(LUNIT,LUN,IL,IM)
         IF(JSR(LUN).NE.0)  GOTO 900
         IF(IL.EQ.0) GOTO 901
      ELSEIF(ISR.EQ.1) THEN
         LUN = JUNN
         IF(JSR(JUNN).NE.1)  GOTO 902
      ELSE
         GOTO 903
      ENDIF

C  STORE FILE PARAMETERS AND SET FOR READING
C  -----------------------------------------

      IF(ISR.EQ.0) THEN
         JUNN = LUN
         JILL = IL
         JIMM = IM
         JBIT = IBIT
         JBYT = MBYT(LUN)
         JMSG = NMSG(LUN)
         JSUB = NSUB(LUN)
         KSUB = MSUB (LUN)
         JNOD = INODE(LUN)
         JDAT = IDATE(LUN)
         DO I=1,JBYT
         JBAY(I) = MBAY(I,LUN)
         ENDDO
         CALL WTSTAT(LUNIT,LUN,-1,0)
      ENDIF

C  REWIND THE FILE AND POSITION AFTER THE DICTIONARY
C  -------------------------------------------------

      REWIND LUNIT
1     READ(LUNIT,ERR=904,END=2) MSTR
      IF(MOVA2I(MSTR(17:17)).EQ.11) GOTO 1
2     BACKSPACE LUNIT

C  RESTORE FILE PARAMETERS AND POSITION IT TO WHERE IT WAS SAVED
C  -------------------------------------------------------------

      IF(ISR.EQ.1) THEN
         LUN        = JUNN
         IL         = JILL
         IM         = JIMM
         IBIT       = JBIT
         MBYT(LUN)  = JBYT
         NMSG(LUN)  = JMSG
         NSUB(LUN)  = JSUB
         MSUB(LUN)  = KSUB
         INODE(LUN) = JNOD
         IDATE(LUN) = I4DY(JDAT)
         DO I=1,JBYT
         MBAY(I,LUN) = JBAY(I)
         ENDDO
         DO IMSG=1,JMSG
         READ(LUNIT,ERR=905,END=906)
         ENDDO
         CALL WTSTAT(LUNIT,LUN,IL,IM)
      ENDIF

      JSR(LUN) = MOD(JSR(LUN)+1,2)

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: REWNBF - ATTEMPING TO SAVE '//
     . 'PARAMETERS FOR FILE FOR WHICH THEY HAVE ALREADY BEEN SAVED '//
     . '(AND NOT YET RESTORED) (UNIT",I3,")")') LUNIT
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: REWNBF - ATTEMPING TO SAVE '//
     . 'PARAMETERS FOR BUFR FILE WHICH IS NOT OPENED FOR EITHER INPUT'//
     . ' OR OUTPUT) (UNIT",I3,")")') LUNIT
      CALL BORT(BORT_STR)
902   WRITE(BORT_STR,'("BUFRLIB: REWNBF - ATTEMPING TO RESTORE '//
     . 'PARAMETERS TO BUFR FILE WHICH WERE NEVER SAVED (UNIT",I3,")")')
     . LUNIT
      CALL BORT(BORT_STR)
903   WRITE(BORT_STR,'("BUFRLIB: REWNBF - SAVE/RESTORE SWITCH (INPUT '//
     . 'ARGUMENT ISR) IS NOT ZERO OR ONE (HERE =",I4,") (UNIT",I3,")")')     . ISR,LUNIT
      CALL BORT(BORT_STR)
904   WRITE(BORT_STR,'("BUFRLIB: REWNBF - ERROR READING A DICTIONARY '//
     . 'MESSAGE AFTER REWIND OF BUFR FILE IN UNIT",I4,")")')  LUNIT
      CALL BORT(BORT_STR)
905   WRITE(BORT_STR,'("BUFRLIB: REWNBF - ERROR READING MSG (RECORD) '//
     . 'NO.",I5," IN ATTEMPT TO REPOSITION BUFR FILE IN UNIT",I3," TO'//
     . ' ORIGINAL MSG NO.",I5)') IMSG,LUNIT,JMSG
      CALL BORT(BORT_STR)
906   WRITE(BORT_STR,'("BUFRLIB: REWNBF - HIT END OF FILE BEFORE '//
     . 'REPOSITIONING BUFR FILE IN UNIT",I3," TO ORIGINAL MESSAGE '//
     . 'NO.",I5)') LUNIT,JMSG
      CALL BORT(BORT_STR)
      END
      FUNCTION RJUST(STR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    RJUST
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION RIGHT JUSTIFIES A CHARACTER STRING.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    RJUST (STR)
C   INPUT ARGUMENT LIST:
C     STR      - CHARACTER*(*): STRING TO BE RIGHT-JUSTIFED
C
C   OUTPUT ARGUMENT LIST:
C     STR      - CHARACTER*(*): RIGHT-JUSTIFIED STRING
C     RJUST    - REAL: ALWAYS RETURNED AS 0 (DUMMY)
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT
C    THIS ROUTINE IS CALLED BY: UFBDMP   UFDUMP   VALX
C                               Normally not called by any application
C                               programs but it could be.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*(*) STR
      RJUST = 0.
      IF(STR.EQ.' ') GOTO 100
      LSTR = LEN(STR)
      DO WHILE(STR(LSTR:LSTR).EQ.' ')
         DO I=LSTR,2,-1
         STR(I:I) = STR(I-1:I-1)
         ENDDO
         STR(1:1) = ' '
      ENDDO

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE RSVFVM(NEM1,NEM2)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    RSVFVM
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE STEPS THROUGH THE "FOLLOWING VALUE"
C   MNEMONIC NEM1 AND, FOR EACH "." CHARACTER ENCOUNTERED (EXCEPT FOR
C   THE INITIAL ONE), OVERWRITES IT WITH THE NEXT CORRESPONDING
C   CHARACTER FROM NEM2 (SEE REMARKS).
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION
C
C USAGE:    CALL RSVFVM (NEM1, NEM2)
C   INPUT ARGUMENT LIST:
C     NEM1     - CHARACTER*8: "FOLLOWING VALUE" MNEMONIC
C     NEM2     - CHARACTER*8: MNEMONIC IMMEDIATELY FOLLOWING NEM1
C                WITHIN USER DICTIONARY TABLE
C
C   OUTPUT ARGUMENT LIST:
C     NEM1     - CHARACTER*8: COPY OF INPUT NEM1 WITH ALL "."
C                CHARACTERS (EXCEPT INITIAL ONE) OVERWRITTEN WITH
C                CORRESPONDING CHARACTERS FROM NEM2
C
C REMARKS:
C    FOR EXAMPLE:
C     if, on input:    NEM1 = ".DTH...."
C                      NEM2 = "MXTM    "
C     then, on output: NEM1 = ".DTHMXTM"
C
C
C    THIS ROUTINE CALLS:        None
C    THIS ROUTINE IS CALLED BY: NEMTBD   SEQSDX
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*8 NEM1,NEM2

      DO I=1,LEN(NEM1)
      IF(I.EQ.1) THEN

C        Skip initial "." and initialize J.

         J = 1
      ELSE
         IF(NEM1(I:I).EQ.'.') THEN
            NEM1(I:I) = NEM2(J:J)
            J = J+1
         ENDIF
      ENDIF
      ENDDO

      RETURN
      END
      SUBROUTINE SEQSDX(CARD,LUN)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    SEQSDX
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE DECODES THE TABLE D SEQUENCE INFORMATION
C   FROM A MNEMONIC DEFINITION CARD THAT WAS PREVIOUSLY READ FROM A
C   USER-SUPPLIED BUFR DICTIONARY TABLE IN CHARACTER FORMAT BY
C   BUFR ARCHIVE LIBRARY SUBROUTINE RDUSDX.  THESE ARE THEN ADDED TO
C   THE ALREADY-EXISTING ENTRY FOR THAT MNEMONIC (BUILT IN RDUSDX)
C   WITHIN THE INTERNAL BUFR TABLE D ARRAY TABD(*,LUN) IN COMMON BLOCK
C   /TABABD/.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY; CHANGED CALL FROM BORT TO BORT2
C
C USAGE:    CALL SEQSDX (CARD, LUN)
C   INPUT ARGUMENT LIST:
C     CARD     - CHARACTER*80: MNEMONIC DEFINITION CARD THAT WAS READ
C                FROM A USER-SUPPLIED BUFR DICTIONARY TABLE
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C
C REMARKS:
C    THIS ROUTINE CALLS:        ADN30    BORT2    NEMOCK   NEMTAB
C                               PARSEQ   PKTDD    RSVFVM   STRNUM
C    THIS ROUTINE IS CALLED BY: RDUSDX
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /REPTAB/ IDNR(5,2),TYPS(5,2),REPS(5,2),LENS(5)

      CHARACTER*128 BORT_STR1,BORT_STR2
      CHARACTER*80  CARD,SEQS
      CHARACTER*12  ATAG,TAGS(250)
      CHARACTER*8   NEMO,NEMA,NEMB
      CHARACTER*6   ADN30
      CHARACTER*3   TYPS
      CHARACTER*1   REPS,TAB

      DATA MAXTGS /250/
      DATA MAXTAG /12/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  FIND THE SEQUENCE TAG IN TABLE D AND PARSE THE SEQUENCE STRING
C  --------------------------------------------------------------

      NEMO = CARD( 3:10)
      SEQS = CARD(14:78)

C     Note that an entry for this mnemonic should already exist within
C     the internal BUFR Table D array TABD(*,LUN); this entry should
C     have been created by subroutine RDUSDX when the mnemonic and its
C     associated FXY value and description were initially defined
C     within a card read from the "Descriptor Definition" section at
C     the top of the user-supplied BUFR dictionary table in character
C     format.  Now, we need to retrieve the positional index for that
C     entry within TABD(*,LUN) so that we can access the entry and then
C     add the decoded sequence information to it.

      CALL NEMTAB(LUN,NEMO,IDN,TAB,ISEQ)
      IF(TAB.NE.'D') GOTO 900
      CALL PARSEQ(SEQS,TAGS,MAXTGS,NTAG)
      IF(NTAG.EQ.0 ) GOTO 901

      DO N=1,NTAG
      ATAG = TAGS(N)
      IREP = 0

C  CHECK FOR REPLICATOR
C  --------------------

      DO I=1,5
      IF(ATAG(1:1).EQ.REPS(I,1)) THEN

C        Note that REPS(*,*), which contains all of the symbols used to
C        denote all of the various replication schemes that are
C        possible within a user-supplied BUFR dictionary table in
C        character format, was previously defined within subroutine
C        BFRINI.

         DO J=2,MAXTAG
         IF(ATAG(J:J).EQ.REPS(I,2)) THEN
            IF(J.EQ.MAXTAG) GOTO 902

C           Note that subroutine STRNUM will return NUMR = 0 if the
C           string passed to it contains all blanks (as *should* be the
C           case whenever I = 2 '(' ')', 3 '{' '}', 4 '[' ']', or
C           5 '<' '>').

C           However, when I = 1 '"' '"', then subroutine STRNUM will
C           return NUMR = (the number of replications for the mnemonic
C           using F=1 "regular" (i.e. non-delayed) replication).

            CALL STRNUM(ATAG(J+1:MAXTAG),NUMR)
            IF(I.EQ.1 .AND. NUMR.LE.0  ) GOTO 903
            IF(I.EQ.1 .AND. NUMR.GT.255) GOTO 904
            IF(I.NE.1 .AND. NUMR.NE.0  ) GOTO 905
            ATAG = ATAG(2:J-1)
            IREP = I
            GOTO 1
         ENDIF
         ENDDO
         GOTO 902
      ENDIF
      ENDDO

C  CHECK FOR VALID TAG
C  -------------------

1     IRET=NEMOCK(ATAG)
      IF(IRET.EQ.-1) GOTO 906
      IF(IRET.EQ.-2) GOTO 907
      CALL NEMTAB(LUN,ATAG,IDN,TAB,IRET)
      IF(IRET.GT.0) THEN

C        Note that the next code line checks that we are not trying to
C        replicate a Table B mnemonic (which is currently not allowed).
C        The logic works because, for replicated mnemonics, IREP = I =
C        (the index within REPS(*,*) of the symbol associated with the
C        type of replication in question (e.g. "{, "<", etc.))

         IF(TAB.EQ.'B' .AND. IREP.NE.0) GOTO 908
         IF(ATAG(1:1).EQ.'.') THEN

C           This mnemonic is a "following value" mnemonic
C           (i.e. it relates to the mnemonic that immediately
C           follows it within the user-supplied character-format BUFR
C           dictionary table sequence), so confirm that it contains, as
C           a substring, this mnemonic that immediately follows it.

            NEMB = TAGS(N+1)
c  .... get NEMA from IDN
            CALL NUMTAB(LUN,IDN,NEMA,TAB,ITAB)
            CALL NEMTAB(LUN,NEMB,JDN,TAB,IRET)
            CALL RSVFVM(NEMA,NEMB)
            IF(NEMA.NE.ATAG) GOTO 909
c  .... DK: I don't think the next test can ever be satisfied
c  ....     should probably be IF(N.EQ.NTAG ) GOTO 910
            IF(N.GT.NTAG ) GOTO 910
            IF(TAB.NE.'B') GOTO 911
         ENDIF
      ELSE
         GOTO 912
      ENDIF

C  WRITE THE DESCRIPTOR STRING INTO TABD ARRAY
C  -------------------------------------------
c  .... first look for a replication descriptor
      IF(IREP.GT.0) CALL PKTDD(ISEQ,LUN,IDNR(IREP,1)+NUMR,IRET)
      IF(IRET.LT.0) GOTO 913
      CALL PKTDD(ISEQ,LUN,IDN,IRET)
      IF(IRET.LT.0) GOTO 914

      ENDDO

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR1,'("BUFRLIB: SEQSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"MNEMONIC ",A," IS NOT A TABLE D ENTRY '//
     . '(UNDEFINED, TAB=",A,")")') NEMO,TAB
      CALL BORT2(BORT_STR1,BORT_STR2)
901   WRITE(BORT_STR1,'("BUFRLIB: SEQSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"TABLE D SEQUENCE (PARENT) MNEMONIC ",A,'//
     . '" DOES NOT CONTAIN ANY CHILD MNEMONICS")') NEMO
      CALL BORT2(BORT_STR1,BORT_STR2)
902   WRITE(BORT_STR1,'("BUFRLIB: SEQSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"TABLE D SEQUENCE (PARENT) MNEMONIC ",A,'//
     . '" CONTAINS A BADLY FORMED CHILD MNEMONIC",A)') NEMO,TAGS(N)
      CALL BORT2(BORT_STR1,BORT_STR2)
903   WRITE(BORT_STR1,'("BUFRLIB: SEQSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(9X,"TBL D MNEM. ",A," CONTAINS REG. REPL. '//
     . 'CHILD MNEM. ",A," W/ INVALID # OF REPLICATIONS (",I3,") AFTER'//
     . ' 2ND QUOTE")') NEMO,TAGS(N),NUMR
      CALL BORT2(BORT_STR1,BORT_STR2)
904   WRITE(BORT_STR1,'("BUFRLIB: SEQSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"TBL D MNEM. ",A," CONTAINS REG. REPL. '//
     . 'CHILD MNEM. ",A," W/ # OF REPLICATIONS (",I3,") > LIMIT OF '//
     . '255")') NEMO,TAGS(N),NUMR
      CALL BORT2(BORT_STR1,BORT_STR2)
905   WRITE(BORT_STR1,'("BUFRLIB: SEQSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"TBL D MNEM. ",A," CONTAINS DELAYED REPL.'//
     . ' CHILD MNEM. ",A," W/ # OF REPL. (",I3,") SPECIFIED - A NO-'//
     . 'NO")') NEMO,TAGS(N),NUMR
      CALL BORT2(BORT_STR1,BORT_STR2)
906   WRITE(BORT_STR1,'("BUFRLIB: SEQSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"TABLE D (PARENT) MNEMONIC ",A," CONTAINS'//
     .' A CHILD MNEMONIC ",A," NOT BETWEEN 1 & 8 CHARACTERS")')
     . NEMO,TAGS(N)
      CALL BORT2(BORT_STR1,BORT_STR2)
907   WRITE(BORT_STR1,'("BUFRLIB: SEQSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"TABLE D (PARENT) MNEMONIC ",A," CONTAINS'//
     . ' A CHILD MNEMONIC ",A," WITH INVALID CHARACTERS")') NEMO,TAGS(N)
      CALL BORT2(BORT_STR1,BORT_STR2)
908   WRITE(BORT_STR1,'("BUFRLIB: SEQSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"TABLE D (PARENT) MNEMONIC ",A," CONTAINS'//
     . ' A REPLICATED CHILD TABLE B MNEMONIC ",A," - A NO-NO")')
     . NEMO,TAGS(N)
      CALL BORT2(BORT_STR1,BORT_STR2)
909   WRITE(BORT_STR1,'("BUFRLIB: SEQSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"TBL D (PARENT) MNEM. ",A," CONTAINS AN '//
     . 'INVALID ''FOLLOWING VALUE'' MNEMONIC ",A,"(SHOULD BE ",A,")")')
     . NEMO,TAGS(N),NEMA
      CALL BORT2(BORT_STR1,BORT_STR2)
910   WRITE(BORT_STR1,'("BUFRLIB: SEQSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"TBL D (PARENT) MNEM. ",A," CONTAINS A '//
     . '''FOLLOWING VALUE'' MNEMONIC ",A," WHICH IS LAST IN THE '//
     . 'STRING")') NEMO,NEMA
      CALL BORT2(BORT_STR1,BORT_STR2)
911   WRITE(BORT_STR1,'("BUFRLIB: SEQSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"TBL D (PARENT) MNEM. ",A,", THE MNEM. ",'//
     . 'A," FOLLOWING A ''FOLLOWING VALUE'' MNEM. IS NOT A TBL B '//
     . 'ENTRY")') NEMO,NEMB
      CALL BORT2(BORT_STR1,BORT_STR2)
912   WRITE(BORT_STR1,'("BUFRLIB: SEQSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(18X,"TABLE D SEQUENCE (PARENT) MNEMONIC ",A,'//
     . '" CONTAINS A CHILD MNEMONIC ",A," NOT FOUND IN ANY TABLE")')
     .  NEMO,TAGS(N)
      CALL BORT2(BORT_STR1,BORT_STR2)
913   WRITE(BORT_STR1,'("BUFRLIB: SEQSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(9X,"TBL D (PARENT) MNEM. ",A," - BAD RETURN '//
     . 'FROM PKTDD TRYING TO STORE REPL. DESC. ",A,", SEE PREV. '//
     . 'WARNING MSG")') NEMO,ADN30(IDNR(IREP,1)+NUMR,6)
      CALL BORT2(BORT_STR1,BORT_STR2)
914   WRITE(BORT_STR1,'("BUFRLIB: SEQSDX - CARD READ IN IS: ",A)') CARD
      WRITE(BORT_STR2,'(9X,"TBL D (PARENT) MNEM. ",A," - BAD RETURN '//
     . 'FROM PKTDD TRYING TO STORE CHILD MNEM. ",A,", SEE PREV. '//
     . 'WARNING MSG")') NEMO,TAGS(N)
      CALL BORT2(BORT_STR1,BORT_STR2)
      END
      SUBROUTINE STANDARD(LUNIT,MSGIN,MSGOT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    STANDARD
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1997-09-03
C
C ABSTRACT: THIS SUBROUTINE TAKES, AS INPUT, A BUFR MESSAGE SUCH AS
C   WOULD HAVE PREVIOUSLY BEEN OUTPUT BY, FOR EXAMPLE BUFR ARCHIVE
C   LIBRARY SUBROUTINE WRITSA AND, USING THE BUFR TABLES INFORMATION
C   ASSOCIATED WITH LOGICAL UNIT LUNIT, OUTPUTS A STANDARDIZED VERSION
C   OF THIS MESSAGE. THIS "STANDARDIZATION" INVOLVES REMOVING ALL
C   REFERENCES TO NCEP BUFR-SPECIFIC BYTE COUNTERS AND BIT PADS IN
C   SECTION 4 AS WELL AS REPLACING THE TABLE A FXY NUMBER FROM SECTION
C   3 WITH THE SEQUENCE OF TABLE B AND TABLE D FXY NUMBERS THAT
C   DIRECTLY CONSTITUTE THAT TABLE A FXY NUMBER.  THUS, IF THIS
C   RESULTING "ONE LEVEL DEEP" EXPANSION CONSISTS OF ONLY FXY NUMBERS
C   FROM THE OFFICIAL, INTERNATIONALLY-COORDINATED WMO BUFR TABLES,
C   THEN THE NEW MESSAGE IS ENTIRELY AND STRICTLY STANDARD ACCORDING TO
C   THE WMO REGULATIONS.
C
C PROGRAM HISTORY LOG:
C 1997-09-03  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL STANDARD (LUNIT, MSGIN, MSGOT)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     MSGIN    - INTEGER: *-WORD ARRAY CONTAINING BUFR MESSAGE IN NCEP
C                BUFR
C
C   OUTPUT ARGUMENT LIST:
C     MSGOT    - INTEGER: *-WORD ARRAY CONTAINING INPUT BUFR MESSAGE
C                NOW IN STANDARDIZED BUFR
C
C REMARKS:
C    MSGIN AND MSGOT MUST BE SEPARATE ARRAYS.
C
C    THIS ROUTINE CALLS:        BORT     IUPB     MVB      NUMTAB
C                               PCB      PKC      STATUS   UPB
C                               UPC      UPTDD
C                                        
C    THIS ROUTINE IS CALLED BY: COPYST   WRITST
C                               Also called by application programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      DIMENSION MSGIN(*),MSGOT(*)

      CHARACTER*128 BORT_STR
      CHARACTER*8   SUBSET
      CHARACTER*4   SEVN
      CHARACTER*1   TAB

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  LUNIT MUST POINT TO AN OPEN BUFR FILE
C  -------------------------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900

C  IDENTIFY THE SECTION LENGTHS AND ADDRESSES IN MSGIN
C  ---------------------------------------------------

      IAD0 = 0
      LEN0 = 8
      LENN = IUPB(MSGIN,IAD0+5,24)

      IAD1 = IAD0+LEN0
      LEN1 = IUPB(MSGIN,IAD1+1,24)
      LEN2 = IUPB(MSGIN,IAD1+8,1)

      IAD2 = IAD1+LEN1
      LEN2 = IUPB(MSGIN,IAD2+1,24)*LEN2

      IAD3 = IAD2+LEN2
      LEN3 = IUPB(MSGIN,IAD3+1,24)

      IAD4 = IAD3+LEN3
      LEN4 = IUPB(MSGIN,IAD4+1,24)

      LENM = LEN0+LEN1+LEN2+LEN3+LEN4+4

      IF(LENN.NE.LENM) GOTO 901

      MBIT = (LENN-4)*8
      CALL UPC(SEVN,4,MSGIN,MBIT)
      IF(SEVN.NE.'7777') GOTO 902

C  COPY SECTIONS 0 THROUGH PART OF SECTION 3 INTO MSGOT
C  ----------------------------------------------------

      CALL MVB(MSGIN,1,MSGOT,1,LEN0+LEN1+LEN2+7)

C  REWRITE NEW SECTION 3 IN A "STANDARD" FORM
C  ------------------------------------------

      NSUB = IUPB(MSGIN,IAD3+ 5,16)
      ISUB = IUPB(MSGIN,IAD3+10,16)
      IBIT = (IAD3+7)*8

C  LOOK UP THE SUBSET DESCRIPTOR AND ITS LENGTH IN DESCRIPTORS
C  -----------------------------------------------------------
c  .... get SUBSET from ISUB
      CALL NUMTAB(LUN,ISUB,SUBSET,TAB,ITAB)
      IF(ITAB.EQ.0) GOTO 903
      CALL UPTDD(ITAB,LUN,0,NSEQ)

C  COPY EACH DESCRIPTOR IN THE SUBSET SEQUENCE INTO THE NEW SECTION 3
C  ------------------------------------------------------------------

      DO N=1,NSEQ
      CALL UPTDD(ITAB,LUN,N,IDSC)
      CALL PKB(IDSC,16,MSGOT,IBIT)
      IF(N.EQ.NSEQ) CALL PKB(0,8,MSGOT,IBIT)
      ENDDO

      IBIT = IAD3*8
      LEN3 = 8+NSEQ*2
      NAD4 = IAD3+LEN3
      CALL PKB(LEN3,24,MSGOT,IBIT)

C  NOW THE TRICKY PART - NEW SECTION 4
C  -----------------------------------

      IBIT = (IAD4+4)*8
      JBIT = (NAD4+4)*8

C  COPY THE SUBSETS, MINUS THE BYTE COUNTER AND PAD, INTO NEW SECTION 4
C  --------------------------------------------------------------------

      DO 10 I=1,NSUB
      CALL UPB(LSUB,16,MSGIN,IBIT)

      DO L=1,LSUB-2
      CALL UPB(NVAL,8,MSGIN,IBIT)
      CALL PKB(NVAL,8,MSGOT,JBIT)
      ENDDO

      DO K=1,8
      KBIT = IBIT-K-8
      CALL UPB(KVAL,8,MSGIN,KBIT)
      IF(KVAL.EQ.K) THEN
         JBIT = JBIT-K-8
         GOTO 10
      ENDIF
      ENDDO
      GOTO 904

10    ENDDO

C  MAKE SURE NEW SECTION 4 HAS AN EVEN NUMBER OF BYTES & ENTER THE COUNT
C  ---------------------------------------------------------------------

      DO WHILE(.NOT.(MOD(JBIT,8).EQ.0 .AND. MOD(JBIT/8,2).EQ.0))
         CALL PKB(0,1,MSGOT,JBIT)
      ENDDO

      IBIT = NAD4*8
      LEN4 = JBIT/8 - NAD4
      CALL PKB(LEN4,24,MSGOT,IBIT)

C  FINISH THE NEW MESSAGE WITH AN UPDATED SECTION-0 BYTE COUNT
C  -----------------------------------------------------------

      IBIT = 32
      LENM = LEN0+LEN1+LEN2+LEN3+LEN4+4
      CALL PKB(LENM,24,MSGOT,IBIT)

      CALL PKC('7777', 4,MSGOT,JBIT)

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: STANDARD - BUFR FILE IS CLOSED, IT MUST BE'//
     . ' OPEN')
901   WRITE(BORT_STR,'("BUFRLIB: STANDARD - INPUT MESSAGE LENGTH FROM'//
     . ' SECTION 0",I6," DOES NOT EQUAL SUM OF ALL INDIVIDUAL SECTION'//
     . ' LENGTHS (",I6,")")') LENN,LENM
      CALL BORT(BORT_STR)
902   WRITE(BORT_STR,'("BUFRLIB: STANDARD - INPUT MESSAGE DOES NOT '//
     . 'END WITH ""7777"" (ENDS WITH ",A)') SEVN
      CALL BORT(BORT_STR)
903   CALL BORT('BUFRLIB: STANDARD - INPUT MESSAGE TABLE D SUBSET '//
     . 'DESCRIPTOR NOT FOUND IN INTERNAL TABLE D')
904   CALL BORT('BUFRLIB: STANDARD - BIT MISMATCH COPYING SECTION 4 '//
     . 'FROM INPUT TO OUTPUT (STANDARD) MESSAGE')
      END
      SUBROUTINE STATUS(LUNIT,LUN,IL,IM)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    STATUS
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE CHECKS WHETHER LOGICAL UNIT NUMBER LUNIT
C   (AND ITS ASSOCIATED BUFR FILE) IS CURRENTLY CONNECTED TO THE
C   BUFR ARCHIVE LIBRARY SOFTWARE.  IF SO, IT RETURNS THE I/O STREAM
C   INDEX (LUN) ASSOCIATED WITH THE LOGICAL UNIT NUMBER, THE LOGICAL
C   UNIT STATUS INDICATOR (IL), AND THE BUFR MESSAGE STATUS INDICATOR
C   (IM) FOR THAT I/O STREAM INDEX.  OTHERWISE, IT CHECKS WHETHER THERE
C   IS SPACE FOR A NEW I/O STREAM INDEX AND, IF SO, RETURNS THE NEXT
C   AVAILABLE I/O STREAM INDEX IN LUN IN ORDER TO DEFINE LUNIT (IL AND
C   IM ARE RETURNED AS ZERO, THEY ARE LATER DEFINED VIA CALLS TO BUFR
C   ARCHIVE LIBRARY SUBROUTINE WTSTAT IN THIS CASE).  IF THERE IS NO
C   SPACE FOR A NEW I/O STREAM INDEX, LUN IS RETURNED AS ZERO (AS WELL
C   AS IL AND IM) MEANING LUNIT COULD NOT BE CONNECTED TO THE BUFR
C   ARCHIVE LIBRARY SOFTWARE.  LUN IS USED TO IDENTIFY UP TO "NFILES"
C   UNIQUE BUFR FILES IN THE VARIOUS INTERNAL ARRAYS.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1996-12-11  J. WOOLLEN -- FIXED A LONG STANDING BUG WHICH OCCURS IN
C                           UNUSUAL SITUATIONS, VERY LOW IMPACT
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL STATUS ( LUNIT, LUN, IL, IM )
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX ASSOCIATED WITH LOGICAL UNIT
C                LUNIT
C                       0 = LUNIT is not currently connected to the
C                           BUFR Archive Library software and there is
C                           no space for a new I/O stream index
C     IL       - INTEGER: LOGICAL UNIT STATUS INDICATOR:
C                       0 = LUNIT is not currently connected to the
C                           BUFR Archive Library software or it was
C                           just connected in this call to STATUS
C                       1 = LUNIT is connected to the BUFR Archive
C                           Library software as an output file
C                      -1 = LUNIT is connected to the BUFR Archive
C                           Library software as an input file
C     IM       - INTEGER: INDICATOR AS TO WHETHER THERE IS A BUFR
C                MESSAGE CURRENTLY OPEN WITHIN MEMORY FOR THIS LUNIT:
C                       0 = no or LUNIT was just connected to the
C                           BUFR Archive Library software in this call
C                           to STATUS
C                       1 = yes
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT
C    THIS ROUTINE IS CALLED BY: CLOSBF   CLOSMG   COMPRES  COPYBF
C                               COPYMG   COPYSB   COPYST   CPYMEM
C                               DATEBF   DRFINI   DUMPBF   IFBGET
C                               INVMRG   MINIMG   NMBYT    NMSUB
C                               OPENBF   OPENMB   OPENMG   RDMEMM
C                               RDMEMS   RDMGSB   READDX   READERM
C                               READERME READFT   READIBM  READLC
C                               READMG   READMM   READNS   READSB
C                               REWNBF   STANDARD UFBCNT   UFBCPY
C                               UFBCUP   UFBDMP   UFBEVN   UFBGET
C                               UFBIN3   UFBINT   UFBINX   UFBMMS
C                               UFBOVR   UFBQCD   UFBQCP   UFBREP
C                               UFBRMS   UFBSEQ   UFBSTP   UFBTAB
C                               UFBTAM   UFDUMP   WRCMPS   WRITCP
C                               WRITLC   WRITSA   WRITSB   WRITST
C                               Also called by application programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)

      COMMON /STBFR/ IOLUN(NFILES),IOMSG(NFILES)

      CHARACTER*128 BORT_STR

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IF(LUNIT.LE.0 .OR. LUNIT.GT.99) GOTO 900

C  CLEAR THE STATUS INDICATORS
C  ---------------------------

      LUN = 0
      IL  = 0
      IM  = 0

C  SEE IF UNIT IS ALREADY CONNECTED TO BUFR ARCHIVE LIBRARY SOFTWARE
C  -----------------------------------------------------------------

      DO I=1,NFILES
      IF(ABS(IOLUN(I)).EQ.LUNIT) LUN = I
      ENDDO

C  IF NOT, TRY TO DEFINE IT SO AS TO CONNECT IT TO BUFR ARCHIVE LIBRARY
C  SOFTWARE
C  --------------------------------------------------------------------

      IF(LUN.EQ.0) THEN
         DO I=1,NFILES
         IF(IOLUN(I).EQ.0) THEN

C  File space is available, return with LUN > 0, IL and IM remain 0
C  ----------------------------------------------------------------

            LUN = I
            GOTO 100
         ENDIF
         ENDDO

C  File space is NOT available, return with LUN, IL and IM all 0
C  -------------------------------------------------------------

         GOTO 100
      ENDIF

C  IF THE UNIT WAS ALREADY CONNECTED TO THE BUFR ARCHIVE LIBRARY
C   SOFTWARE PRIOR TO THIS CALL, RETURN STATUSES
C  -------------------------------------------------------------

      IL = SIGN(1,IOLUN(LUN))
      IM = IOMSG(LUN)

C  EXITS
C  ----

100   RETURN
900   WRITE(BORT_STR,'("BUFRLIB: STATUS - INPUT UNIT NUMBER (",I3,") '//
     . 'OUTSIDE LEGAL RANGE OF 1-99")') LUNIT
      CALL BORT(BORT_STR)
      END
      SUBROUTINE STRCLN

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    STRCLN
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE RESETS THE MNEMONIC STRING CACHE IN THE
C   BUFR INTERFACE (ARRAYS IN COMMON BLOCK /STCACH/).  THE MNEMONIC
C   STRING CACHE IS A PERFORMANCE ENHANCING DEVICE WHICH SAVES TIME
C   WHEN THE SAME MNEMONIC STRINGS ARE ENCOUNTERED IN A PROGRAM, OVER
C   AND OVER AGAIN (THE TYPICAL SCENARIO).
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-04-02  J. WOOLLEN -- MODIFIED TO ENLARGE THE CACHE FROM 50
C                           ELEMENTS TO 1000, MAXIMUM
C 1998-07-08  J. WOOLLEN -- CORRECTED SOME MINOR ERRORS
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    CALL STRCLN
C
C REMARKS:
C    THIS ROUTINE CALLS:        None
C    THIS ROUTINE IS CALLED BY: MAKESTAB
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MXS=1000)

      COMMON /STCACH/ MSTR,NSTR,LSTR,LUNS(MXS,2),USRS(MXS),ICON(52,MXS)
      CHARACTER*80 USRS

      MSTR = MXS
      NSTR = 0
      LSTR = 0
      RETURN
      END
      SUBROUTINE STRING(STR,LUN,I1,IO)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    STRING
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE CHECKS TO SEE IF A USER-SPECIFIED CHARACTER
C   STRING IS IN THE STRING CACHE (ARRAYS IN COMMON BLOCKS /STCACH/ AND
C   /STORDS/).  IF IT IS NOT IN THE CACHE, IT MUST CALL THE BUFR
C   ARCHIVE LIBRARY PARSING SUBROUTINE PARUSR TO PERFORM THE TASK OF
C   SEPARATING AND CHECKING THE INDIVIDUAL "PIECES" (I.E., MNEMONICS)
C   SO THAT IT CAN THEN BE ADDED TO THE CACHE.  IF IT IS ALREADY IN THE
C   CACHE, THEN THIS EXTRA WORK DOES NOT NEED TO BE PERFORMED.  THE
C   MNEMONIC STRING CACHE IS A PERFORMANCE ENHANCING DEVICE WHICH SAVES
C   TIME WHEN THE SAME MNEMONIC STRINGS ARE ENCOUNTERED IN A USER
C   PROGRAM, OVER AND OVER AGAIN (THE TYPICAL SCENARIO).
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-04-02  J. WOOLLEN -- MODIFIED TO ENLARGE THE CACHE FROM 50
C                           ELEMENTS TO 1000, MAXIMUM; OPTIMIZATION OF
C                           THE CACHE SEARCH ALGORITHM IN SUPPORT OF A
C                           BIGGER CACHE
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"; CORRECTED SOME MINOR ERRORS
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY; CHANGED CALL FROM
C                           BORT TO BORT2
C
C USAGE:    CALL STRING (STR, LUN, I1, IO)
C   INPUT ARGUMENT LIST:
C     STR      - CHARACTER*(*): STRING OF BLANK-SEPARATED MNEMONICS
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C
C   OUTPUT ARGUMENT LIST:
C     I1       - INTEGER: A NUMBER GREATER THAN OR EQUAL TO THE NUMBER
C                OF BLANK-SEPARATED MNEMONICS IN STR
C     IO       - INTEGER: STATUS INDICATOR FOR BUFR FILE ASSOCIATED
C                WITH LUN:
C                       0 = input file
C                       1 = output file
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT2    PARUSR
C    THIS ROUTINE IS CALLED BY: UFBEVN   UFBGET   UFBIN3   UFBINT
C                               UFBOVR   UFBREP   UFBSTP   UFBTAB
C                               UFBTAM
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MXS=1000,JCONS=52)
      PARAMETER (NFILES=32)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /STCACH/ MSTR,NSTR,LSTR,LUX(MXS,2),USR(MXS),ICON(JCONS,MXS)
      COMMON /USRSTR/ JCON(JCONS)
      COMMON /STORDS/ IORD(MXS),IORX(MXS)

      CHARACTER*(*) STR
      CHARACTER*128 BORT_STR1,BORT_STR2
      CHARACTER*80  USR,UST

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      NXT = 0
      UST = STR
      IND = INODE(LUN)
      IF(LEN(STR).GT.80) GOTO 900

C  SEE IF STRING IS IN THE CACHE
C  -----------------------------
c  .... DK: I guess NSTR has been initialized prior to this by STRCLN
c           (called by MAKESTAB), otherwise first time in it's undefined
      DO N=1,NSTR
      IF(LUX(IORD(N),2).EQ.IND) THEN
         IORX(NXT+1) = IORD(N)
         NXT = NXT+1
      ENDIF
      ENDDO
      DO N=1,NXT
      IF(UST.EQ.USR(IORX(N)))GOTO1
      ENDDO
      GOTO2

C  IF IT IS IN THE CACHE, COPY PARAMETERS FROM THE CACHE
C  -----------------------------------------------------

1     DO J=1,JCONS
      JCON(J) = ICON(J,IORX(N))
      ENDDO
      GOTO 100

C  IF IT IS NOT IN THE CACHE, PARSE IT AND PUT IT THERE
C  ----------------------------------------------------

2     CALL PARUSR(STR,LUN,I1,IO)
c  .... DK: I guess LSTR & MSTR have been initialized prior to this by
c           STRCLN (called by MAKESTAB), otherwise first time in they're
c           undefined
      LSTR = MAX(MOD(LSTR+1,MSTR+1),1)
c  .... DK: I guess NSTR has been initialized prior to this by STRCLN
c           (called by MAKESTAB), otherwise first time in it's undefined
      NSTR = MIN(NSTR+1,MSTR)
c  .... File
      LUX(LSTR,1) = LUN
c  .... Table A entry
      LUX(LSTR,2) = IND
      USR(LSTR) = STR
      DO J=1,JCONS
      ICON(J,LSTR) = JCON(J)
      ENDDO

C  REARRANGE THE CACHE ORDER AFTER AN UPDATE
C  -----------------------------------------

      DO N=NSTR,2,-1
      IORD(N) = IORD(N-1)
      ENDDO
      IORD(1) = LSTR

100   IF(JCON(1).GT.I1) GOTO 901

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR1,'("BUFRLIB: STRING - INPUT STRING (",A,") HAS")')
     . STR
      WRITE(BORT_STR2,'(18X,"LENGTH (",I4,"), > LIMIT OF 80 CHAR.")')
     .  LEN(STR)
      CALL BORT2(BORT_STR1,BORT_STR2)
901   WRITE(BORT_STR1,'("BUFRLIB: STRING - INPUT STRING (",A,")")') STR
      WRITE(BORT_STR2,'(18X,"HAS",I5," STORE NODES (MNEMONICS) - THE '//
     . 'LIMIT (THIRD INPUT ARGUMENT) IS",I5)') JCON(1),I1
      CALL BORT2(BORT_STR1,BORT_STR2)
      END
      SUBROUTINE STRNUM(STR,NUM)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    STRNUM
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE DECODES AN INTEGER FROM A CHARACTER STRING.
C   THE INPUT STRING SHOULD CONTAIN ONLY DIGITS AND (OPTIONAL) TRAILING
C   BLANKS AND SHOULD NOT CONTAIN ANY SIGN CHARACTERS (E.G. '+', '-')
C   NOR LEADING BLANKS NOR EMBEDDED BLANKS.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION
C
C USAGE:    CALL STRNUM (STR, NUM)
C   INPUT ARGUMENT LIST:
C     STR      - CHARACTER*(*): STRING CONTAINING ENCODED INTEGER VALUE
C
C   OUTPUT ARGUMENT LIST:
C     NUM      - INTEGER: DECODED VALUE
C                      -1 = decode was unsuccessful
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        STRSUC
C    THIS ROUTINE IS CALLED BY: JSTNUM   PARUTG   SEQSDX
C                               Normally not called by any application
C                               programs but it could be.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*(*) STR
      CHARACTER*20  STR2

      COMMON /QUIET / IPRT

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      NUM = 0
      K = 0

C     Note that, in the following call to subroutine STRSUC, the output
C     string STR2 is not used anywhere else in this routine.  In fact,
C     the only reason that subroutine STRSUC is being called here is to
C     determine NUM, which, owing to the fact that the input string STR
C     cannot contain any leading blanks, is equal to the number of
C     digits to be decoded from the beginning of STR.
c  .... DK: Should we have a contingency for NUM returned as -1? (guess
c           it can't ever happen, right)

      CALL STRSUC(STR,STR2,NUM)

      DO I=1,NUM
      READ(STR(I:I),'(I1)',ERR=99) J
      IF(J.EQ.0 .AND. STR(I:I).NE.'0') GOTO 99
      K = K*10+J
      ENDDO

      NUM = K
      GOTO 100

C     Note that NUM = -1 unambiguously indicates a bad decode since
C     the input string cannot contain sign characters; thus, NUM is
C     always positive if the decode is successful.

99    NUM = -1
      IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT*,'BUFRLIB: STRNUM - BAD DECODE -  RETURN WITH NUM = -1'
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT*
      ENDIF

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE STRSUC(STR1,STR2,LENS)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    STRSUC
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE REMOVES LEADING AND TRAILING BLANKS FROM A
C   STRING.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; ADDED MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN UNUSUAL THINGS HAPPEN
C
C USAGE:    CALL STRSUC (STR1, STR2, LENS)
C   INPUT ARGUMENT LIST:
C     STR1     - CHARACTER*(*): STRING
C
C   OUTPUT ARGUMENT LIST:
C     STR2     - CHARACTER*(*): COPY OF STR1 WITH LEADING AND TRAILING
C                BLANKS REMOVED
C     LENS     - INTEGER: LENGTH OF STR2:
C                      -1 = STR1 contained embedded blanks
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        None
C    THIS ROUTINE IS CALLED BY: STRNUM
C                               Normally not called by any application
C                               programs but it could be.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*(*) STR1,STR2

      COMMON /QUIET / IPRT

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      LENS = 0
      LSTR = LEN(STR1)

C  FIND THE FIRST NON-BLANK IN THE INPUT STRING
C  --------------------------------------------

      DO I=1,LSTR
      IF(STR1(I:I).NE.' ') GOTO 2
      ENDDO
      GOTO 100

C     Now, starting with the first non-blank in the input string,
C     copy characters from the input string into the output string
C     until reaching the next blank in the input string.

2     DO J=I,LSTR
      IF(STR1(J:J).EQ.' ') GOTO 3
      LENS = LENS+1
      STR2(LENS:LENS) = STR1(J:J)
      ENDDO
      GOTO 100

C     Now, continuing on within the input string, make sure that
C     there are no more non-blank characters.  If there are, then
C     the blank at which we stopped copying from the input string
C     into the output string was an embedded blank.

3     DO I=J,LSTR
      IF(STR1(I:I).NE.' ') LENS = -1
      ENDDO

      IF(LENS.EQ.-1 .AND. IPRT.GE.0)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
         PRINT*,'BUFRLIB: STRSUC - INPUT STRING ',STR1,' CONTAINS ',
     .    '1 OR MORE EMBEDDED BLANKS -  RETURN WITH LENS = -1'
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT*
      ENDIF

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE SUBUPD(LUNIT,LUN,IBYT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    SUBUPD
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2003-11-04
C
C ABSTRACT: THIS SUBROUTINE PACKS UP THE CURRENT SUBSET WITHIN MEMORY
C  (ARRAY IBAY IN COMMON BLOCK /BITBUF/) AND THEN TRIES TO ADD IT TO
C  THE BUFR MESSAGE THAT IS CURRENTLY OPEN WITHIN MEMORY FOR LUNIT
C  (ARRAY MBAY IN COMMON BlOCK /BITBUF/).  IF THE SUBSET WILL NOT FIT
C  INTO THE CURRENTLY OPEN MESSAGE, THEN THAT MESSAGE IS FLUSHED TO
C  LUNIT AND A NEW ONE IS CREATED IN ORDER TO HOLD THE CURRENT SUBSET.
C  IF THE SUBSET IS LARGER THAN AN EMPTY MESSAGE, THE SUBSET IS
C  DISCARDED ANDA DIAGNOSTIC IS PRINTED.  THIS SUBROUTINE IS IDENTICAL
C  TO BUFR ARCHIVE LIBRARY SUBROUTINE MSGUPD EXCEPT SUBUPD DOES NOT PAD
C  THE PACKED SUBSET.
C
C PROGRAM HISTORY LOG:
C 2003-11-04  J. WOOLLEN -- ORIGINAL AUTHOR (WAS IN VERIFICATION
C                           VERSION)
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION
C
C USAGE:    CALL SUBUPD (LUNIT, LUN, IBYT)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C                (ASSOCIATED WITH FILE CONNECTED TO LOGICAL UNIT LUNIT)
C     IBYT     - INTEGER: NUMBER OF BYTES WITHIN IBAY CONTAINING PACKED
C                DATA
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        IUPB     MSGINI   MSGWRT   MVB
C                               PKB      USRTPL
C    THIS ROUTINE IS CALLED BY: None
C                               Perhaps a verification application
C                               program calls it (if not, remove it?)
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /MSGPTR/ NBY0,NBY1,NBY2,NBY3,NBY4,NBY5
      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /QUIET / IPRT

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  SEE IF THE NEW SUBSET FITS
C  --------------------------

      IF(MBYT(LUN)+IBYT+8.GT.MAXBYT) THEN
c  .... NO it does not fit
         CALL MSGWRT(LUNIT,MBAY(1,LUN),MBYT(LUN))
         CALL MSGINI(LUN)
      ENDIF

      IF(MBYT(LUN)+IBYT+8.GT.MAXBYT) GOTO 900

C  SET A BYTE COUNT AND TRANSFER THE SUBSET BUFFER INTO THE MESSAGE
C  ----------------------------------------------------------------

      LBIT = 0
      CALL PKB(IBYT,16,IBAY,LBIT)
c  .... DK: Why the -3 in "MBYT(LUN)-3" ??
      CALL MVB(IBAY,1,MBAY(1,LUN),MBYT(LUN)-3,IBYT)

C  UPDATE THE SUBSET AND BYTE COUNTERS
C  --------------------------------------

      MBYT(LUN)   = MBYT(LUN)   + IBYT
      NSUB(LUN)   = NSUB(LUN)   + 1

      LBIT = (NBY0+NBY1+NBY2+4)*8
      CALL PKB(NSUB(LUN),16,MBAY(1,LUN),LBIT)

      LBYT = NBY0+NBY1+NBY2+NBY3
      NBYT = IUPB(MBAY(1,LUN),LBYT+1,24)
      LBIT = LBYT*8
      CALL PKB(NBYT+IBYT,24,MBAY(1,LUN),LBIT)

C  RESET THE USER ARRAYS AND EXIT NORMALLY
C  ---------------------------------------

      CALL USRTPL(LUN,1,1)
      GOTO 100

C  ON ENCOUTERING OVERLARGE SUBSETS, EXIT GRACEFULLY (SUBSET DISCARDED)
C  --------------------------------------------------------------------

900   IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*,'BUFRLIB: SUBUPD - SUBSET LONGER THAN ANY POSSIBLE ',
     . 'MESSAGE {SUBSET LENGTH= ',MBYT(LUN)+IBYT+8,', MESSAGE LENGTH= ',
     . MAXBYT,'}'
      PRINT*,'>>>>>>>OVERLARGE SUBSET DISCARDED FROM FILE<<<<<<<<'
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
      ENDIF

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE TABENT(LUN,NEMO,TAB,ITAB,IREP,IKNT,JUM0)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    TABENT
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE BUILDS AND STORES AN ENTRY FOR A TABLE B OR
C   TABLE D MNEMONIC (NEMO) WITHIN THE INTERNAL JUMP/LINK TABLE.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"; CORRECTED SOME MINOR ERRORS
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED HISTORY DOCUMENTATION; OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL TABENT (LUN, NEMO, TAB, ITAB, IREP, IKNT, JUM0)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     NEMO     - CHARACTER*8: TABLE B OR D MNEMONIC TO STORE IN JUMP/
C                LINK TABLE
C     TAB      - CHARACTER*1: INTERNAL BUFR TABLE ARRAY ('B' OR 'D') IN
C                WHICH NEMO IS DEFINED
C     ITAB     - INTEGER: POSITIONAL INDEX OF NEMO WITHIN TAB
C     IREP     - INTEGER: POSITIONAL INDEX WITHIN COMMON /REPTAB/
C                ARRAYS, FOR USE WHEN NEMO IS REPLICATED:
C                       0 = NEMO is not replicated
C     IKNT     - INTEGER: NUMBER OF REPLICATIONS, FOR USE WHEN NEMO IS
C                REPLICATED USING F=1 REGULAR (I.E., NON-DELAYED)
C                REPLICATION:
C                       0 = NEMO is not replicated using F=1 regular
C                           (i.e., non-delayed) replication
C     JUM0     - INTEGER: INDEX VALUE TO BE STORED FOR NEMO WITHIN
C                INTERNAL JUMP/LINK TABLE ARRAY JMPB(*)
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     INCTAB   NEMTBB
C    THIS ROUTINE IS CALLED BY: TABSUB
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)

C     Note that the values within the COMMON /REPTAB/ arrays were
C     initialized within subroutine BFRINI.

      COMMON /REPTAB/ IDNR(5,2),TYPS(5,2),REPS(5,2),LENS(5)

      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)
      COMMON /TABCCC/ ICDW,ICSC,ICRV

      CHARACTER*128 BORT_STR
      CHARACTER*24  UNIT
      CHARACTER*10  TAG,RTAG
      CHARACTER*8   NEMO
      CHARACTER*3   TYP,TYPS,TYPT
      CHARACTER*1   REPS,TAB

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  MAKE A JUMP/LINK TABLE ENTRY FOR A REPLICATOR
C  ---------------------------------------------

      IF(IREP.NE.0) THEN
         RTAG = REPS(IREP,1)//NEMO
         DO I=1,10
         IF(RTAG(I:I).EQ.' ') THEN
            RTAG(I:I) = REPS(IREP,2)
            CALL INCTAB(RTAG,TYPS(IREP,1),NODE)
            JUMP(NODE) = NODE+1
            JMPB(NODE) = JUM0
            LINK(NODE) = 0
            IBT (NODE) = LENS(IREP)
            IRF (NODE) = 0
            ISC (NODE) = 0
            IF(IREP.EQ.1) IRF(NODE) = IKNT
            JUM0 = NODE
            GOTO 1
         ENDIF
         ENDDO
         GOTO 900
      ENDIF

C  MAKE AN JUMP/LINK ENTRY FOR AN ELEMENT OR A SEQUENCE
C  ----------------------------------------------------

1     IF(TAB.EQ.'B') THEN
         CALL NEMTBB(LUN,ITAB,UNIT,ISCL,IREF,IBIT)
         IF(UNIT(1:5).EQ.'CCITT') TYPT = 'CHR'
         IF(UNIT(1:5).NE.'CCITT') TYPT = 'NUM'
         CALL INCTAB(NEMO,TYPT,NODE)
         JUMP(NODE) = 0
         JMPB(NODE) = JUM0
         LINK(NODE) = 0
         IBT (NODE) = IBIT
         IRF (NODE) = IREF
         ISC (NODE) = ISCL
         IF(UNIT(1:4).EQ.'CODE') TYPT = 'COD'
         IF(UNIT(1:4).EQ.'FLAG') TYPT = 'FLG'
         IF(TYPT.EQ.'NUM') THEN
            IBT(NODE) = IBT(NODE)+ICDW
            ISC(NODE) = ISC(NODE)+ICSC
         ENDIF
      ELSEIF(TAB.EQ.'D') THEN
         IF(IREP.EQ.0) TYPT = 'SEQ'
         IF(IREP.NE.0) TYPT = TYPS(IREP,2)
         CALL INCTAB(NEMO,TYPT,NODE)
         JUMP(NODE) = NODE+1
         JMPB(NODE) = JUM0
         LINK(NODE) = 0
         IBT (NODE) = 0
         IRF (NODE) = 0
         ISC (NODE) = 0
      ELSE
         GOTO 901
      ENDIF

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: TABENT - REPLICATOR ERROR FOR INPUT '//
     . 'MNEMONIC ",A,", RTAG IS ",A)') NEMO,RTAG
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: TABENT - UNDEFINED TAG (",A,") FOR '//
     . 'INPUT MNEMONIC ",A)') TAB,NEMO
      CALL BORT(BORT_STR)
      END
      SUBROUTINE TABSUB(LUN,NEMO)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    TABSUB
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE BUILDS THE ENTIRE JUMP/LINK TREE (I.E.,
C   INCLUDING RECURSIVELY RESOLVING ALL "CHILD" MNEMONICS) FOR A TABLE
C   A MNEMONIC (NEMO) WITHIN THE INTERNAL JUMP/LINK TABLE.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 2000-09-19  J. WOOLLEN -- ADDED CAPABILITY TO ENCODE AND DECODE DATA
C                           USING THE OPERATOR DESCRIPTORS (BUFR TABLE
C                           C) FOR CHANGING WIDTH AND CHANGING SCALE
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED HISTORY DOCUMENTATION; OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL TABSUB (LUN, NEMO)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     NEMO     - CHARACTER*8: TABLE A MNEMONIC
C
C REMARKS:
C    EXAMPLE SHOWING CONTENTS OF INTERNAL JUMP/LINK TABLE (WITHIN
C    COMMON /TABLES/):
C
C      INTEGER MAXTAB = maximum number of jump/link table entries
C
C      INTEGER NTAB = actual number of jump/link table entries
C                     currently in use
C
C      For I = 1, NTAB:
C
C      CHARACTER*10 TAG(I) = mnemonic
C
C      CHARACTER*3 TYP(I) = mnemonic type indicator:
C         "SUB" if TAG(I) is a Table A mnemonic
C         "SEQ" if TAG(I) is a Table D mnemonic using either short
C               (i.e. 1-bit) delayed replication, F=1 regular (i.e.
C               non-delayed) replication, or no replication at all
C         "RPC" if TAG(I) is a Table D mnemonic using either medium
C               (i.e. 8-bit) delayed replication or long (i.e. 16-bit)
C               delayed replication
C         "DRB" if TAG(I) denotes the short (i.e. 1-bit) delayed
C               replication of a Table D mnemonic (which would then
C               itself have its own separate entry in the jump/link
C               table with a corresponding TAG value of "SEQ")
C         "DRP" if TAG(I) denotes either the medium (i.e. 8-bit) or
C               long (i.e. 16-bit) delayed replication of a Table D
C               mnemonic (which would then itself have its own separate
C               entry in the jump/link table with a corresponding TAG
C               value of "RPC")
C         "REP" if TAG(I) denotes the F=1 regular (i.e. non-delayed)
C               replication of a Table D mnemonic (which would then
C               itself have its own separate entry in the jump/link
C               table with a corresponding TAG value of "SEQ")
C         "CHR" if TAG(I) is a Table B mnemonic with units "CCITT IA5"
C         "NUM" if TAG(I) is a Table B mnemonic with any units other
C               than "CCITT IA5"
C
C       INTEGER JMPB(I):
C
C       IF ( TYP(I) = "SUB" ) THEN
C          JMPB(I) = 0
C       ELSE IF ( ( TYP(I) = "SEQ" and TAG(I) uses either short (i.e.
C                   1-bit) delayed replication or F=1 regular (i.e.
C                   non-delayed) replication )
C                OR
C                 ( TYP(I) = "RPC" )  ) THEN
C          JMPB(I) = the index of the jump/link table entry denoting
C                    the replication of TAG(I)
C       ELSE
C          JMPB(I) = the index of the jump/link table entry for the
C                    Table A or Table D mnemonic of which TAG(I) is a
C                    child
C       END IF
C
C       INTEGER JUMP(I):
C
C       IF ( ( TYP(I) = "CHR" )  OR  ( TYP(I) = "NUM" ) ) THEN
C          JUMP(I) = 0
C       ELSE IF ( ( TYP(I) = "DRB" ) OR
C                 ( TYP(I) = "DRP" ) OR
C                 ( TYP(I) = "REP" ) ) THEN
C          JUMP(I) = the index of the jump/link table entry for the
C                    Table D mnemonic whose replication is denoted by
C                    TAG(I)
C       ELSE
C          JUMP(I) = the index of the jump/link table entry for the
C                    Table B or Table D mnemonic which, sequentially,
C                    is the first child of TAG(I)
C       END IF
C
C       INTEGER LINK(I):
C
C       IF ( ( TYP(I) = "SEQ" and TAG(I) uses either short (i.e.
C              1-bit) delayed replication or F=1 regular (i.e. non-
C              delayed) replication )
C           OR
C            ( TYP(I) = "SUB" )
C           OR
C            ( TYP(I) = "RPC" ) ) THEN
C              LINK(I) = 0
C       ELSE IF ( TAG(I) is, sequentially, the last child Table B or
C                 Table D mnemonic of the parent Table A or Table D
C                 mnemonic indexed by JMPB(I) ) THEN
C          LINK(I) = 0
C       ELSE
C          LINK(I) = the index of the jump/link table entry for the
C                    Table B or Table D mnemonic which, sequentially,
C                    is the next (i.e. following TAG(I)) child mnemonic
C                    of the parent Table A or Table D mnemonic indexed
C                    by JMPB(I)
C       END IF
C
C       INTEGER IBT(I):
C
C       IF ( ( TYP(I) = "CHR" )  OR  ( TYP(I) = "NUM" ) ) THEN
C          IBT(I) = bit width of Table B mnemonic TAG(I)
C       ELSE IF ( ( TYP(I) = "DRB" )  OR  ( TYP(I) = "DRP" ) ) THEN
C          IBT(I) = bit width of delayed descriptor replication factor
C                   (i.e. 1, 8, or 16, depending on the replication
C                   scheme denoted by TAG(I))
C       ELSE
C          IBT(I) = 0
C       END IF
C
C       INTEGER IRF(I):
C
C       IF ( TYP(I) = "NUM" ) THEN
C          IRF(I) = reference value of Table B mnemonic TAG(I)
C       ELSE IF ( TYP(I) = "REP" ) THEN
C          IRF(I) = number of F=1 regular (i.e. non-delayed)
C                   replications of Table D mnemonic TAG(JUMP(I))
C       ELSE
C          IRF(I) = 0
C       END IF
C
C       INTEGER ISC(I):
C
C       IF ( TYP(I) = "NUM" ) THEN
C          ISC(I) = scale factor of Table B mnemonic TAG(I)
C       ELSE IF ( TYP(I) = "SUB" ) THEN
C          ISC(I) = the index of the jump/link table entry which,
C                   sequentially, constitutes the last element of the
C                   jump/link tree for Table A mnemonic TAG(I)
C       ELSE
C          ISC(I) = 0
C       END IF
C
C
C
C    THIS ROUTINE CALLS:        BORT     INCTAB   NEMTAB   NEMTBD
C                               TABENT
C    THIS ROUTINE IS CALLED BY: MAKESTAB
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)

      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)
      COMMON /TABCCC/ ICDW,ICSC,ICRV

      CHARACTER*128 BORT_STR
      CHARACTER*10  TAG
      CHARACTER*8   NEMO,NEMS,NEM
      CHARACTER*3   TYP
      CHARACTER*1   TAB
      DIMENSION     NEM(250,10),IRP(250,10),KRP(250,10)
      DIMENSION     DROP(10),JMP0(10),NODL(10),NTAG(10,2)
      LOGICAL       DROP

      DATA MAXLIM /10/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  CHECK THE MNEMONIC
C  ------------------

C     Note that Table A mnemonics, in addition to being stored within
C     internal BUFR Table A array TABA(*,LUN), are also stored as
C     Table D mnemonics within internal BUFR Table D array TABD(*,LUN).
C     Thus, the following test is valid.

      CALL NEMTAB(LUN,NEMO,IDN,TAB,ITAB)
      IF(TAB.NE.'D') GOTO 900

C  STORE A SUBSET NODE AND JUMP/LINK THE TREE
C  ------------------------------------------

      CALL INCTAB(NEMO,'SUB',NODE)
      JUMP(NODE) = NODE+1
      JMPB(NODE) = 0
      LINK(NODE) = 0
      IBT (NODE) = 0
      IRF (NODE) = 0
      ISC (NODE) = 0

      CALL NEMTBD(LUN,ITAB,NSEQ,NEM(1,1),IRP(1,1),KRP(1,1))
      NTAG(1,1) = 1
      NTAG(1,2) = NSEQ
      JMP0(1)   = NODE
      LIMB      = 1

      ICDW = 0
      ICSC = 0
      ICRV = 0

C  THIS LOOP RESOLVES ENTITIES IN A SUBSET BY EMULATING RECURSION
C  --------------------------------------------------------------

1     DO N=NTAG(LIMB,1),NTAG(LIMB,2)

      NTAG(LIMB,1) = N+1
      NODL(LIMB)   = NTAB+1
      DROP(LIMB)   = N.EQ.NTAG(LIMB,2)

      CALL NEMTAB(LUN,NEM(N,LIMB),IDN,TAB,ITAB)
      NEMS = NEM(N,LIMB)

C  SPECIAL TREATMENT FOR CERTAIN OPERATOR DESCRIPTORS (TAB=C)
C  ----------------------------------------------------------

      IF(TAB.EQ.'C') THEN
         NODL(LIMB) = NTAB
         READ(NEMS,'(3X,I3)') IYYY
         IF(ITAB.EQ.1) THEN
            ICDW = IYYY-128
            IF(IYYY.EQ.0) ICDW = 0
         ELSEIF(ITAB.EQ.2) THEN
            ICSC = IYYY-128
            IF(IYYY.EQ.0) ICSC = 0
         ENDIF
      ELSE
         IREP = IRP(N,LIMB)
         IKNT = KRP(N,LIMB)
         JUM0 = JMP0(LIMB)
         CALL TABENT(LUN,NEMS,TAB,ITAB,IREP,IKNT,JUM0)
      ENDIF

      IF(TAB.EQ.'D') THEN

C        Note here how a new tree "LIMB" is created (and is then
C        immediately recursively resolved) whenever a Table D mnemonic
C        contains another Table D mnemonic as one of its children.

         LIMB = LIMB+1
         IF(LIMB.GT.MAXLIM) GOTO 901
         CALL NEMTBD(LUN,ITAB,NSEQ,NEM(1,LIMB),IRP(1,LIMB),KRP(1,LIMB))
         NTAG(LIMB,1) = 1
         NTAG(LIMB,2) = NSEQ
         JMP0(LIMB)   = NTAB
         GOTO 1
      ELSEIF(DROP(LIMB)) THEN
2        LINK(NODL(LIMB)) = 0
         LIMB = LIMB-1
         IF(LIMB.EQ.0 ) THEN
            IF(ICDW.NE.0) GOTO 902
            IF(ICSC.NE.0) GOTO 903
            GOTO 100
         ENDIF
         IF(DROP(LIMB)) GOTO 2
         LINK(NODL(LIMB)) = NTAB+1
         GOTO 1
      ELSEIF(TAB.NE.'C') THEN
         LINK(NODL(LIMB)) = NTAB+1
      ENDIF

      ENDDO

      GOTO 904

C  EXITS
C  -----

100   RETURN
900   WRITE(BORT_STR,'("BUFRLIB: TABSUB - SUBSET NODE NOT IN TABLE D '//
     . '(TAB=",A,") FOR INPUT MNEMONIC ",A)') TAB,NEMO
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: TABSUB - THERE ARE TOO MANY NESTED '//
     . 'TABLE D SEQUENCES (TREES) WITHIN INPUT MNEMONIC ",A," - THE '//
     . 'LIMIT IS",I4)') NEMO,MAXLIM
      CALL BORT(BORT_STR)
902   WRITE(BORT_STR,'("BUFRLIB: TABSUB - A CHANGE DATA WIDTH '//
     . 'OPERATOR WAS NOT CANCELLED (VIA 201000) IN THE TREE BUILT '//
     . 'FROM INPUT MNEMONIC ",A)') NEMO
      CALL BORT(BORT_STR)
903   WRITE(BORT_STR,'("BUFRLIB: TABSUB - A CHANGE DATA SCALE '//
     . 'OPERATOR WAS NOT CANCELLED (VIA 202000) IN THE TREE BUILT '//
     . 'FROM INPUT MNEMONIC ",A)') NEMO
      CALL BORT(BORT_STR)
904   WRITE(BORT_STR,'("BUFRLIB: TABSUB - ENTITIES WERE NOT '//
     . 'SUCCESSFULLY RESOLVED (BY EMULATING RESURSION) FOR SUBSET '//
     . 'DEFINED BY TBL A MNEM. ",A)') NEMO
      CALL BORT(BORT_STR)
      END
      SUBROUTINE TRYBUMP(LUNIT,LUN,USR,I1,I2,IO,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    TRYBUMP (docblock incomplete)
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE CHECKS THE FIRST NODE ASSOCIATED WITH A
C   CHARACTER STRING (PARSED INTO ARRAYS IN COMMON BLOCK /USRSTR/) IN
C   ORDER TO DETERMINE IF IT REPRESENTS A DELAYED REPLICATION SEQUENCE.
C   IF SO, THEN THE DELAYED REPLICATION SEQUENCE IS INITIALIZED, IT IS
C   "BUMPED" TO THE VALUE OF INPUT ARGUMENT I2, AND AN ATTEMPT IS MADE
C   TO READ OR WRITE SPECIFIED VALUES TO THE CURRENT BUFR DATA SET IN
C   UNIT LUNIT.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- IMPROVED MACHINE PORTABILITY
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY) (INCOMPLETE); OUTPUTS MORE
C                           COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL TRYBUMP (LUNIT, LUN, USR, I1, I2, IO, IRET)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C                (SEE REMARKS)
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C                (ASSOCIATED WITH FILE CONNECTED TO LOGICAL UNIT LUNIT)
C     USR      - REAL*8: (I1,I2) STARTING ADDRESS OF DATA VALUES READ
C                FROM OR WRITTEN TO DATA SUBSET
C     I1       - INTEGER: LENGTH OF FIRST DIMENSION OF USR
C     I2       - INTEGER: IF READING, LENGTH OF SECOND DIMENSION OF
C                USR; IF WRITING, NUMBER OF "LEVELS" OF DATA VALUES TO
C                BE WRITTEN TO DATA SUBSET
C     IO       - INTEGER: STATUS INDICATOR FOR BUFR FILE ASSOCIATED
C                WITH LUNIT:
C                       0 = input file
C                       1 = output file
C
C   OUTPUT ARGUMENT LIST:
C     IRET     - INTEGER: NUMBER OF "LEVELS" OF DATA VALUES READ FROM
C                OR WRITTEN TO DATA SUBSET (IF READING SHOULD BE NO
C                LARGER THAN I2, IF WRITING SHOULD BE SAME AS I2)
C                      -1 = ....
C
C REMARKS:
C    ARGUMENT LUNIT IS NOT REFERENCED IN THIS SUBROUTINE.  IT IS LEFT
C    HERE IN CASE AN APPLICATION PROGRAM CALLS THIS SUBROUTINE.
C
C    THIS ROUTINE CALLS:        BORT     INVWIN   LSTJPB   UFBRW
C                               USRTPL
C    THIS ROUTINE IS CALLED BY: UFBINT   UFBOVR
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /USRSTR/ NNOD,NCON,NODS(20),NODC(10),IVLS(10),KONS(10)

      REAL*8 USR(I1,I2),VAL

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  SEE IF THERE IS A DELAYED REPLICATION GROUP INVOLVED
C  ----------------------------------------------------

      NDRP = LSTJPB(NODS(1),LUN,'DRP')
      IF(NDRP.LE.0) GOTO 100

C  IF SO, CLEAN IT OUT AND BUMP IT TO I2
C  -------------------------------------

      INVN = INVWIN(NDRP,LUN,1,NVAL(LUN))
      VAL(INVN,LUN) = 0
      JNVN = INVN+1
      DO WHILE(NINT(VAL(JNVN,LUN)).GT.0)
         JNVN = JNVN+NINT(VAL(JNVN,LUN))
      ENDDO
      DO KNVN=1,NVAL(LUN)-JNVN+1
      INV(INVN+KNVN,LUN) = INV(JNVN+KNVN-1,LUN)
      VAL(INVN+KNVN,LUN) = VAL(JNVN+KNVN-1,LUN)
      ENDDO
      NVAL(LUN) = NVAL(LUN)-(JNVN-INVN-1)
      CALL USRTPL(LUN,INVN,I2)

C  FINALLY, CALL THE MNEMONIC READER/WRITER
C  ----------------------------------------

      CALL UFBRW(LUN,USR,I1,I2,IO,IRET)

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE UFBCNT(LUNIT,KMSG,KSUB)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBCNT
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE RETURNS A COUNT OF THE CURRENT MESSAGE
C   NUMBER AND SUBSET NUMBER, WHERE THE MESSAGE NUMBER IS RELATIVE TO
C   ALL MESSAGES IN THE BUFR FILE AND THE SUBSET NUMBER IS RELATIVE TO
C   ALL SUBSETS IN THE MESSAGE.  IF THE MESSAGE/SUBSET ARE BEING READ,
C   THE MESSAGE COUNT ADVANCES EACH TIME BUFR ARCHIVE LIBRARY
C   SUBROUTINE READMG (OR EQUIVALENT) IS CALLED AND THE SUBSET COUNT
C   ADVANCES EACH TIME BUFR ARCHIVE LIBRARY SUBROUTINE READSB (OR
C   EQUIVALENT) IS CALLED FOR A PARTICULAR MESSAGE.  IF THE MESSAGE/
C   SUBSET ARE BEING WRITTEN, THE MESSAGE COUNT ADVANCES EACH TIME
C   BUFR ARCHIVE LIBRARY SUBROUTINE OPENMG (OR EQUIVALENT) IS CALLED
C   AND THE SUBSET COUNT ADVANCES EACH TIME BUFR ARCHIVE LIBRARY
C   SUBROUTINE WRITSB (OR EQUIVALENT) IS CALLED.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL UFBCNT (LUNIT, KMSG, KSUB)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C   OUTPUT ARGUMENT LIST:
C     KMSG     - INTEGER: POINTER TO MESSAGE COUNT IN BUFR FILE
C                (INCLUDING MESSAGE CURRENTLY OPEN FOR READING/WRITING)
C     KSUB     - INTEGER: POINTER TO SUBSET COUNT IN BUFR MESSAGE
C                (INCLUDING SUBSET CURRENTLY OPEN FOR READING/WRITING)
C
C REMARKS:
C    IF AN APPLICATION PROGRAM DESIRES TO KNOW THE NUMBER OF SUBSETS IN
C    A BUFR MESSAGES JUST OPENED, IT MUST USE THE FUNCTION NMSUB RATHER
C    THAN THIS SUBROUTINE BECAUSE KSUB ONLY INCREMENTS BY ONE FOR EACH
C    CALL TO READSB (I.E., KSUB = 0 IMMEDIATELY AFTER READMG IS
C    CALLED).
C
C    THIS ROUTINE CALLS:        BORT     STATUS
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  CHECK THE FILE STATUS - RETURN THE MESSAGE AND SUBSET COUNTERS
C  --------------------------------------------------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      KMSG = NMSG(LUN)
      KSUB = NSUB(LUN)

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: STATUS - BUFR FILE IS CLOSED, IT MUST BE '//
     . 'OPEN FOR EITHER INPUT OR OUTPUT')
      END
      SUBROUTINE UFBCPY(LUBIN,LUBOT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBCPY
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE COPIES A COMPLETE SUBSET BUFFER, UNPACKED
C   INTO INTERNAL MEMORY FROM LOGICAL UNIT LUBIN BY A PREVIOUS CALL TO
C   BUFR ARCHIVE LIBRARY SUBROUTINE READSB, READERS OR READNS, TO
C   LOGICAL UNIT LUBOT.  BUFR ARCHIVE LIBRARY SUBROUTINE OPENMG OR
C   OPENMB MUST HAVE BEEN PREVIOUSLY CALLED TO OPEN AND INITIALIZE A
C   BUFR MESSAGE WITHIN MEMORY FOR LOGICAL UNIT LUBOU.  BOTH FILES MUST
C   HAVE BEEN OPENED TO THE INTERFACE (VIA A CALL TO BUFR ARCHIVE
C   LIBRARY SUBROUTINE OPENBF) WITH IDENTICAL BUFR TABLES.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY); OUTPUTS MORE COMPLETE DIAGNOSTIC
C                           INFO WHEN ROUTINE TERMINATES ABNORMALLY
C
C USAGE:    CALL UFBCPY (LUBIN, LUBOT)
C   INPUT ARGUMENT LIST:
C     LUBIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR INPUT BUFR
C                FILE
C     LUBOT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR OUTPUT BUFR
C                FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     STATUS
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)

      REAL*8 VAL

C----------------------------------------------------------------------
C----------------------------------------------------------------------

C  CHECK THE FILE STATUSES AND I-NODE
C  ----------------------------------

      CALL STATUS(LUBIN,LUI,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      IF(IM.EQ.0) GOTO 902
      IF(INODE(LUI).NE.INV(1,LUI)) GOTO 903

      CALL STATUS(LUBOT,LUO,IL,IM)
      IF(IL.EQ.0) GOTO 904
      IF(IL.LT.0) GOTO 905
      IF(IM.EQ.0) GOTO 906

      IF(INODE(LUI).NE.INODE(LUO)) GOTO 907

C  EVERYTHING OKAY COPY USER ARRAY FROM LUI TO LUO
C  -----------------------------------------------

      NVAL(LUO) = NVAL(LUI)

      DO N=1,NVAL(LUI)
      INV(N,LUO) = INV(N,LUI)
      VAL(N,LUO) = VAL(N,LUI)
      ENDDO

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: UFBCPY - INPUT BUFR FILE IS CLOSED, IT MUST'//
     . ' BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: UFBCPY - INPUT BUFR FILE IS OPEN FOR '//
     . 'OUTPUT, IT MUST BE OPEN FOR INPUT')
902   CALL BORT('BUFRLIB: UFBCPY - A MESSAGE MUST BE OPEN IN INPUT '//
     . 'BUFR FILE, NONE ARE')
903   CALL BORT('BUFRLIB: UFBCPY - LOCATION OF INTERNAL TABLE FOR '//
     . 'INPUT BUFR FILE DOES NOT AGREE WITH EXPECTED LOCATION IN '//
     . 'INTERNAL SUBSET ARRAY')
904   CALL BORT('BUFRLIB: UFBCPY - OUTPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR OUTPUT')
905   CALL BORT('BUFRLIB: UFBCPY - OUTPUT BUFR FILE IS OPEN FOR '//
     . 'INPUT, IT MUST BE OPEN FOR OUTPUT')
906   CALL BORT('BUFRLIB: UFBCPY - A MESSAGE MUST BE OPEN IN OUTPUT '//
     . 'BUFR FILE, NONE ARE')
907   CALL BORT('BUFRLIB: UFBCPY - INPUT AND OUTPUT BUFR FILES MUST '//
     . 'HAVE THE SAME INTERNAL TABLES, THEY ARE DIFFERENT HERE')
      END
      SUBROUTINE UFBCUP(LUBIN,LUBOT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBCUP
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE MAKES ONE COPY OF EACH UNIQUE ELEMENT IN AN
C   INPUT SUBSET BUFFER INTO THE IDENTICAL MNEMONIC SLOT IN THE OUTPUT
C   SUBSET BUFFER.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY); OUTPUTS MORE COMPLETE DIAGNOSTIC
C                           INFO WHEN ROUTINE TERMINATES ABNORMALLY
C
C USAGE:    CALL UFBCUP (LUBIN, LUBOT)
C   INPUT ARGUMENT LIST:
C     LUBIN    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR INPUT BUFR 
C                FILE
C     LUBOT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR OUTPUT BUFR 
C                FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     STATUS
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)

      CHARACTER*10 TAG,TAGI(MAXJL),TAGO
      CHARACTER*3  TYP
      DIMENSION    NINI(MAXJL)
      REAL*8       VAL

C----------------------------------------------------------------------
C----------------------------------------------------------------------

C  CHECK THE FILE STATUSES AND I-NODE
C  ----------------------------------

      CALL STATUS(LUBIN,LUI,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      IF(IM.EQ.0) GOTO 902
      IF(INODE(LUI).NE.INV(1,LUI)) GOTO 903

      CALL STATUS(LUBOT,LUO,IL,IM)
      IF(IL.EQ.0) GOTO 904
      IF(IL.LT.0) GOTO 905
      IF(IM.EQ.0) GOTO 906

C  MAKE A LIST OF UNIQUE TAGS IN INPUT BUFFER
C  ------------------------------------------

      NTAG = 0

      DO 5 NI=1,NVAL(LUI)
      NIN = INV(NI,LUI)
      IF(ITP(NIN).GE.2) THEN
         DO NV=1,NTAG
         IF(TAGI(NV).EQ.TAG(NIN)) GOTO 5
         ENDDO
         NTAG = NTAG+1
         NINI(NTAG) = NI
         TAGI(NTAG) = TAG(NIN)
      ENDIF
5     ENDDO

      IF(NTAG.EQ.0) GOTO 907

C  GIVEN A LIST MAKE ONE COPY OF COMMON ELEMENTS TO OUTPUT BUFFER
C  --------------------------------------------------------------

      DO 10 NV=1,NTAG
      NI = NINI(NV)
      DO NO=1,NVAL(LUO)
      TAGO = TAG(INV(NO,LUO))
      IF(TAGI(NV).EQ.TAGO) THEN
         VAL(NO,LUO) = VAL(NI,LUI)
         GOTO 10
      ENDIF
      ENDDO
10    ENDDO

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: UFBCUP - INPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: UFBCUP - INPUT BUFR FILE IS OPEN FOR '//
     . 'OUTPUT, IT MUST BE OPEN FOR INPUT')
902   CALL BORT('BUFRLIB: UFBCUP - A MESSAGE MUST BE OPEN IN INPUT '//
     . 'BUFR FILE, NONE ARE')
903   CALL BORT('BUFRLIB: UFBCUP - LOCATION OF INTERNAL TABLE FOR '//
     . 'INPUT BUFR FILE DOES NOT AGREE WITH EXPECTED LOCATION IN '//
     . 'INTERNAL SUBSET ARRAY')
904   CALL BORT('BUFRLIB: UFBCUP - OUTPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR OUTPUT')
905   CALL BORT('BUFRLIB: UFBCUP - OUTPUT BUFR FILE IS OPEN FOR '//
     . 'INPUT, IT MUST BE OPEN FOR OUTPUT')
906   CALL BORT('BUFRLIB: UFBCUP - A MESSAGE MUST BE OPEN IN OUTPUT '//
     . 'BUFR FILE, NONE ARE')
907   CALL BORT('BUFRLIB: UFBCUP - THERE ARE NO ELEMENTS (TAGS) IN '//
     . 'INPUT SUBSET BUFFER')
      END
      SUBROUTINE UFBDMP(LUNIN,LUPRT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBDMP
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE DUMPS A VERBOSE PRINT LISTING OF THE
C   CONTENTS OF THE UNPACKED DATA SUBSET CURRENTLY RESIDING IN THE
C   INTERNAL SUBSET ARRAYS ASSOCIATED WITH A BUFR FILE IN LOGICAL UNIT
C   ABS(LUNIN) OPENED FOR INPUT VIA A PREVIOUS CALL TO BUFR ARCHIVE
C   LIBRARY SUBROUTINE OPENBF.  THE DATA SUBSET MUST HAVE SUBSEQUENTLY
C   BEEN READ INTO THE INTERNAL BUFR ARCHIVE LIBRARY ARRAYS VIA CALLS
C   TO BUFR ARCHIVE LIBRARY SUBROUTINE READMG OR READERME FOLLOWED BY A
C   CALL TO BUFR ARCHIVE LIBRARY SUBROUTINE READSB OR READERS (OR VIA A
C   SINGLE CALL TO BUFR ARCHIVE LIBRARY SUBROUTINE READNS).  FOR A
C   PARTICULAR SUBSET, THIS LISTING CONTAINS EACH MNEMONIC ACCOMPANIED
C   BY ITS CORRESPONDING DATA VALUE AND OTHER POTENTIALLY USEFUL
C   INFORMATION SUCH AS WHICH OTHER MNEMONIC(S) THAT MNEMONIC WAS A
C   CONSTITUENT OF WITHIN THE OVERALL DATA SUBSET.  HOWEVER, IT ALSO
C   CONTAINS OTHER, MORE ESOTERIC INFORMATION SUCH AS BUFR STORAGE
C   CHARACTERISTICS AND A COPY OF THE JUMP/LINK TABLE USED INTERNALLY
C   WITHIN THE BUFR ARCHIVE LIBRARY SOFTWARE.  THIS SUBROUTINE IS
C   SIMILAR TO BUFR ARCHIVE LIBRARY SUBROUTINE UFDUMP EXCEPT THAT
C   UFDUMP DOES NOT PRINT POINTERS, COUNTERS AND THE OTHER, MORE
C   ESOTERIC INFORMATION DESCRIBING THE INTERNAL SUBSET STRUCTURES.
C   IN ADDITION, UFBDMP HAS THE ABILITY TO SCROLL THROUGH A SUBSET,
C   TWENTY ELEMENTS AT A TIME (SEE REMARKS).  UFDUMP DOES NOT HAVE
C   THIS CAPABILITY.  EACH SUBROUTINE, UFBDMP AND UFDUMP, IS USEFUL
C   FOR DIFFERENT DIAGNOSTIC PURPOSES, BUT IN GENERAL UFDUMP IS MORE
C   USEFUL FOR JUST LOOKING AT THE DATA ELEMENTS.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2002-05-14  J. WOOLLEN -- REMOVED OLD CRAY COMPILER DIRECTIVES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY); OUTPUTS MORE COMPLETE DIAGNOSTIC
C                           INFO WHEN ROUTINE TERMINATES ABNORMALLY OR
C                           FOR INFORMATIONAL PURPOSES; TEST FOR A
C                           MISSING VALUE NOW ALLOWS SOME FUZZINESS
C                           ABOUT 10E10 (RATHER THAN TRUE EQUALITY AS
C                           BEFORE) BECAUSE SOME MISSING VALUES (E.G.,
C                           CHARACTER STRINGS < 8 CHARACTERS) WERE NOT
C                           GETTING STAMPED OUT AS "MISSING"; ADDED
C                           OPTION TO PRINT VALUES USING FORMAT EDIT
C                           DESCRIPTOR "F15.6" IF LUNIN IS < ZERO,
C                           IF LUNIN IS > ZERO EDIT DESCRIPTOR EXPANDED
C                           FROM "G10.3" TO "G15.6" {REGARDLESS OF
C                           LUNIN, ADDITIONAL VALUES
C                           "IB,IS,IR,ND,JP,LK,JB" NOW PRINTED (THEY
C                           WERE COMMENTED OUT)}
C
C USAGE:    CALL UFBDMP (LUNIN, LUPRT)
C   INPUT ARGUMENT LIST:
C     LUNIN    - INTEGER: ABSOLUTE VALUE IS FORTRAN LOGICAL UNIT NUMBER
C                FOR BUFR FILE
C                  - IF LUNIN IS GREATER THAN ZERO, DATA VALUES ARE
C                    PRINTED OUT USING FORMAT DATA EDIT DESCRIPTOR
C                    "G15.6" (all values are printed since output
C                    format adapts to the magnitude of the data, but
C                    they are not lined up in columns according to
C                    decimal point)
C                  - IF LUNIN IS LESS THAN ZERO, DATA VALUES ARE
C                    PRINTED OUT USING FORMAT DATA EDIT DESCRIPTOR
C                    "F15.6" {values are lined up in columns according
C                    to decimal point, but data of large magnitude,
C                    (i.e., exceeding the format width of 15) get the
C                    overflow ("***************") print}
C     LUPRT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR PRINT OUTPUT
C                FILE
C                       0 = LUPRT is set to 06 (standard output) and
C                           the subroutine will scroll the output,
C                           twenty elements at a time (see REMARKS)
C
C   INPUT FILES:
C     UNIT 05  - STANDARD INPUT (SEE REMARKS)
C
C   OUTPUT FILES:
C     IF LUPRT > 0: UNIT "LUPRT" - PRINT (IF LUPRT=6, STANDARD OUTPUT)
C     IF LUPRT = 0: UNIT 06      - STANDARD OUTPUT PRINT (SEE REMARKS)
C                    
C
C REMARKS:
C    THIS ROUTINE WILL SCROLL THROUGH THE DATA SUBSET, TWENTY ELEMENTS
C    AT A TIME WHEN LUPRT IS INPUT AS "0".  IN THIS CASE, THE EXECUTING
C    SHELL SCRIPT SHOULD USE THE TERMINAL AS BOTH STANDARD INPUT AND
C    STANDARD OUTPUT.  INITIALLY, THE FIRST TWENTY ELEMENTS OF THE
C    CURRENT UNPACKED SUBSET WILL BE DISPLAYED ON THE TERMIMAL,
C    FOLLOWED BY THE PROMPT "(<enter> for MORE, q <enter> to QUIT)".
C    IF THE TERMINAL ENTERS ANYTHING OTHER THAN "q" FOLLOWED BY
C    "<enter>" (e.g., "<enter>"), THE NEXT TWENTY ELEMENTS WILL BE
C    DISPLAYED, AGAIN FOLLOWED BY THE SAME PROMPT.  THIS CONTINUES
C    UNTIL EITHER THE ENTIRE SUBSET HAS BEEN DISPLAYED, OR THE TERMINAL
C    ENTERS "q" FOLLOWED BY "<enter>" AFTER THE PROMPT, IN WHICH CASE
C    THIS SUBROUTINE STOPS THE SCROLL AND RETURNS TO THE CALLING
C    PROGRAM (PRESUMABLY TO READ IN THE NEXT SUBSET IN THE BUFR FILE).
C
C    THIS ROUTINE CALLS:        BORT     RJUST    STATUS
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)

      CHARACTER*10 TAG,TG
      CHARACTER*8  VC
      CHARACTER*3  TYP,TP
      CHARACTER*1  YOU
      EQUIVALENCE  (VL,VC)
      REAL*8       VAL,VL,BMISS

      DATA BMISS /10E10/, YOU /'Y'/

C----------------------------------------------------------------------

      IF(LUPRT.EQ.0) LUOUT = 6
      IF(LUPRT.NE.0) LUOUT = LUPRT

C  CHECK THE FILE STATUS AND I-NODE
C  --------------------------------

      LUNIT = ABS(LUNIN)
      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      IF(IM.EQ.0) GOTO 902
      IF(INODE(LUN).NE.INV(1,LUN)) GOTO 903

C  DUMP THE CONTENTS OF COMMON /USRINT/ FOR UNIT ABS(LUNIN)
C  --------------------------------------------------------

      DO NV=1,NVAL(LUN)
      IF(LUPRT.EQ.0 .AND. MOD(NV,20).EQ.0) THEN

C  When LUPRT=0, the output will be scrolled, 20 elements at a time
C  ----------------------------------------------------------------

         PRINT*,'(<enter> for MORE, q <enter> to QUIT)'
         READ(5,'(A1)') YOU

C  If the terminal enters "q" followed by "<enter>" after the prompt
C  "(<enter> for MORE, q <enter> to QUIT)", scrolling will end and the
C  subroutine will return to the calling program
C  -------------------------------------------------------------------

         IF(YOU.EQ.'q') THEN
         PRINT*
         PRINT*,'==> You have chosen to stop the dumping of this subset'
         PRINT*
            GOTO 100
         ENDIF
      ENDIF
      ND = INV (NV,LUN)
      VL = VAL (NV,LUN)
      TG = TAG (ND)
      TP = TYP (ND)
      IT = ITP (ND)
      IB = IBT (ND)
      IS = ISC (ND)
      IR = IRF (ND)
      JP = JUMP(ND)
      LK = LINK(ND)
      JB = JMPB(ND)
      RJ = RJUST(TG)
      IF(TP.NE.'CHR' .AND. VL.LT.BMISS) THEN
         IF(LUNIT.EQ.LUNIN) THEN
            WRITE(LUOUT,1) NV,TP,IT,TG,VL,IB,IS,IR,ND,JP,LK,JB
         ELSE
            WRITE(LUOUT,10) NV,TP,IT,TG,VL,IB,IS,IR,ND,JP,LK,JB
         ENDIF
      ELSE

C  Add some "fuzziness" about equality check due to machine diffs
C  --------------------------------------------------------------

cccccccccIF(VL.EQ.BMISS) THEN
         IF(VL.GT.BMISS-5000..AND.VL.LT.BMISS+5000.) THEN
            VC = 'MISSING'
         ELSE
            VC = VC(1:IB/8)
         ENDIF
         RJ = RJUST(VC)
         WRITE(LUOUT,2) NV,TP,IT,TG,VC,IB,IS,IR,ND,JP,LK,JB
      ENDIF
      ENDDO

      WRITE(LUOUT,3)

1     FORMAT(I5,1X,A3,'-',I1,1X,A10,1X,G15.6,7(1X,I5))
10    FORMAT(I5,1X,A3,'-',I1,1X,A10,1X,F15.6,7(1X,I5))
2     FORMAT(I5,1X,A3,'-',I1,1X,A10,6X,'"',A8,'"',7(1X,I5))
3     FORMAT(/' >>> END OF SUBSET <<< '/)

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: UFBDMP - INPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: UFBDMP - INPUT BUFR FILE IS OPEN FOR '//
     . 'OUTPUT, IT MUST BE OPEN FOR INPUT')
902   CALL BORT('BUFRLIB: UFBDMP - A MESSAGE MUST BE OPEN IN INPUT '//
     . 'BUFR FILE, NONE ARE')
903   CALL BORT('BUFRLIB: UFBDMP - LOCATION OF INTERNAL TABLE FOR '//
     . 'INPUT BUFR FILE DOES NOT AGREE WITH EXPECTED LOCATION IN '//
     . 'INTERNAL SUBSET ARRAY')
      END
      SUBROUTINE UFBEVN(LUNIT,USR,I1,I2,I3,IRET,STR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBEVN
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE READS SPECIFIED VALUES FROM THE CURRENT
C   BUFR DATA SUBSET WITHIN INTERNAL ARRAYS.  THE DATA VALUES
C   CORRESPOND TO MNEMONICS WHICH ARE PART OF A MULTIPLE-REPLICATION
C   SEQUENCE WITHIN ANOTHER MULTIPLE-REPLICATION SEQUENCE.  THE INNER
C   SEQUENCE IS USUALLY ASSOCIATED WITH DATA "LEVELS" AND THE OUTER
C   SEQUENCE WITH DATA "EVENTS".  THE BUFR FILE IN LOGICAL UNIT LUNIT
C   MUST HAVE BEEN OPENED FOR INPUT VIA A PREVIOUS CALL TO BUFR ARCHIVE
C   LIBRARY SUBROUTINE OPENBF.   IN ADDITION, THE DATA SUBSET MUST HAVE
C   SUBSEQUENTLY BEEN READ INTO THE INTERNAL BUFR ARCHIVE LIBRARY
C   ARRAYS VIA CALLS TO BUFR ARCHIVE LIBRARY SUBROUTINE READMG OR
C   READERME FOLLOWED BY A CALL TO BUFR ARCHIVE LIBRARY SUBROUTINE
C   READSB OR READERS (OR VIA A SINGLE CALL TO BUFR ARCHIVE LIBRARY
C   SUBROUTINE READNS).  OTHER THAN THE ADDITION OF A THIRD
C   DIMENSION AND THE READ ONLY RESTRICTION, THE CONTEXT AND USAGE OF
C   UFBEVN IS EXACTLY THE SAME AS FOR BUFR ARCHIVE LIBRARY SUBROUTINES
C   UFBINT, UFBREP AND UFBSEQ.  THIS SUBROUTINE IS DESIGNED TO READ
C   EVENT INFORMATION FROM "PREPBUFR" TYPE BUFR FILES.  PREPBUFR FILES
C   HAVE THE FOLLOWING BUFR TABLE EVENT STRUCTURE (NOTE SIXTEEN
C   CHARACTERS HAVE BEEN REMOVED FROM THE LAST COLUMN TO ALLOW THE
C   TABLE TO FIT IN THIS DOCBLOCK):
C
C   | ADPUPA   | HEADR  {PLEVL}                                    |
C   | HEADR    | SID  XOB  YOB  DHR  ELV  TYP  T29  TSB  ITP  SQN  |
C   | PLEVL    | CAT <PINFO> <QINFO> <TINFO> <ZINFO> <WINFO>       |
C   | PINFO    | [PEVN]             <PBACKG>  <PPOSTP>             |
C   | QINFO    | [QEVN]    TDO      <QBACKG>  <QPOSTP>             |
C   | TINFO    | [TEVN]    TVO      <TBACKG>  <TPOSTP>             |
C   | ZINFO    | [ZEVN]             <ZBACKG>  <ZPOSTP>             |
C   | WINFO    | [WEVN]             <WBACKG>  <WPOSTP>             |
C   | PEVN     | POB  PQM  PPC  PRC                                |
C   | QEVN     | QOB  QQM  QPC  QRC                                |
C   | TEVN     | TOB  TQM  TPC  TRC                                |
C   | ZEVN     | ZOB  ZQM  ZPC  ZRC                                |
C   | WEVN     | UOB  WQM  WPC  WRC  VOB                           |
C   | PBACKG   | POE  PFC                                          |
C   | QBACKG   | QOE  QFC                                          |
C   | TBACKG   | TOE  TFC                                          |
C   | ZBACKG   | ZOE  ZFC                                          |
C   | WBACKG   | WOE  UFC  VFC                                     |
C   | PPOSTP   | PAN                                               |
C   | QPOSTP   | QAN                                               |
C   | TPOSTP   | TAN                                               |
C   | ZPOSTP   | ZAN                                               |
C   | WPOSTP   | UAN  VAN                                          |
C
C   NOTE THAT THE EIGHT-BIT DELAYED REPLIATION EVENT SEQUENCES "[xxxx]"
C   ARE NESTED INSIDE ONE-BIT DELAYED REPLICATED SEQUENCES "<yyyy>".
C   THE ANALOGOUS BUFR ARCHIVE LIBRARY SUBROUTINE UFBIN3 DOES NOT WORK
C   PROPERLY ON THIS TYPE OF EVENT STRUCTURE.  IT WORKS ONLY ON THE
C   EVENT STRUCTURE FOUND IN "PREPFITS" TYPE BUFR FILES (SEE UFBIN3 FOR
C   MORE DETAILS).  IN TURN, UFBEVN DOES NOT WORK PROPERLY ON THE EVENT
C   STRUCTURE FOUND IN PREPFITS FILES (ALWAYS USE UFBIN3 IN THIS CASE).
C   ONE OTHER DIFFERENCE BETWEEN UFBEVN AND UFBIN3 IS THAT UFBEVN
C   STORES THE MAXIMUM NUMBER OF EVENTS FOUND FOR ALL DATA VALUES
C   SPECIFIED AMONGST ALL LEVELS RETURNED INTERNALLY IN COMMON BLOCK
C   /UFBN3C/.  UFBIN3 RETURNS THIS VALUE AS AN ADDITIONAL OUTPUT
C   ARGUMENT.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"; IMPROVED MACHINE
C                           PORTABILITY
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  J. WOOLLEN -- SAVES THE MAXIMUM NUMBER OF EVENTS FOUND
C                           FOR ALL DATA VALUES SPECIFIED AMONGST ALL
C                           LEVELS RETURNED AS VARIABLE MAXEVN IN NEW
C                           COMMON BLOCK /UFBN3C/
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); ADDED CALL TO BORT
C                           IF BUFR FILE IS OPEN FOR OUTPUT; UNIFIED/
C                           PORTABLE FOR WRF; ADDED DOCUMENTATION
C                           (INCLUDING HISTORY); OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY OR UNUSUAL THINGS HAPPEN
C
C USAGE:    CALL UFBEVN (LUNIT, USR, I1, I2, I3, IRET, STR)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     I1       - INTEGER: LENGTH OF FIRST DIMENSION OF USR OR THE
C                NUMBER OF BLANK-SEPARATED MNEMONICS IN STR (FORMER
C                MUST BE .GE. LATTER)
C     I2       - INTEGER: LENGTH OF SECOND DIMENSION OF USR
C     I3       - INTEGER: LENGTH OF THIRD DIMENSION OF USR (MAXIMUM
C                VALUE IS 255)
C     STR      - CHARACTER*(*): STRING OF BLANK-SEPARATED TABLE B
C                MNEMONICS IN ONE-TO-ONE CORRESPONDENCE WITH FIRST
C                DIMENSION OF USR
C
C   OUTPUT ARGUMENT LIST:
C     USR      - REAL*8: (I1,I2,I3) STARTING ADDRESS OF DATA VALUES
C                READ FROM DATA SUBSET
C     IRET     - INTEGER: NUMBER OF "LEVELS" OF DATA VALUES READ FROM
C                DATA SUBSET (MUST BE NO LARGER THAN I2)
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    APPLICATION PROGRAMS READING PREPFITS FILES SHOULD NOT CALL THIS
C    ROUTINE.
C
C    THIS ROUTINE CALLS:        BORT     CONWIN   GETWIN   NVNWIN
C                               NXTWIN   STATUS   STRING
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /USRSTR/ NNOD,NCON,NODS(20),NODC(10),IVLS(10),KONS(10)
      COMMON /UFBN3C/ MAXEVN
      COMMON /QUIET / IPRT

      CHARACTER*(*) STR
      DIMENSION     INVN(255)
      REAL*8        VAL,USR(I1,I2,I3),BMISS

      DATA BMISS /10E10/

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      MAXEVN = 0
      IRET   = 0

C  CHECK THE FILE STATUS AND I-NODE
C  --------------------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      IF(IM.EQ.0) GOTO 902
      IF(INODE(LUN).NE.INV(1,LUN)) GOTO 903

      IF(I1.LE.0) THEN
         IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
         PRINT*,'BUFRLIB: UFBEVN - THIRD ARGUMENT (INPUT) IS .LE. 0',
     .    ' -  RETURN WITH SIXTH ARGUMENT (IRET) = 0'
         PRINT*,'STR = ',STR
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
         GOTO 100
      ELSEIF(I2.LE.0) THEN
         IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
         PRINT*,'BUFRLIB: UFBEVN - FOURTH ARGUMENT (INPUT) IS .LE. 0',
     .    ' -  RETURN WITH SIXTH ARGUMENT (IRET) = 0'
         PRINT*,'STR = ',STR
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
         GOTO 100
      ELSEIF(I3.LE.0) THEN
         IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
         PRINT*,'BUFRLIB: UFBEVN - FIFTH ARGUMENT (INPUT) IS .LE. 0',
     .    ' -  RETURN WITH SIXTH ARGUMENT (IRET) = 0'
         PRINT*,'STR = ',STR
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
         GOTO 100
      ENDIF

C  PARSE OR RECALL THE INPUT STRING
C  --------------------------------

      CALL STRING(STR,LUN,I1,0)

C  INITIALIZE USR ARRAY
C  --------------------

      DO K=1,I3
      DO J=1,I2
      DO I=1,I1
      USR(I,J,K) = BMISS
      ENDDO
      ENDDO
      ENDDO

C  LOOP OVER COND WINDOWS
C  ----------------------

      INC1 = 1
      INC2 = 1

1     CALL CONWIN(LUN,INC1,INC2,I2)
      IF(NNOD.EQ.0) THEN
         IRET = I2
         GOTO 100
      ELSEIF(INC1.EQ.0) THEN
         GOTO 100
      ELSE
         DO I=1,NNOD
         IF(NODS(I).GT.0) THEN
            INS2 = INC1
            CALL GETWIN(NODS(I),LUN,INS1,INS2)
            IF(INS1.EQ.0) GOTO 100
            GOTO 2
         ENDIF
         ENDDO
         INS1 = INC1
         INS2 = INC2
      ENDIF

C  READ PUSH DOWN STACK DATA INTO 3D ARRAYS
C  ----------------------------------------

2     IRET = IRET+1
      IF(IRET.LE.I2) THEN
         DO I=1,NNOD
         IF(NODS(I).GT.0) THEN
            NNVN = NVNWIN(NODS(I),LUN,INS1,INS2,INVN,I3)
            MAXEVN = MAX(NNVN,MAXEVN)
            DO N=1,NNVN
            USR(I,IRET,N) = VAL(INVN(N),LUN)
            ENDDO
         ENDIF
         ENDDO
      ENDIF

C  DECIDE WHAT TO DO NEXT
C  ----------------------

      CALL NXTWIN(LUN,INS1,INS2)
      IF(INS1.GT.0 .AND. INS1.LT.INC2) GOTO 2
      IF(NCON.GT.0) GOTO 1

      IF(IRET.EQ.0)  THEN
         IF(IPRT.GE.1)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
            PRINT*,'BUFRLIB: UFBEVN - NO SPECIFIED VALUES READ IN - ',
     .       'RETURN WITH SIXTH ARGUMENT (IRET) = 0'
            PRINT*,'STR = ',STR
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
      ENDIF

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: UFBEVN - INPUT BUFR FILE IS CLOSED, IT MUST'//
     . ' BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: UFBEVN - INPUT BUFR FILE IS OPEN FOR OUTPUT'//
     . ', IT MUST BE OPEN FOR INPUT')
902   CALL BORT('BUFRLIB: UFBEVN - A MESSAGE MUST BE OPEN IN INPUT '//
     . 'BUFR FILE, NONE ARE')
903   CALL BORT('BUFRLIB: UFBEVN - LOCATION OF INTERNAL TABLE FOR '//
     . 'INPUT BUFR FILE DOES NOT AGREE WITH EXPECTED LOCATION IN '//
     . 'INTERNAL SUBSET ARRAY')
      END
      SUBROUTINE UFBGET(LUNIT,TAB,I1,IRET,STR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBGET
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE UNPACKS AND RETURNS THE VALUES FOR ONE-
C   DIMENSIONAL DESCRIPTORS IN THE INPUT STRING WITHOUT ADVANCING THE
C   SUBSET POINTER.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"; IMPROVED MACHINE
C                           PORTABILITY
C 1998-10-27  J. WOOLLEN -- MODIFIED TO CORRECT PROBLEMS CAUSED BY IN-
C                           LINING CODE WITH FPP DIRECTIVES
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2002-05-14  J. WOOLLEN -- REMOVED OLD CRAY COMPILER DIRECTIVES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY); OUTPUTS MORE COMPLETE DIAGNOSTIC
C                           INFO WHEN ROUTINE TERMINATES ABNORMALLY
C
C USAGE:    CALL UFBGET (LUNIT, TAB, I1, IRET, STR)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     I1       - INTEGER: LENGTH OF TAB
C     STR      - CHARACTER*(*): STRING OF BLANK-SEPARATED TABLE B
C                MNEMONICS IN ONE-TO-ONE CORRESPONDENCE WITH THE WORDS
C                IN THE ARRAY TAB
C
C   OUTPUT ARGUMENT LIST:
C     TAB      - REAL*8: (I1) STARTING ADDRESS OF DATA VALUES READ FROM
C                DATA SUBSET
C     IRET     - INTEGER: RETURN CODE:
C                       0 = normal return
C                      -1 = there are no more subsets in the BUFR
C                           message
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     INVWIN   STATUS   STRING
C                               UPBB     UPC      USRTPL
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /USRSTR/ NNOD,NCON,NODS(20),NODC(10),IVLS(10),KONS(10)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)
      COMMON /USRBIT/ NBIT(MAXJL),MBIT(MAXJL)

      CHARACTER*(*) STR
      CHARACTER*10  TAG
      CHARACTER*8   CVAL
      CHARACTER*3   TYP
      EQUIVALENCE   (CVAL,RVAL)
      REAL*8        VAL,RVAL,TAB(I1),BMISS,UPS,TEN

      DATA BMISS /10E10/
      DATA TEN   /10/

C-----------------------------------------------------------------------
      MPS(NODE) = 2**(IBT(NODE))-1
      UPS(NODE) = (IVAL+IRF(NODE))*TEN**(-ISC(NODE))
C-----------------------------------------------------------------------

      IRET = 0

      DO I=1,I1
      TAB(I) = BMISS
      ENDDO

C  MAKE SURE A FILE/MESSAGE IS OPEN FOR INPUT
C  ------------------------------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      IF(IM.EQ.0) GOTO 902

C  SEE IF THERE IS ANOTHER SUBSET IN THE MESSAGE
C  ---------------------------------------------

      IF(NSUB(LUN).EQ.MSUB(LUN)) THEN
         IRET = -1
         GOTO 100
      ENDIF

C  PARSE THE STRING
C  ----------------

      CALL STRING(STR,LUN,I1,0)

C  EXPAND THE TEMPLATE FOR THIS SUBSET AS LITTLE AS POSSIBLE
C  ---------------------------------------------------------

      N = 1
      NBIT(N) = 0
      MBIT(N) = MBYT(LUN)*8 + 16
      CALL USRTPL(LUN,N,N)

10    DO N=N+1,NVAL(LUN)
      NODE = INV(N,LUN)
      NBIT(N) = IBT(NODE)
      MBIT(N) = MBIT(N-1)+NBIT(N-1)
      IF(NODE.EQ.NODS(NNOD)) THEN
         NVAL(LUN) = N
         GOTO 20
      ELSEIF(ITP(NODE).EQ.1) THEN
         CALL UPBB(IVAL,NBIT(N),MBIT(N),MBAY(1,LUN))
         CALL USRTPL(LUN,N,IVAL)
         GOTO 10
      ENDIF
      ENDDO
20    CONTINUE

C  UNPACK ONLY THE NODES FOUND IN THE STRING
C  -----------------------------------------

      DO I=1,NNOD
      NODE = NODS(I)
      INVN = INVWIN(NODE,LUN,1,NVAL(LUN))
      IF(INVN.GT.0) THEN
         CALL UPBB(IVAL,NBIT(INVN),MBIT(INVN),MBAY(1,LUN))
         IF(ITP(NODE).EQ.1) THEN
            TAB(I) = IVAL
         ELSEIF(ITP(NODE).EQ.2) THEN
            IF(IVAL.LT.MPS(NODE)) TAB(I) = UPS(NODE)
         ELSEIF(ITP(NODE).EQ.3) THEN
            CVAL = ' '
            KBIT = MBIT(INVN)
            CALL UPC(CVAL,NBIT(INVN)/8,MBAY(1,LUN),KBIT)
            TAB(I) = RVAL
         ENDIF
      ELSE
         TAB(I) = BMISS
      ENDIF
      ENDDO

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: UFBGET - INPUT BUFR FILE IS CLOSED, IT MUST'//
     . ' BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: UFBGET - INPUT BUFR FILE IS OPEN FOR OUTPUT'//
     . ', IT MUST BE OPEN FOR INPUT')
902   CALL BORT('BUFRLIB: UFBGET - A MESSAGE MUST BE OPEN IN INPUT '//
     . 'BUFR FILE, NONE ARE')
      END
      SUBROUTINE UFBIN3(LUNIT,USR,I1,I2,I3,IRET,JRET,STR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBIN3
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2003-11-04
C
C ABSTRACT: THIS SUBROUTINE READS SPECIFIED VALUES FROM THE CURRENT
C   BUFR DATA SUBSET WITHIN INTERNAL ARRAYS.  THE DATA VALUES
C   CORRESPOND TO MNEMONICS WHICH ARE PART OF A MULTIPLE-REPLICATION
C   SEQUENCE WITHIN ANOTHER MULTIPLE-REPLICATION SEQUENCE.  THE INNER
C   SEQUENCE IS USUALLY ASSOCIATED WITH DATA "LEVELS" AND THE OUTER
C   SEQUENCE WITH DATA "EVENTS".  THE BUFR FILE IN LOGICAL UNIT LUNIT
C   MUST HAVE BEEN OPENED FOR INPUT VIA A PREVIOUS CALL TO BUFR ARCHIVE
C   LIBRARY SUBROUTINE OPENBF.  IN ADDITION, THE DATA SUBSET MUST HAVE
C   SUBSEQUENTLY BEEN READ INTO THE INTERNAL BUFR ARCHIVE LIBRARY
C   ARRAYS VIA CALLS TO BUFR ARCHIVE LIBRARY SUBROUTINE READMG OR
C   READERME FOLLOWED BY A CALL TO BUFR ARCHIVE LIBRARY SUBROUTINE
C   READSB OR READERS (OR VIA A SINGLE CALL TO BUFR ARCHIVE LIBRARY
C   SUBROUTINE READNS).  THIS SUBROUTINE IS DESIGNED TO READ EVENT
C   INFORMATION FROM "PREPFITS" TYPE BUFR FILES (BUT NOT FROM
C   "PREPBUFR" TYPE FILES!!).  PREPFITS FILES HAVE THE FOLLOWING BUFR
C   TABLE EVENT STRUCTURE (NOTE SIXTEEN CHARACTERS HAVE BEEN REMOVED
C   FROM THE LAST COLUMN TO ALLOW THE TABLE TO FIT IN THIS DOCBLOCK):
C
C   | ADPUPA   | HEADR  {PLEVL}                                    |
C   | HEADR    | SID XOB YOB DHR ELV TYP T29 ITP                   |
C   | PLEVL    | CAT PRC PQM QQM TQM ZQM WQM CDTP_QM [OBLVL]       |
C   | OBLVL    | SRC FHR <PEVN> <QEVN> <TEVN> <ZEVN> <WEVN> <CEVN> |
C   | OBLVL    | <CTPEVN>                                          |
C   | PEVN     | POB  PMO                                          |
C   | QEVN     | QOB                                               |
C   | TEVN     | TOB                                               |
C   | ZEVN     | ZOB                                               |
C   | WEVN     | UOB  VOB                                          |
C   | CEVN     | CAPE CINH LI                                      |
C   | CTPEVN   | CDTP GCDTT TOCC                                   |
C
C   NOTE THAT THE ONE-BIT DELAYED REPLICATED SEQUENCES "<xxxx>" ARE
C   NESTED INSIDE THE EIGHT-BIT DELAYED REPLIATION EVENT SEQUENCES
C   "[yyyy]".  THE ANALOGOUS BUFR ARCHIVE LIBRARY SUBROUTINE UFBEVN
C   DOES NOT WORK PROPERLY ON THIS TYPE OF EVENT STRUCTURE.  IT WORKS
C   ONLY ON THE EVENT STRUCTURE FOUND IN "PREPBUFR" TYPE BUFR FILES
C   (SEE UFBEVN FOR MORE DETAILS).  IN TURN, UFBIN3 DOES NOT WORK
C   PROPERLY ON THE EVENT STRUCTURE FOUND IN PREPBUFR FILES (ALWAYS USE
C   UFBEVN IN THIS CASE).  ONE OTHER DIFFERENCE BETWEEN UFBIN3 AND
C   UFBEVN IS THAT UFBIN3 RETURNS THE MAXIMUM NUMBER OF EVENTS FOUND
C   FOR ALL DATA VALUES SPECIFIED AS AN OUTPUT ARGUMENT (JRET).  UFBEVN
C   DOES NOT DO THIS, BUT RATHER IT STORES THIS VALUE INTERNALLY IN
C   COMMON BLOCK /UFBN3C/.
C
C PROGRAM HISTORY LOG:
C 2003-11-04  J. WOOLLEN -- ORIGINAL AUTHOR (WAS IN VERIFICATION
C                           VERSION)
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY OR UNUSUAL THINGS HAPPEN
C
C USAGE:    CALL UFBIN3 (LUNIT, USR, I1, I2, I3, IRET, JRET, STR)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     I1       - INTEGER: LENGTH OF FIRST DIMENSION OF USR OR THE
C                NUMBER OF BLANK-SEPARATED MNEMONICS IN STR (FORMER
C                MUST BE .GE. LATTER)
C     I2       - INTEGER: LENGTH OF SECOND DIMENSION OF USR
C     I3       - INTEGER: LENGTH OF THIRD DIMENSION OF USR (MAXIMUM
C                VALUE IS 255)
C     STR      - CHARACTER*(*): STRING OF BLANK-SEPARATED TABLE B
C                MNEMONICS IN ONE-TO-ONE CORRESPONDENCE WITH FIRST
C                DIMENSION OF USR
C
C   OUTPUT ARGUMENT LIST:
C     USR      - REAL*8: (I1,I2,I3) STARTING ADDRESS OF DATA VALUES
C                READ FROM DATA SUBSET
C     IRET     - INTEGER: NUMBER OF "LEVELS" OF DATA VALUES READ FROM
C                DATA SUBSET (MUST BE NO LARGER THAN I2)
C     JRET     - INTEGER: MAXIMUM NUMBER OF "EVENTS" FOUND FOR ALL DATA
C                VALUES SPECIFIED AMONGST ALL LEVELS READ FROM DATA
C                SUBSET (MUST BE NO LARGER THAN I3)
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    IMPORTANT: THIS ROUTINE SHOULD ONLY BE CALLED BY THE VERIFICATION
C               APPLICATION PROGRAM "GRIDTOBS", WHERE IT WAS PREVIOUSLY
C               AN IN-LINE SUBROUTINE.  IN GENERAL, UFBIN3 DOES NOT
C               WORK PROPERLY IN OTHER APPLICATION PROGRAMS (I.E, THOSE
C               THAT ARE READING PREPBUFR FILES) AT THIS TIME.  ALWAYS
C               USE UFBEVN INSTEAD!!
C
C    THIS ROUTINE CALLS:        BORT     CONWIN   GETWIN   NEVN
C                               NXTWIN   STATUS   STRING
C    THIS ROUTINE IS CALLED BY: None
C                               SHOULD NOT BE CALLED BY ANY APPLICATION
C                               PROGRAMS EXCEPT GRIDTOBS!!
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /USRSTR/ NNOD,NCON,NODS(20),NODC(10),IVLS(10),KONS(10)
      COMMON /QUIET / IPRT

      CHARACTER*(*) STR
      REAL*8        VAL,USR(I1,I2,I3),BMISS

      DATA BMISS /10E10/

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      IRET = 0
      JRET = 0

C  CHECK THE FILE STATUS AND I-NODE
C  --------------------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      IF(IM.EQ.0) GOTO 902
      IF(INODE(LUN).NE.INV(1,LUN)) GOTO 903

      IF(I1.LE.0) THEN
         IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
         PRINT*,'BUFRLIB: UFBIN3 - THIRD ARGUMENT (INPUT) IS .LE. 0',
     .    ' -  RETURN WITH SIXTH AND SEVENTH ARGUMENTS (IRET, JRET) = 0'
         PRINT*,'STR = ',STR
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
         GOTO 100
      ELSEIF(I2.LE.0) THEN
         IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
         PRINT*,'BUFRLIB: UFBIN3 - FOURTH ARGUMENT (INPUT) IS .LE. 0',
     .    ' -  RETURN WITH SIXTH AND SEVENTH ARGUMENTS (IRET, JRET) = 0'
         PRINT*,'STR = ',STR
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
         GOTO 100
      ELSEIF(I3.LE.0) THEN
         IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
         PRINT*,'BUFRLIB: UFBIN3 - FIFTH ARGUMENT (INPUT) IS .LE. 0',
     .    ' -  RETURN WITH SIXTH AND SEVENTH ARGUMENTS (IRET, JRET) = 0'
         PRINT*,'STR = ',STR
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
         GOTO 100
      ENDIF

C  PARSE OR RECALL THE INPUT STRING
C  --------------------------------

      CALL STRING(STR,LUN,I1,0)

C  INITIALIZE USR ARRAY
C  --------------------

      DO K=1,I3
      DO J=1,I2
      DO I=1,I1
      USR(I,J,K) = BMISS
      ENDDO
      ENDDO
      ENDDO

C  LOOP OVER COND WINDOWS
C  ----------------------

      INC1 = 1
      INC2 = 1

1     CALL CONWIN(LUN,INC1,INC2,I2)
      IF(NNOD.EQ.0) THEN
        IRET = I2
        GOTO 100
      ELSEIF(INC1.EQ.0) THEN
        GOTO 100
      ELSE
        DO I=1,NNOD
        IF(NODS(I).GT.0) THEN
           INS2 = INC1
           CALL GETWIN(NODS(I),LUN,INS1,INS2)
           IF(INS1.EQ.0) GOTO 100
           GOTO 2
        ENDIF
        ENDDO
        INS1 = INC1
        INS2 = INC2
      ENDIF

C  READ PUSH DOWN STACK DATA INTO 3D ARRAYS
C  ----------------------------------------

2     IRET = IRET+1
      IF(IRET.LE.I2) THEN
         DO I=1,NNOD
            NNVN = NEVN(NODS(I),LUN,INS1,INS2,I1,I2,I3,USR(I,IRET,1))
            JRET = MAX(JRET,NNVN)
         ENDDO
      ENDIF

C  DECIDE WHAT TO DO NEXT
C  ----------------------

      CALL NXTWIN(LUN,INS1,INS2)
      IF(INS1.GT.0 .AND. INS1.LT.INC2) GOTO 2
      IF(NCON.GT.0) GOTO 1

      IF(IRET.EQ.0 .OR. JRET.EQ.0)  THEN
         IF(IPRT.GE.1)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
            PRINT*,'BUFRLIB: UFBIN3 - NO SPECIFIED VALUES READ IN - ',
     .       'RETURN WITH SIXTH ARGUMENT (IRET) = 0 AND/OR SEVENTH ',
     .       'ARGUMENT (JRET) = 0'
            PRINT*,'STR = ',STR
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
      ENDIF

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: UFBIN3 - INPUT BUFR FILE IS CLOSED, IT MUST'//
     . ' BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: UFBIN3 - INPUT BUFR FILE IS OPEN FOR OUTPUT'//
     . ', IT MUST BE OPEN FOR INPUT')
902   CALL BORT('BUFRLIB: UFBIN3 - A MESSAGE MUST BE OPEN IN INPUT '//
     . 'BUFR FILE, NONE ARE')
903   CALL BORT('BUFRLIB: UFBIN3 - LOCATION OF INTERNAL TABLE FOR '//
     . 'INPUT BUFR FILE DOES NOT AGREE WITH EXPECTED LOCATION IN '//
     . 'INTERNAL SUBSET ARRAY')
      END
      SUBROUTINE UFBINT(LUNIN,USR,I1,I2,IRET,STR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBINT
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE WRITES OR READS SPECIFIED VALUES TO OR FROM
C   THE CURRENT BUFR DATA SUBSET WITHIN INTERNAL ARRAYS, WITH THE
C   DIRECTION OF THE DATA TRANSFER DETERMINED BY THE CONTEXT OF
C   ABS(LUNIN) {I.E., IF ABS(LUNIN) POINTS TO A BUFR FILE THAT IS OPEN
C   FOR INPUT, THEN DATA VALUES ARE READ FROM THE INTERNAL DATA SUBSET;
C   OTHERWISE, DATA VALUES ARE WRITTEN TO THE INTERNAL DATA SUBSET.
C   THE DATA VALUES CORRESPOND TO MNEMONICS WHICH ARE PART OF A
C   DELAYED-REPLICATION SEQUENCE, OR FOR WHICH THERE IS NO REPLICATION
C   AT ALL. IF UFBINT IS READING VALUES, THEN EITHER BUFR ARCHIVE
C   LIBRARY SUBROUTINE READSB, READERS OR READNS MUST HAVE BEEN
C   PREVIOUSLY CALLED TO READ THE SUBSET FROM UNIT ABS(LUNIN) INTO
C   INTERNAL MEMORY.  IF IT IS WRITING VALUES, THEN EITHER BUFR ARCHIVE
C   LIBRARY SUBROUTINE OPENMG OR OPENMB MUST HAVE BEEN PREVIOUSLY
C   CALLED TO OPEN AND INITIALIZE A BUFR MESSAGE WITHIN MEMORY FOR THIS
C   ABS(LUNIN).
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1996-11-25  J. WOOLLEN -- MODIFIED TO ADD A RETURN CODE WHEN
C                           MNEMONICS ARE NOT FOUND WHEN READING
C 1996-12-11  J. WOOLLEN -- REMOVED A HARD ABORT FOR USERS WHO TRY TO
C                           WRITE NON-EXISTING MNEMONICS
C 1996-12-17  J. WOOLLEN -- MODIFIED TO ALWAYS INITIALIZE "USR" ARRAY
C                           TO MISSING (10E10) WHEN BUFR FILE IS BEING
C                           READ
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"; IMPROVED MACHINE
C                           PORTABILITY
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2002-05-14  J. WOOLLEN -- REMOVED OLD CRAY COMPILER DIRECTIVES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY); OUTPUTS MORE COMPLETE DIAGNOSTIC
C                           INFO WHEN ROUTINE TERMINATES ABNORMALLY OR
C                           UNUSUAL THINGS HAPPEN; CHANGED CALL FROM
C                           BORT TO BORT2 IN SOME CASES
C
C USAGE:    CALL UFBINT (LUNIN, USR, I1, I2, IRET, STR)
C   INPUT ARGUMENT LIST:
C     LUNIN    - INTEGER: ABSOLUTE VALUE IS FORTRAN LOGICAL UNIT NUMBER
C                FOR BUFR FILE
C                  - IF BUFR FILE OPEN FOR OUTPUT AND LUNIN IS LESS
C                    THAN ZERO, UFBINT TREATS THE BUFR FILE AS THOUGH
C                    IT WERE OPEN FOR INPUT
C     USR      - ONLY IF BUFR FILE OPEN FOR OUTPUT:
C                   REAL*8: (I1,I2) STARTING ADDRESS OF DATA VALUES
C                   WRITTEN TO DATA SUBSET
C     I1       - INTEGER: LENGTH OF FIRST DIMENSION OF USR OR THE
C                NUMBER OF BLANK-SEPARATED MNEMONICS IN STR (FORMER
C                MUST BE AT LEAST AS LARGE AS LATTER)
C     I2       - INTEGER:
C                  - IF BUFR FILE OPEN FOR INPUT:  LENGTH OF SECOND
C                    DIMENSION OF USR
C                  - IF BUFR FILE OPEN FOR OUTPUT: NUMBER OF "LEVELS"
C                    OF DATA VALUES TO BE WRITTEN TO DATA SUBSET
C     STR      - CHARACTER*(*): STRING OF BLANK-SEPARATED TABLE B
C                MNEMONICS IN ONE-TO-ONE CORRESPONDENCE WITH FIRST
C                DIMENSION OF USR
C                  - IF BUFR FILE OPEN FOR INPUT: THIS CAN ALSO BE A
C                    SINGLE TABLE D (SEQUENCE) MNEMONIC WITH EITHER 8-
C                    OR 16-BIT DELAYED REPLICATION (SEE REMARKS 1)
C
C   OUTPUT ARGUMENT LIST:
C     USR      - ONLY IF BUFR FILE OPEN FOR INPUT:
C                   REAL*8: (I1,I2) STARTING ADDRESS OF DATA VALUES
C                   READ FROM DATA SUBSET
C     IRET     - INTEGER:
C                  - IF BUFR FILE OPEN FOR INPUT: NUMBER OF "LEVELS" OF
C                    DATA VALUES READ FROM DATA SUBSET (MUST BE NO
C                    LARGER THAN I2)
C                  - IF BUFR FILE OPEN FOR OUTPUT: NUMBER OF "LEVELS"
C                    OF DATA VALUES WRITTEN TO DATA SUBSET (SHOULD BE
C                    SAME AS I2)
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    1) UFBINT CAN ALSO BE CALLED TO PROVIDE INFORMATION ABOUT A SINGLE
C       TABLE D (SEQUENCE) MNEMONIC WITH EITHER 8- OR 16-BIT DELAYED
C       REPLICATION IN A SUBSET WHEN THE BUFR FILE IS OPEN FOR INPUT.
C       THE MNEMONIC IN STR MUST APPEAR AS IT DOES IN THE BUFR TABLE,
C       I.E., BRACKETED BY "{" AND "}" OR "[" AND "]" FOR 8-BIT DELAYED
C       REPLICATION, OR BRACKETED BY "(" AND ")" FOR 16-BIT DELAYED
C       REPLICATION.  {NOTE: THIS WILL NOT WORK FOR SEQUENCES WITH
C       1-BIT DELAYED REPLICATION (BRACKETED BY "<" AND ">"), STANDARD
C       REPLICATION (BRACKETED BY "'s), OR NO REPLICATION (NO
C       BRACKETING SYMBOLS).}
C       
C       FOR EXAMPLE:
C
C       CALL UFBINT(LUNIN,PLEVL,1, 50,IRET,'{PLEVL}')
C
C       WILL RETURN WITH IRET EQUAL TO THE NUMBER OF OCCURRENCES OF THE
C       8-BIT DELAYED REPLICATION SEQUENCE PLEVL IN THE SUBSET AND WITH
C       (PLEVL(I),I=1,IRET) EQUAL TO THE NUMBER OF REPLICATIONS IN EACH
C       OCCURRENCE OF PLEVL IN THE SUBSET.  IF THERE ARE NO OCCURRENCES
C       OF PLEVL IN THE SUBSET, IRET IS RETURNED AS ZERO.
C
C    2) WHEN BUFR FILE IS OPEN FOR OUTPUT, CALLING UFBINT WITH ONE OR
C       MORE TABLE B MNEMONICS IN STR WHICH ARE PART OF A DELAYED
C       REPLICATION SEQUENCE (AS DEFINED IN THE BUFR MNEMONIC TABLE)
C       WILL NOT ONLY WRITE THE VALUES FOR THE SPECIFIED MNEMONIC(S)
C       INTO THE SUBSET, IT WILL ALSO ALLOCATE SPACE FOR ALL OTHER
C       MNEMONICS DEFINED FOR THE SEQUENCE IN THE BUFR TABLE, WITH THE
C       NUMBER OF REPLICATIONS BASED ON THE VALUE OF I2.
C
C       THIS ALLOWS AN APPLICATION PROGRAM TO STORE VALUES WHICH HAVE
C       STANDARD REPLICATION NESTED INSIDE OF A DELAYED REPLICATION
C       SEQUENCE.  FOR EXAMPLE, IF AN APPLICATION PROGRAM WANTED TO
C       WRITE 50 LEVELS OF WIND SPEED, WIND DIRECTION, OBSERVED
C       PRESSURE, FIRST GUESS PRESSURE AND ANALYZED PRESSURE, THE BUFR
C       TABLE COULD HAVE THE FOLLOWING STRUCTURE (NOTE 16 CHARACTERS
C       HAVE BEEN REMOVED FROM THE LAST COLUMN TO ALLOW THE TABLE TO
C       FIT IN THIS DOCBLOCK):
C
C       | SEQNCE   | {PLEVL}                                           |
C       | PLEVL    | WSPD WDIR TSIG PRLC TSIG PRLC TSIG PRLC           |
C
C              -- OR --
C
C       | SEQNCE   | {PLEVL}                                           |
C       | PLEVL    | WSPD WDIR "PSEQ"3                                 |
C       | PSEQ     | TSIG PRLC                                         |
C
C       THE FOLLOWING LOGIC WOULD THEN ENCODE VALUES PROPERLY:
C.....................................................................
C       REAL*8 DROBS(2,50)
C       REAL*8 SROBS(2,150)
C              ....
C              ....
C       DO I=1,50
C         DROBS(1,I) = Value of wind speed on level "I"
C         DROBS(2,I) = Value of wind direction on level "I"
C       ENDDO
C       DO I=1,50
C         SROBS(1,I*1) = Value of observed pressure on level "I"
C         SROBS(2,I*1) = 25. ! Value in Code Table 0-08-021 (TSIG) for
C                            !  time sigificance (Nominal reporting
C                            !  time) for observed pressure on level
C                            !  "I"
C         SROBS(1,I*2) = Value of first guess pressure on level "I"
C         SROBS(2,I*2) = 27. ! Value in Code Table 0-08-021 (TSIG) for
C                            !  time sigificance (First guess) for
C                            !  first guess pressure on level "I"
C         SROBS(1,I*3) = Value of analyzed pressure on level "I"
C         SROBS(2,I*3) = 16. ! Value in Code Table 0-08-021 (TSIG) for
C                            !  time sigificance (Analysis) for
C                            !  analyzed pressure on level "I"
C       ENDDO
C
C       CALL UFBINT(LUNIN,DROBS,2, 50,IRET,'WSPD WDIR')
C       CALL UFBREP(LUNIN,SROBS,2,150,IRET,'TSIG PRLC')
C.....................................................................
C
C       A SIMILAR EXAMPLE COULD BE PROVIDED FOR READING VALUES WHICH
C       HAVE STANDARD REPLICATION NESTED WITHIN DELAYED REPLICATION,
C       FROM BUFR FILES OPEN FOR INPUT.  (NOT SHOWN HERE.)
C
C
C
C    THIS ROUTINE CALLS:        BORT     BORT2    STATUS   STRING
C                               TRYBUMP  UFBRW
C    THIS ROUTINE IS CALLED BY: UFBINX   UFBRMS
C                               Also called by application programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /USRSTR/ NNOD,NCON,NODS(20),NODC(10),IVLS(10),KONS(10)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /QUIET / IPRT

      CHARACTER*(*) STR
      CHARACTER*128 BORT_STR1,BORT_STR2
      REAL*8        USR(I1,I2),VAL,BMISS

      DATA BMISS /10E10/,IFIRST1/0/,IFIRST2/0/

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      IRET = 0

C  CHECK THE FILE STATUS AND I-NODE
C  --------------------------------

      LUNIT = ABS(LUNIN)
      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IM.EQ.0) GOTO 901
      IF(INODE(LUN).NE.INV(1,LUN)) GOTO 902

      IO = MIN(MAX(0,IL),1)
      IF(LUNIT.NE.LUNIN) IO = 0

      IF(I1.LE.0) THEN
         IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
         PRINT*,'BUFRLIB: UFBINT - THIRD ARGUMENT (INPUT) IS .LE. 0',
     .    ' -  RETURN WITH FIFTH ARGUMENT (IRET) = 0'
         PRINT*,'STR = ',STR
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
         GOTO 100
      ELSEIF(I2.LE.0) THEN
         IF(IPRT.EQ.-1)  IFIRST1 = 1
         IF(IO.EQ.0 .OR. IFIRST1.EQ.0 .OR. IPRT.GE.1)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
            PRINT*,'BUFRLIB: UFBINT - FOURTH ARGUMENT (INPUT) IS .LE.',
     .       ' 0 -  RETURN WITH FIFTH ARGUMENT (IRET) = 0'
            PRINT*,'STR = ',STR
            IF(IPRT.EQ.0 .AND. IO.EQ.1)  PRINT 101
101   FORMAT('Note: Only the first occurrence of this WARNING message ',
     . 'is printed, there may be more.  To output'/6X,'ALL WARNING ',
     . 'messages, modify your application program to add ',
     . '"CALL OPENBF(0,''QUIET'',1)" prior'/6X,'to the first call to a',
     . ' BUFRLIB routine.')
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
            IFIRST1 = 1
         ENDIF
         GOTO 100
      ENDIF

C  PARSE OR RECALL THE INPUT STRING
C  --------------------------------

      CALL STRING(STR,LUN,I1,IO)

C  INITIALIZE USR ARRAY PRECEEDING AN INPUT OPERATION
C  --------------------------------------------------

      IF(IO.EQ.0) THEN
         DO J=1,I2
         DO I=1,I1
         USR(I,J) = BMISS
         ENDDO
         ENDDO
      ENDIF

C  CALL THE MNEMONIC READER/WRITER
C  -------------------------------

      CALL UFBRW(LUN,USR,I1,I2,IO,IRET)

C  IF INCOMPLETE WRITE TRY TO INITIALIZE REPLICATION SEQUENCE OR RETURN
C  ---------------------------------------------------------------------

      IF(IO.EQ.1 .AND. IRET.NE.I2 .AND. IRET.GE.0) THEN
         CALL TRYBUMP(LUNIT,LUN,USR,I1,I2,IO,IRET)
         IF(IRET.NE.I2) GOTO 903
      ELSEIF(IRET.EQ.-1) THEN
         IRET = 0
      ENDIF

      IF(IRET.EQ.0)  THEN
         IF(IO.EQ.0) THEN
            IF(IPRT.GE.1)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
               PRINT*,'BUFRLIB: UFBINT - NO SPECIFIED VALUES READ IN',
     .          ' -  RETURN WITH FIFTH ARGUMENT (IRET) = 0'
               PRINT*,'STR = ',STR
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
            ENDIF
         ELSE
            IF(IPRT.EQ.-1)  IFIRST2 = 1
            IF(IFIRST2.EQ.0 .OR. IPRT.GE.1)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
               PRINT*,'BUFRLIB: UFBINT - NO SPECIFIED VALUES WRITTEN ',
     .          'OUT -  RETURN WITH FIFTH ARGUMENT (IRET) = 0'
               PRINT*,'STR = ',STR,' MAY NOT BE IN THE BUFR TABLE(?)'
               IF(IPRT.EQ.0)  PRINT 101
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
               IFIRST2 = 1
            ENDIF
         ENDIF
      ENDIF

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: UFBINT - BUFR FILE IS CLOSED, IT MUST BE'//
     . ' OPEN')
901   CALL BORT('BUFRLIB: UFBINT - A MESSAGE MUST BE OPEN IN BUFR '//
     . 'FILE, NONE ARE')
902   CALL BORT('BUFRLIB: UFBINT - LOCATION OF INTERNAL TABLE FOR '//
     . 'BUFR FILE DOES NOT AGREE WITH EXPECTED LOCATION IN INTERNAL '//
     . 'SUBSET ARRAY')
903   WRITE(BORT_STR1,'("BUFRLIB: UFBINT - MNEMONIC STRING READ IN IS'//
     . ': ",A)') STR
      WRITE(BORT_STR2,'(18X,"THE NUMBER OF ''LEVELS'' ACTUALLY '//
     . 'WRITTEN (",I3,") DOES NOT EQUAL THE NUMBER REQUESTED (",I3,")'//
     . ' - INCOMPLETE WRITE")')  IRET,I2
      CALL BORT2(BORT_STR1,BORT_STR2)
      END
      SUBROUTINE UFBINX(LUNIT,IMSG,ISUB,USR,I1,I2,IRET,STR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBINX
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2003-11-04
C
C ABSTRACT: THIS SUBROUTINE EITHER OPENS A BUFR FILE CONNECTED TO
C   LOGICAL UNIT LUNIT FOR INPUT OPERATIONS (IF IT IS NOT ALREADY
C   OPENED AS SUCH), OR SAVES ITS POSITION AND REWINDS IT TO THE FIRST
C   DATA MESSAGE (IF BUFR FILE ALREADY OPENED), THEN (VIA A CALL TO
C   BUFR ARCHIVE LIBRARY SUBROUTINE UFBINT) READS SPECIFIED VALUES FROM
C   INTERNAL SUBSET ARRAYS ASSOCIATED WITH A PARTICULAR SUBSET FROM A
C   PARTICULAR BUFR MESSAGE IN A MESSAGE BUFFER.  THE PARTICULAR SUBSET
C   AND BUFR MESSAGE ARE BASED BASED ON THE SUBSET NUMBER IN THE
C   MESSAGE AND THE MESSAGE NUMBER IN THE BUFR FILE.  FINALLY, THIS
C   SUBROUTINE EITHER CLOSES THE BUFR FILE IN LUNIT (IF IS WAS OPENED
C   HERE) OR RESTORES IT TO ITS PREVIOUS READ/WRITE STATUS AND POSITION
C   (IF IT WAS NOT OPENED HERE).  SEE UFBINT FOR MORE INFORMATION ON
C   THE READING OF VALUES OUT OF A BUFR MESSAGE SUBSET.  NOTE: THE
C   MESSAGE NUMBER HERE DOES NOT INCLUDE THE DICTIONARY MESSAGES AT THE
C   BEGINNING OF THE FILE.
C
C PROGRAM HISTORY LOG:
C 2003-11-04  J. WOOLLEN -- ORIGINAL AUTHOR (WAS IN VERIFICATION
C                           VERSION BUT MAY HAVE BEEN IN THE PRODUCTION
C                           VERSION AT ONE TIME AND THEN REMOVED)
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL UFBINX (LUNIT, IMSG, ISUB, USR, I1, I2, IRET, STR)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     IMSG     - INTEGER: POINTER TO BUFR MESSAGE NUMBER TO READ IN
C                BUFR FILE
C     ISUB     - INTEGER: POINTER TO SUBSET NUMBER TO READ IN BUFR
C                MESSAGE
C     I1       - INTEGER: LENGTH OF FIRST DIMENSION OF USR OR THE
C                NUMBER OF BLANK-SEPARATED MNEMONICS IN STR (FORMER
C                MUST BE AT LEAST AS LARGE AS LATTER)
C     I2       - INTEGER: LENGTH OF SECOND DIMENSION OF USR
C     STR      - CHARACTER*(*): STRING OF BLANK-SEPARATED TABLE B
C                MNEMONICS IN ONE-TO-ONE CORRESPONDENCE WITH FIRST
C                DIMENSION OF USR {THIS CAN ALSO BE A SINGLE TABLE D
C                (SEQUENCE) MNEMONIC WITH EITHER 8- OR 16-BIT DELAYED
C                REPLICATION (SEE REMARKS 1 IN UFBINT DOCBLOCK)}
C
C   OUTPUT ARGUMENT LIST:
C     USR      - REAL*8: (I1,I2) STARTING ADDRESS OF DATA VALUES READ
C                FROM DATA SUBSET
C     IRET     - INTEGER: NUMBER OF "LEVELS" OF DATA VALUES READ FROM
C                DATA SUBSET (MUST BE NO LARGER THAN I2)
C
C   INPUT FILES:
C     UNIT "LUNIT" - BUFR FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     CLOSBF   OPENBF   READMG
C                               READSB   REWNBF   STATUS   UFBINT
C                               UPB
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)

      CHARACTER*(*) STR
      CHARACTER*128 BORT_STR
      CHARACTER*8   SUBSET
      LOGICAL       OPENIT
      REAL*8        USR(I1,I2)

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      OPENIT = IL.EQ.0

      IF(OPENIT) THEN

C  OPEN BUFR FILE CONNECTED TO UNIT LUNIT IF IT IS NOT ALREADY OPEN
C  ----------------------------------------------------------------

         CALL OPENBF(LUNIT,'IN',LUNIT)
      ELSE

C  IF BUFR FILE ALREADY OPENED, SAVE POSITION & REWIND TO FIRST DATA MSG
C  ---------------------------------------------------------------------

         CALL REWNBF(LUNIT,0)
      ENDIF

C  SKIP TO MESSAGE # IMSG
C  ----------------------

      DO I=1,IMSG-1
      READ(LUNIT,ERR=900,END=901) MSTR
      ENDDO

      CALL READMG(LUNIT,SUBSET,JDATE,JRET)
      IF(JRET.NE.0) GOTO 901

C  POSITION AT SUBSET # ISUB
C  -------------------------

      DO I=1,ISUB-1
      IF(NSUB(LUN).GT.MSUB(LUN)) GOTO 902
      IBIT = MBYT(LUN)*8
      CALL UPB(NBYT,16,MBAY(1,LUN),IBIT)
      MBYT(LUN) = MBYT(LUN) + NBYT
      NSUB(LUN) = NSUB(LUN) + 1
      ENDDO

      CALL READSB(LUNIT,JRET)
      IF(JRET.NE.0) GOTO 902

      CALL UFBINT(LUNIT,USR,I1,I2,IRET,STR)

      IF(OPENIT) THEN

C  CLOSE BUFR FILE IF IT WAS OPENED HERE
C  -------------------------------------

         CALL CLOSBF(LUNIT)
      ELSE


C  RESTORE BUFR FILE TO PREV. STATUS & POSITION IF NOT ORIG. OPENED HERE
C  ---------------------------------------------------------------------

         CALL REWNBF(LUNIT,1)
      ENDIF

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: UFBINX - ERROR READING MESSAGE '//
     . '(RECORD) NUMBER",I5," IN INPUT BUFR FILE CONNECTED TO UNIT",'//
     . 'I4)')  I,LUNIT
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: UFBINX - HIT END OF FILE BEFORE '//
     . 'READING REQUESTED MESSAGE NO.",I5," IN BUFR FILE CONNECTED TO'//
     . ' UNIT",I4)')  IMSG,LUNIT
      CALL BORT(BORT_STR)
902   WRITE(BORT_STR,'("BUFRLIB: UFBINX - ALL SUBSETS READ BEFORE '//
     . 'READING REQ. SUBSET NO.",I3," IN REQ. MSG NO.",I5," IN BUFR '//
     . 'FILE CONNECTED TO UNIT",I4)') ISUB,IMSG,LUNIT
      CALL BORT(BORT_STR)
      END
      SUBROUTINE UFBMEM(LUNIT,INEW,IRET,IUNIT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBMEM
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE OPENS A BUFR FILE FOR INPUT, READS EACH
C   MESSAGE AND TRANSFERS THEM ONE-BY-ONE TO INTERNAL MEMORY (ARRAY
C   MSGS IN COMMON BLOCK /MSGMEM/).  IF MESSAGES ARE APPENDED TO
C   EXISTING MESSAGES IN INTERNAL MEMORY, THE BUFR FILE READ HERE IS
C   CLOSED PRIOR TO RETURNING TO THE CALLING PROGRAM.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE MAXIMUM NUMBER OF BYTES REQUIRED TO
C                           STORE ALL MESSAGES INTERNALLY WAS INCREASED
C                           FROM 4 MBYTES TO 8 MBYTES
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2001-08-15  D. KEYSER  -- PARAMETER MAXMEM (THE MAXIMUM NUMBER OF
C                           BYTES REQUIRED TO STORE ALL MESSAGES
C                           INTERNALLY) WAS INCREASED FROM 8 MBYTES TO
C                           16 MBYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- PARAMETER MAXMSG (THE MAXIMUM NUMBER OF
C                           BUFR MESSAGES WHICH CAN BE STORED
C                           INTERNALLY) INCREASED FROM 50000 TO 200000;
C                           UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL UFBMEM (LUNIT, INEW, IRET, IUNIT)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     INEW     - INTEGER: SWITCH:
C                       0 = initialize internal arrays prior to
C                           transferring messages here
C                    else = append the messages transferred here to
C                           internal memory arrays
C
C   OUTPUT ARGUMENT LIST:
C     IRET     - INTEGER: NUMBER OF MESSAGES TRANSFERRED
C     IUNIT    - INTEGER: RETURN CODE:
C                       0 = no messages were read from LUNIT, file is
C                           empty
C                   LUNIT = INEW input as 0
C                    else = FORTRAN logical unit for BUFR file
C                           associated with initial message transferred
C                           to internal memory
C
C   INPUT FILES:
C     UNIT "LUNIT" - BUFR FILE
C
C REMARKS:
C    NOTE THAT IREADMM, RDMEMM, READMM, UFBMMS, UFBMNS, UFBRMS, UFBTAB
C    OR UFBTAM CAN BE CALLED AFTER THIS TO READ SPECIFIC BUFR MESSAGES
C    FROM INTERNAL MEMORY.
C
C    THIS ROUTINE CALLS:        BORT     CLOSBF   LMSG     OPENBF
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXMSG=200000,MAXMEM=16000000)
      PARAMETER (MXMSGL=20000)

      COMMON /MSGMEM/ MUNIT,MLAST,MSGP(0:MAXMSG),MSGS(MAXMEM)
      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)

      CHARACTER*128 BORT_STR
      CHARACTER*8   SEC0
      DIMENSION     MBAY(MXMSGL/4)
      EQUIVALENCE   (SEC0,MBAY(1))

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  TRY TO OPEN BUFR FILE AND SET TO INITIALIZE OR CONCATENATE
C  ----------------------------------------------------------

      CALL OPENBF(LUNIT,'IN',LUNIT)

      IF(INEW.EQ.0) THEN
         MSGP(0) = 0
         MUNIT = 0
         MLAST = 0
      ENDIF

      IMSG = 8/NBYTW+1
      NMSG = MSGP(0)
      IRET = 0

C  TRANSFER MESSAGES FROM FILE TO MEMORY - SET MESSAGE POINTERS
C  ------------------------------------------------------------

1     READ(LUNIT,ERR=900,END=100) SEC0,(MBAY(I),I=IMSG,LMSG(SEC0))
      IRET = IRET+1
      NMSG = NMSG+1
      LMEM = LMSG(SEC0)+IMSG-1
      IF(NMSG      .GT.MAXMSG) GOTO 901
      IF(LMEM+MLAST.GT.MAXMEM) GOTO 902

      DO I=1,LMEM
      MSGS(MLAST+I) = MBAY(I)
      ENDDO

      MSGP(0)    = NMSG
      MSGP(NMSG) = MLAST+1
      MLAST = MLAST+LMEM
      GOTO 1

C  EXITS
C  -----

100   IF(IRET.EQ.0) THEN
         CALL CLOSBF(LUNIT)
      ELSE
         IF(MUNIT.NE.0) CALL CLOSBF(LUNIT)
         IF(MUNIT.EQ.0) MUNIT = LUNIT
      ENDIF
      IUNIT = MUNIT

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: UFBMEM - ERROR READING MESSAGE '//
     . 'NUMBER",I5," INTO MEMORY FROM UNIT",I3)') NMSG+1,LUNIT
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: UFBMEM - THE NUMBER OF MESSAGES READ'//
     . ' IN EXCEEDS MAXIMUM THAT CAN BE STORED INTERNALLY (",I6,")")')
     . MAXMSG
      CALL BORT(BORT_STR)
902   WRITE(BORT_STR,'("BUFRLIB: UFBMEM - THE NUMBER OF BYTES '//
     . 'REQUIRED TO STORE ALL MESSAGES INTERNALLY EXCEEDS THE MAXIMUM'//
     . ' (",I8,")")') MAXMEM
      CALL BORT(BORT_STR)
      END
      SUBROUTINE UFBMMS(IMSG,ISUB,SUBSET,JDATE)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBMMS
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE READS A PARTICULAR SUBSET INTO INTERNAL
C   SUBSET ARRAYS FROM A PARTICULAR BUFR MESSAGE IN INTERNAL MEMORY
C   BASED ON THE SUBSET NUMBER IN THE MESSAGE AND THE MESSAGE NUMBER IN
C   INTERNAL MEMORY.  THIS SUBROUTINE IS ACTUALLY A COMBINATION OF
C   BUFR ARCHIVE LIBRARY SUBROUTINES RDMEMM AND RDMEMS.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE MAXIMUM NUMBER OF BYTES REQUIRED TO
C                           STORE ALL MESSAGES INTERNALLY WAS INCREASED
C                           FROM 4 MBYTES TO 8 MBYTES
C 2001-08-15  D. KEYSER  -- PARAMETER MAXMEM (THE MAXIMUM NUMBER OF
C                           BYTES REQUIRED TO STORE ALL MESSAGES
C                           INTERNALLY) WAS INCREASED FROM 8 MBYTES TO
C                           16 MBYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- PARAMETER MAXMSG (THE MAXIMUM NUMBER OF
C                           BUFR MESSAGES WHICH CAN BE STORED
C                           INTERNALLY) INCREASED FROM 50000 TO 200000;
C                           UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL UFBMMS (IMSG, ISUB, SUBSET, JDATE)
C   INPUT ARGUMENT LIST:
C     IMSG     - INTEGER: POINTER TO BUFR MESSAGE NUMBER (RECORD) IN
C                STORAGE
C     ISUB     - INTEGER: POINTER TO SUBSET NUMBER TO READ IN BUFR
C                MESSAGE
C
C   OUTPUT ARGUMENT LIST:
C     SUBSET   - CHARACTER*8: TABLE A MNEMONIC FOR BUFR MESSAGE
C                CONTAINING SUBSET
C     JDATE    - INTEGER: DATE-TIME FROM SECTION 1 OF BUFR MESSAGE
C                CONTAINING SUBSET, IN FORMAT OF EITHER YYMMDDHH OR
C                YYYYMMDDHH, DEPENDING ON DATELEN() VALUE
C
C REMARKS:
C    NOTE THAT UFBMEM IS CALLED PRIOR TO THIS TO STORE THE BUFR
C    MESSAGES INTO INTERNAL MEMORY.
C
C    THIS ROUTINE CALLS:        BORT     RDMEMM   RDMEMS   STATUS
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXMSG=200000,MAXMEM=16000000)
      PARAMETER (NFILES=32)

      COMMON /MSGMEM/ MUNIT,MLAST,MSGP(0:MAXMSG),MSGS(MAXMEM)
      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)

      CHARACTER*128 BORT_STR
      CHARACTER*8   SUBSET

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  READ SUBSET #ISUB FROM MEMORY MESSAGE #IMSG
C  -------------------------------------------

      CALL RDMEMM(IMSG,SUBSET,JDATE,IRET)
      IF(IRET.NE.0) GOTO 900
      CALL RDMEMS(ISUB,IRET)
      IF(IRET.NE.0) GOTO 901

C  EXITS
C  -----

      RETURN
900   IF(IMSG.GT.0)  THEN
      WRITE(BORT_STR,'("BUFRLIB: UFBMMS - REQUESTED MEMORY MESSAGE '//
     . 'NUMBER TO READ IN (",I5,") EXCEEDS THE NUMBER OF MESSAGES IN '//
     . 'MEMORY (",I5,")")') IMSG,MSGP(0)
      ELSE
      WRITE(BORT_STR,'("BUFRLIB: UFBMMS - REQUESTED MEMORY MESSAGE '//
     . 'NUMBER TO READ IN IS ZERO - THIS IS NOT VALID")')
      ENDIF
      CALL BORT(BORT_STR)
901   CALL STATUS(MUNIT,LUN,IL,IM)
      WRITE(BORT_STR,'("BUFRLIB: UFBMMS - REQ. SUBSET NUMBER TO READ '//
     . 'IN (",I3,") EXCEEDS THE NUMBER OF SUBSETS (",I3,") IN THE '//
     . 'REG. MEMORY MESSAGE (",I5,")")') ISUB,MSUB(LUN),IMSG
      CALL BORT(BORT_STR)
      END
      SUBROUTINE UFBMNS(IREP,SUBSET,IDATE)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBMNS
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE READS A PARTICULAR SUBSET INTO INTERNAL
C   SUBSET ARRAYS FROM A COLLECTION OF BUFR MESSAGES IN INTERNAL MEMORY
C   BASED ON THE SUBSET NUMBER RELATIVE TO THE TOTAL NUMBER OF SUBSETS
C   IN THE COLLECTION.  THE SUBROUTINE DOES NOT RETURN ANY INFORMATION
C   ABOUT WHICH MESSAGE NUMBER CONTAINED THE DESIRED SUBSET.  IF THE
C   REQUESTED SUBSET IS LARGER THAN THE TOTAL NUMBER OF SUBSETS IN
C   MEMORY, THEN AN APPROPRIATE CALL IS MADE TO BUFR ARCHIVE LIBRARY
C   SUBROUTINE BORT.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE MAXIMUM NUMBER OF BYTES REQUIRED TO
C                           STORE ALL MESSAGES INTERNALLY WAS INCREASED 
C                           FROM 4 MBYTES TO 8 MBYTES
C 2001-08-15  D. KEYSER  -- PARAMETER MAXMEM (THE MAXIMUM NUMBER OF
C                           BYTES REQUIRED TO STORE ALL MESSAGES
C                           INTERNALLY) WAS INCREASED FROM 8 MBYTES TO
C                           16 MBYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- PARAMETER MAXMSG (THE MAXIMUM NUMBER OF
C                           BUFR MESSAGES WHICH CAN BE STORED
C                           INTERNALLY) INCREASED FROM 50000 TO 200000;
C                           UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL UFBMNS (IREP, SUBSET, IDATE)
C   INPUT ARGUMENT LIST:
C     IREP     - INTEGER: POINTER TO SUBSET NUMBER TO READ IN
C                COLLECTION OF MESSAGES
C
C   OUTPUT ARGUMENT LIST:
C     SUBSET   - CHARACTER*8: TABLE A MNEMONIC FOR BUFR MESSAGE
C                CONTAINING SUBSET
C     IDATE    - INTEGER: DATE-TIME FROM SECTION 1 OF BUFR MESSAGE
C                CONTAINING SUBSET, IN FORMAT OF EITHER YYMMDDHH OR
C                YYYYMMDDHH, DEPENDING ON DATELEN() VALUE
C
C REMARKS:
C    NOTE THAT UFBMEM IS CALLED PRIOR TO THIS TO STORE THE BUFR
C    MESSAGES INTO INTERNAL MEMORY.
C
C    THIS ROUTINE CALLS:        BORT     NMSUB    RDMEMM   RDMEMS
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXMSG=200000,MAXMEM=16000000)

      COMMON /MSGMEM/ MUNIT,MLAST,MSGP(0:MAXMSG),MSGS(MAXMEM)

      CHARACTER*128 BORT_STR
      CHARACTER*8   SUBSET

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IRET = 0
      JREP = 0
      IMSG = 1

C  READ SUBSET #ISUB FROM MEMORY MESSAGE #IMSG
C  -------------------------------------------

      DO WHILE(IRET.EQ.0)
      CALL RDMEMM(IMSG,SUBSET,IDATE,IRET)
      IF(IRET.NE.0) GOTO 900
      IF(JREP+NMSUB(MUNIT).GE.IREP) THEN
         CALL RDMEMS(IREP-JREP,IRET)
c  .... DK: I don't think the below error could ever happen(??)
         IF(IRET.NE.0) GOTO 900
         GOTO 100
      ELSE
         JREP = JREP+NMSUB(MUNIT)
         IMSG = IMSG+1
      ENDIF
      ENDDO
c  .... DK: I don't think the below error could ever happen(??)
      GOTO 900

C  EXITS
C  -----

100   RETURN
900   WRITE(BORT_STR,'("BUFRLIB: UFBMNS - REQ. SUBSET NO. TO READ IN '//
     . '(",I5,") EXCEEDS TOTAL NO. OF SUBSETS IN THE COLLECTION OF '//
     . 'MEMORY MESSAGES (",I5,")")') IREP,JREP
      CALL BORT(BORT_STR)
      END
      SUBROUTINE UFBOVR(LUNIT,USR,I1,I2,IRET,STR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBOVR
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE WRITES OVER SPECIFIED VALUES WHICH EXIST
C   IN CURRENT INTERNAL BUFR SUBSET ARRAYS IN A FILE OPEN FOR OUTPUT.
C   THE DATA VALUES CORRESPOND TO MNEMONICS WHICH ARE PART OF A
C   DELAYED-REPLICATION SEQUENCE, OR FOR WHICH THERE IS NO REPLICATION
C   AT ALL.  EITHER BUFR ARCHIVE LIBRARY SUBROUTINE OPENMG OR OPENMB
C   MUST HAVE BEEN PREVIOUSLY CALLED TO OPEN AND INITIALIZE A BUFR
C   MESSAGE WITHIN MEMORY FOR THIS LUNIT.  IN ADDITION, BUFR ARCHIVE
C   LIBRARY SUBROUTINE WRITSB OR INVMRG MUST HAVE BEEN CALLED TO STORE
C   DATA IN THE INTERNAL OUTPUSE SUBSET ARRAYS.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2002-05-14  J. WOOLLEN -- REMOVED OLD CRAY COMPILER DIRECTIVES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY); OUTPUTS MORE COMPLETE DIAGNOSTIC
C                           INFO WHEN ROUTINE TERMINATES ABNORMALLY OR
C                           UNUSUAL THINGS HAPPEN; CHANGED CALL FROM
C                           BORT TO BORT2 IN SOME CASES
C
C USAGE:    CALL UFBOVR (LUNIT, USR, I1, I2, IRET, STR)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     USR      - REAL*8: (I1,I2) STARTING ADDRESS OF DATA VALUES
C                WRITTEN TO DATA SUBSET
C     I1       - INTEGER: LENGTH OF FIRST DIMENSION OF USR OR THE
C                NUMBER OF BLANK-SEPARATED MNEMONICS IN STR (FORMER
C                MUST BE AT LEAST AS LARGE AS LATTER)
C     I2       - INTEGER: NUMBER OF "LEVELS" OF DATA VALUES TO BE
C                WRITTEN TO DATA SUBSET
C     STR      - CHARACTER*(*): STRING OF BLANK-SEPARATED TABLE B
C                MNEMONICS IN ONE-TO-ONE CORRESPONDENCE WITH FIRST
C                DIMENSION OF USR
C
C   OUTPUT ARGUMENT LIST:
C     IRET     - INTEGER: NUMBER OF "LEVELS" OF DATA VALUES WRITTEN TO
C                DATA SUBSET (SHOULD BE SAME AS I2)
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     BORT2    STATUS   STRING
C                               TRYBUMP
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)

      CHARACTER*128 BORT_STR1,BORT_STR2
      CHARACTER*(*) STR
      REAL*8        USR(I1,I2),VAL

      DATA IFIRST1/0/,IFIRST2/0/

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      IRET = 0

C  CHECK THE FILE STATUS AND I-NODE
C  --------------------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.LT.0) GOTO 901
      IF(IM.EQ.0) GOTO 902
      IF(INODE(LUN).NE.INV(1,LUN)) GOTO 903

C  .... DK: Why check, isn't IO always 1 here?
      IO = MIN(MAX(0,IL),1)

      IF(I1.LE.0) THEN
         IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
         PRINT*,'BUFRLIB: UFBOVR - THIRD ARGUMENT (INPUT) IS .LE. 0',
     .    ' -  RETURN WITH FIFTH ARGUMENT (IRET) = 0'
         PRINT*,'STR = ',STR
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
         GOTO 100
      ELSEIF(I2.LE.0) THEN
         IF(IPRT.EQ.-1)  IFIRST1 = 1
         IF(IO.EQ.0 .OR. IFIRST1.EQ.0 .OR. IPRT.GE.1)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
            PRINT*,'BUFRLIB: UFBOVR - FOURTH ARGUMENT (INPUT) IS .LE.',
     .       ' 0 -  RETURN WITH FIFTH ARGUMENT (IRET) = 0'
            PRINT*,'STR = ',STR
            IF(IPRT.EQ.0 .AND. IO.EQ.1)  PRINT 101
101   FORMAT('Note: Only the first occurrence of this WARNING message ',
     . 'is printed, there may be more.  To output'/6X,'ALL WARNING ',
     . 'messages, modify your application program to add ',
     . '"CALL OPENBF(0,''QUIET'',1)" prior'/6X,'to the first call to a',
     . ' BUFRLIB routine.')
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
            IFIRST1 = 1
         ENDIF
         GOTO 100
      ENDIF

C  PARSE OR RECALL THE INPUT STRING - READ/WRITE VALUES
C  ----------------------------------------------------

      CALL STRING(STR,LUN,I1,IO)
      CALL TRYBUMP(LUNIT,LUN,USR,I1,I2,IO,IRET)

      IF(IO.EQ.1 .AND. IRET.NE.I2) GOTO 904

      IF(IRET.EQ.0)  THEN
         IF(IPRT.EQ.-1)  IFIRST2 = 1
         IF(IFIRST2.EQ.0 .OR. IPRT.GE.1)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
            PRINT*,'BUFRLIB: UFBOVR - NO SPECIFIED VALUES WRITTEN OUT',
     .       ' -  RETURN WITH FIFTH ARGUMENT (IRET) = 0'
            PRINT*,'STR = ',STR,' MAY NOT BE IN THE BUFR TABLE(?)'
            IF(IPRT.EQ.0)  PRINT 101
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
            IFIRST2 = 1
         ENDIF
      ENDIF

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: UFBOVR - OUTPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR OUTPUT')
901   CALL BORT('BUFRLIB: UFBOVR - OUTPUT BUFR FILE IS OPEN FOR '//
     . 'INPUT, IT MUST BE OPEN FOR OUTPUT')
902   CALL BORT('BUFRLIB: UFBOVR - A MESSAGE MUST BE OPEN IN OUTPUT '//
     . 'BUFR FILE, NONE ARE')
903   CALL BORT('BUFRLIB: UFBOVR - LOCATION OF INTERNAL TABLE FOR '//
     . 'OUTPUT BUFR FILE DOES NOT AGREE WITH EXPECTED LOCATION IN '//
     . 'INTERNAL SUBSET ARRAY')
904   WRITE(BORT_STR1,'("BUFRLIB: UFBOVR - MNEMONIC STRING READ IN IS'//
     . ': ",A)') STR
      WRITE(BORT_STR2,'(18X,"THE NUMBER OF ''LEVELS'' ACTUALLY '//
     . 'WRITTEN (",I3,") DOES NOT EQUAL THE NUMBER REQUESTED (",I3,")'//
     . ' - INCOMPLETE WRITE")')  IRET,I2
      CALL BORT2(BORT_STR1,BORT_STR2)
      END
      SUBROUTINE UFBQCD(LUNIT,NEMO,QCD)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBQCD
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE READS IN A MNEMONIC KNOWN TO BE IN THE BUFR
C   TABLE ASSOCIATED WITH THE BUFR FILE IN LOGICAL UNIT LUNIT, AND
C   RETURNS THE DESCRIPTOR ENTRY (Y) ASSOCIATED WITH IT WHEN THE FXY
C   DESCRIPTOR IS A SEQUENCE DESCRIPTOR (F=3) WITH TABLE D CATEGORY 63
C   (X=63).  THIS ROUTINE WILL NOT WORK FOR ANY OTHER TYPE OF
C   DESCRIPTOR OR ANY OTHER SEQUENCE DESCRIPTOR TABLE D CATEGORY.
C   LUNIT MUST ALREADY BE OPENED FOR INPUT OR OUTPUT VIA A CALL TO
C   OPENBF.  THIS ROUTINE IS ESPECIALLY USEFUL WHEN THE CALLING PROGRAM
C   IS WRITING "EVENTS" TO AN OUTPUT BUFR FILE (USUALLY THE "PREPBUFR"
C   FILE) USING THE SAME BUFR TABLE SINCE THE DESCRIPTOR ENTRY (Y) HERE
C   DEFINES THE EVENT PROGRAM CODE.  THUS, THE CALLING PROGRAM CAN PASS
C   THE PROGRAM CODE INTO VARIOUS EVENTS WITHOUT ACTUALLY KNOWING ITS
C   VALUE AS LONG AS IT KNOWS THE MNEMONIC NAME ASSOCIATED WITH IT.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL UFBQCD (LUNIT, NEMO, QCD)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C                (ASSOCIATED BUFR TABLE MAY BE INTERNAL OR EXTERNAL)
C     NEMO     - CHARACTER*(*): MNEMONIC
C
C   OUTPUT ARGUMENT LIST:
C     QCD      - REAL: SEQUENCE DESCRIPTOR ENTRY (I.E., EVENT PROGRAM
C                CODE) IN BUFR TABLE ASSOCIATED WITH NEMO (Y IN FXY
C                DESCRIPTOR, WHERE F=3 AND X=63)
C
C REMARKS:
C    THIS SUBROUTINE IS THE INVERSE OF BUFR ARCHIVE LIBRARY ROUTINE
C    UFBQCP.
C
C    THIS ROUTINE CALLS:        ADN30    BORT     NEMTAB   STATUS
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*(*) NEMO
      CHARACTER*128 BORT_STR
      CHARACTER*6   FXY,ADN30
      CHARACTER*1   TAB

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900

      CALL NEMTAB(LUN,NEMO,IDN,TAB,IRET)
      IF(TAB.NE.'D') GOTO 901

      FXY = ADN30(IDN,6)
      IF(FXY(2:3).NE.'63') GOTO 902
      READ(FXY(4:6),'(F3.0)',ERR=903) QCD

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: UFBQCD - BUFR FILE IS CLOSED, IT MUST BE'//
     . ' OPEN')
901   WRITE(BORT_STR,'("BUFRLIB: UFBQCD - INPUT MNEMONIC ",A," NOT '//
     . 'DEFINED AS A SEQUENCE DESCRIPTOR IN BUFR TABLE")') NEMO
      CALL BORT(BORT_STR)
902   WRITE(BORT_STR,'("BUFRLIB: UFBQCD - BUFR TABLE SEQ. DESCRIPTOR '//
     . 'ASSOC. WITH INPUT MNEMONIC ",A," HAS INVALID CATEGORY ",A," -'//
     . ' CATEGORY MUST BE 63")') NEMO,FXY(2:3)
      CALL BORT(BORT_STR)
903   WRITE(BORT_STR,'("BUFRLIB: UFBQCD - ERROR READING ENTRY '//
     . '(PROGRAM CODE) FROM BUFR TBL SEQ. DESCRIPTOR ",A," ASSOC. '//
     . 'WITH INPUT MNEM. ",A)') FXY,NEMO
      CALL BORT(BORT_STR)
      END
      SUBROUTINE UFBQCP(LUNIT,QCP,NEMO)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBQCP
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE READS IN A FXY DESCRIPTOR ENTRY (Y) FOR A
C   SEQUENCE DESCRIPTOR (F=3) WITH TABLE D CATEGORY 63 (X=63) WHEN THE
C   DESCRIPTOR IS KNOWN TO BE IN THE BUFR TABLE IN LOGICAL UNIT LUNIT,
C   AND RETURNS THE MNEMONIC ASSOCIATED WITH IT.  THIS ROUTINE WILL NOT
C   WORK FOR ANY OTHER TYPE OF DESCRIPTOR OR ANY OTHER SEQUENCE
C   DESCRIPTOR TABLE D CATEGORY.  LUNIT MUST ALREADY BE OPENED FOR
C   INPUT OR OUTPUT VIA A CALL TO BUFR ARCHIVE LIBRARY SUBROUTINE
C   OPENBF.  THIS ROUTINE IS ESPECIALLY USEFUL WHEN THE CALLING PROGRAM
C   IS READING "EVENTS" FROM AN INPUT BUFR FILE IN LUNIT (USUALLY THE
C   "PREPBUFR" FILE) SINCE THE DESCRIPTOR ENTRY (Y) HERE DEFINES THE
C   EVENT PROGRAM CODE.  THUS, THE CALLING PROGRAM CAN OBTAIN THE
C   MNEMONIC NAME ASSOCIATED WITH AN EVENT PROGRAM CODE.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL UFBQCP (LUNIT, QCP, NEMO)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C                (ASSOCIATED BUFR TABLE MAY BE INTERNAL OR EXTERNAL)
C     QCP      - REAL: SEQUENCE DESCRIPTOR ENTRY (I.E., EVENT PROGRAM
C                CODE) (Y IN FXY DESCRIPTOR)
C
C   OUTPUT ARGUMENT LIST:
C     NEMO     - CHARACTER*(*): MNEMONIC IN BUFR TABLE ASSOCIATED WITH
C                SEQUENCE DESCRIPTOR FXY WHERE F=3 AND X=63 AND
C                Y=INT(QCP)
C
C REMARKS:
C    THIS SUBROUTINE IS THE INVERSE OF BUFR ARCHIVE LIBRARY ROUTINE
C    UFBQCD.
C
C    THIS ROUTINE CALLS:        BORT     IFXY     NUMTAB   STATUS
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*(*) NEMO
      CHARACTER*1   TAB

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900

      IDN = IFXY('363000')+IFIX(QCP)
c  .... get NEMO from IDN
      CALL NUMTAB(LUN,IDN,NEMO,TAB,IRET)

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: UFBQCP - BUFR FILE IS CLOSED, IT MUST BE'//
     . ' OPEN')
      END
      SUBROUTINE UFBREP(LUNIO,USR,I1,I2,IRET,STR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBREP
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE WRITES OR READS SPECIFIED VALUES TO OR
C   FROM THE CURRENT BUFR DATA SUBSET WITHIN INTERNAL ARRAYS, WITH THE
C   DIRECTION OF THE DATA TRANSFER DETERMINED BY THE CONTEXT OF
C   ABS(LUNIO) (I.E., IF ABS(LUNIO) POINTS TO A BUFR FILE THAT IS OPEN
C   FOR INPUT, THEN DATA VALUES ARE READ FROM THE INTERNAL DATA SUBSET;
C   OTHERWISE, DATA VALUES ARE WRITTEN TO THE INTERNAL DATA SUBSET.
C   THE DATA VALUES CORRESPOND TO MNEMONICS WHICH ARE PART OF A REGULAR
C   (I.E., NON-DELAYED) REPLICATION SEQUENCE OR FOR THOSE WHICH ARE
C   REPLICATED VIA BEING DIRECTLY LISTED MORE THAN ONCE WITHIN AN
C   OVERALL SUBSET DEFINITION RATHER THAN BY BEING INCLUDED WITHIN A
C   REPLICATION SEQUENCE.  IF UFBREP IS READING VALUES, THEN EITHER
C   BUFR ARCHIVE LIBRARY SUBROUTINE READSB, READERS OR READNS MUST HAVE
C   BEEN PREVIOUSLY CALLED TO READ THE SUBSET FROM UNIT ABS(LUNIO) INTO
C   INTERNAL MEMORY.  IF IT IS WRITING VALUES, THEN EITHER BUFR ARCHIVE
C   LIBRARY SUBROUTINE OPENMG OR OPENMB MUST HAVE BEEN PREVIOUSLY
C   CALLED TO OPEN AND INITIALIZE A BUFR MESSAGE WITHIN MEMORY FOR THIS
C   ABS(LUNIO).
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-05-19  J. WOOLLEN -- DISABLED THE PARSING SWITCH WHICH CONTROLS
C                           CHECKING FOR IN THE SAME REPLICATION GROUP,
C                           UFBREP DOES NOT NEED THIS CHECK, AND IT
C                           INTERFERES WITH WHAT UFBREP CAN DO
C                           OTHERWISE
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY); OUTPUTS MORE COMPLETE DIAGNOSTIC
C                           INFO WHEN ROUTINE TERMINATES ABNORMALLY OR
C                           UNUSUAL THINGS HAPPEN; CHANGED CALL FROM
C                           BORT TO BORT2 IN SOME CASES
C
C USAGE:    CALL UFBREP (LUNIO, USR, I1, I2, IRET, STR)
C   INPUT ARGUMENT LIST:
C     LUNIO    - INTEGER: ABSOLUTE VALUE IS FORTRAN LOGICAL UNIT NUMBER
C                FOR BUFR FILE
C                  - IF BUFR FILE OPEN FOR OUTPUT AND LUNIO IS LESS
C                    THAN ZERO, UFBREP TREATS THE BUFR FILE AS THOUGH
C                    IT WERE OPEN FOR INPUT
C     USR      - ONLY IF BUFR FILE OPEN FOR OUTPUT:
C                   REAL*8: (I1,I2) STARTING ADDRESS OF DATA VALUES
C                   WRITTEN TO DATA SUBSET
C     I1       - INTEGER: LENGTH OF FIRST DIMENSION OF USR OR THE
C                NUMBER OF BLANK-SEPARATED MNEMONICS IN STR (FORMER
C                MUST BE AT LEAST AS LARGE AS LATTER)
C     I2       - INTEGER:
C                  - IF BUFR FILE OPEN FOR INPUT:  LENGTH OF SECOND
C                    DIMENSION OF USR
C                  - IF BUFR FILE OPEN FOR OUTPUT: NUMBER OF "LEVELS"
C                    OF DATA VALUES TO BE WRITTEN TO DATA SUBSET
C                    (MAXIMUM VALUE IS 255)
C     STR      - CHARACTER*(*): STRING OF BLANK-SEPARATED TABLE B
C                MNEMONICS IN ONE-TO-ONE CORRESPONDENCE WITH FIRST
C                DIMENSION OF USR
C
C   OUTPUT ARGUMENT LIST:
C     USR      - ONLY IF BUFR FILE OPEN FOR INPUT:
C                   REAL*8: (I1,I2) STARTING ADDRESS OF DATA VALUES
C                   READ FROM DATA SUBSET
C     IRET     - INTEGER:
C                  - IF BUFR FILE OPEN FOR INPUT: NUMBER OF "LEVELS" OF
C                    DATA VALUES READ FROM DATA SUBSET (MUST BE NO
C                    LARGER THAN I2)
C                  - IF BUFR FILE OPEN FOR OUTPUT: NUMBER OF "LEVELS"
C                    OF DATA VALUES WRITTEN TO DATA SUBSET (SHOULD BE
C                    SAME AS I2)
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     BORT2    STATUS   STRING
C                               UFBRP
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /ACMODE/ IAC
      COMMON /QUIET / IPRT

      CHARACTER*(*) STR
      CHARACTER*128 BORT_STR1,BORT_STR2
      REAL*8        USR(I1,I2),VAL,BMISS

      DATA BMISS /10E10/,IFIRST1/0/,IFIRST2/0/

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      IRET = 0

C  CHECK THE FILE STATUS AND I-NODE
C  --------------------------------

      LUNIT = ABS(LUNIO)
      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IM.EQ.0) GOTO 901
      IF(INODE(LUN).NE.INV(1,LUN)) GOTO 902

      IO = MIN(MAX(0,IL),1)
      IF(LUNIO.NE.LUNIT) IO = 0

      IF(I1.LE.0) THEN
         IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
         PRINT*,'BUFRLIB: UFBREP - THIRD ARGUMENT (INPUT) IS .LE. 0',
     .    ' -  RETURN WITH FIFTH ARGUMENT (IRET) = 0'
         PRINT*,'STR = ',STR
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
         GOTO 100
      ELSEIF(I2.LE.0) THEN
         IF(IPRT.EQ.-1)  IFIRST1 = 1
         IF(IO.EQ.0 .OR. IFIRST1.EQ.0 .OR. IPRT.GE.1)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
            PRINT*,'BUFRLIB: UFBREP - FOURTH ARGUMENT (INPUT) IS .LE. ',
     .       '0 -  RETURN WITH FIFTH ARGUMENT (IRET) = 0'
            PRINT*,'STR = ',STR
            IF(IPRT.EQ.0 .AND. IO.EQ.1)  PRINT 101
101   FORMAT('Note: Only the first occurrence of this WARNING message ',
     . 'is printed, there may be more.  To output'/6X,'ALL WARNING ',
     . 'messages, modify your application program to add ',
     . '"CALL OPENBF(0,''QUIET'',1)" prior'/6X,'to the first call to a',
     . ' BUFRLIB routine.')
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
            IFIRST1 = 1
         ENDIF
         GOTO 100
      ENDIF

C  INITIALIZE USR ARRAY PRECEEDING AN INPUT OPERATION
C  --------------------------------------------------

      IF(IO.EQ.0) THEN
         DO J=1,I2
         DO I=1,I1
         USR(I,J) = BMISS
         ENDDO
         ENDDO
      ENDIF

C  PARSE OR RECALL THE INPUT STRING - READ/WRITE VALUES
C  ----------------------------------------------------

      IA2 = IAC
      IAC = 1
      CALL STRING(STR,LUN,I1,IO)

C  CALL THE MNEMONIC READER/WRITER
C  -------------------------------

      CALL UFBRP(LUN,USR,I1,I2,IO,IRET)
      IAC = IA2

      IF(IO.EQ.1 .AND. IRET.LT.I2) GOTO 903

      IF(IRET.EQ.0)  THEN
         IF(IO.EQ.0) THEN
            IF(IPRT.GE.1)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
               PRINT*,'BUFRLIB: UFBREP - NO SPECIFIED VALUES READ IN',
     .          ' -  RETURN WITH FIFTH ARGUMENT (IRET) = 0'
               PRINT*,'STR = ',STR
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
            ENDIF
         ELSE
            IF(IPRT.EQ.-1)  IFIRST2 = 1
            IF(IFIRST2.EQ.0 .OR. IPRT.GE.1)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
               PRINT*,'BUFRLIB: UFBREP - NO SPECIFIED VALUES WRITTEN ',
     .          'OUT -  RETURN WITH FIFTH ARGUMENT (IRET) = 0'
               PRINT*,'STR = ',STR,' MAY NOT BE IN THE BUFR TABLE(?)'
               IF(IPRT.EQ.0)  PRINT 101
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
               IFIRST2 = 1
            ENDIF
         ENDIF
      ENDIF

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: UFBREP - BUFR FILE IS CLOSED, IT MUST BE'//
     . ' OPEN')
901   CALL BORT('BUFRLIB: UFBREP - A MESSAGE MUST BE OPEN IN BUFR '//
     . 'FILE, NONE ARE')
902   CALL BORT('BUFRLIB: UFBREP - LOCATION OF INTERNAL TABLE FOR '//
     . 'BUFR FILE DOES NOT AGREE WITH EXPECTED LOCATION IN INTERNAL '//
     . 'SUBSET ARRAY')
903   WRITE(BORT_STR1,'("BUFRLIB: UFBREP - MNEMONIC STRING READ IN IS'//
     . ': ",A)') STR
      WRITE(BORT_STR2,'(18X,"THE NUMBER OF ''LEVELS'' ACTUALLY '//
     . 'WRITTEN (",I3,") LESS THAN THE NUMBER REQUESTED (",I3,") - '//
     . 'INCOMPLETE WRITE")')  IRET,I2
      CALL BORT2(BORT_STR1,BORT_STR2)
      END
      SUBROUTINE UFBRMS(IMSG,ISUB,USR,I1,I2,IRET,STR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBRMS
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE READS SPECIFIED VALUES OUT OF A PARTICULAR
C   SUBSET WHICH HAS BEEN READ INTO INTERNAL SUBSET ARRAYS FROM A
C   PARTICULAR BUFR MESSAGE IN INTERNAL MEMORY.  THE DATA VALUES
C   CORRESPOND TO MNEMONICS WHICH ARE PART OF A DELAYED-REPLICATION
C   SEQUENCE, OR FOR WHICH THERE IS NO REPLICATION AT ALL. THE SUBSET
C   READ IN IS BASED ON THE SUBSET NUMBER IN THE MESSAGE AND THE
C   MESSAGE READ IN IS BASED ON THE MESSAGE NUMBER IN INTERNAL MEMORY.
C   THIS SUBROUTINE IS ACTUALLY A COMBINATION OF BUFR ARCHIVE LIBRARY
C   SUBROUTINES RDMEMM, RDMEMS AND UFBINT.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE MAXIMUM NUMBER OF BYTES REQUIRED TO
C                           STORE ALL MESSAGES INTERNALLY WAS INCREASED 
C                           FROM 4 MBYTES TO 8 MBYTES
C 2001-08-15  D. KEYSER  -- PARAMETER MAXMEM (THE MAXIMUM NUMBER OF
C                           BYTES REQUIRED TO STORE ALL MESSAGES
C                           INTERNALLY) WAS INCREASED FROM 8 MBYTES TO
C                           16 MBYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- PARAMETER MAXMSG (THE MAXIMUM NUMBER OF
C                           BUFR MESSAGES WHICH CAN BE STORED
C                           INTERNALLY) INCREASED FROM 50000 TO 200000;
C                           UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY OR UNUSUAL THINGS
C                           HAPPEN
C
C USAGE:    CALL UFBRMS (IMSG, ISUB, USR, I1, I2, IRET, STR)
C   INPUT ARGUMENT LIST:
C     IMSG     - INTEGER: POINTER TO BUFR MESSAGE NUMBER (RECORD) IN
C                STORAGE
C     ISUB     - INTEGER: POINTER TO SUBSET NUMBER TO READ IN BUFR
C                MESSAGE
C     I1       - INTEGER: LENGTH OF FIRST DIMENSION OF USR OR THE
C                NUMBER OF BLANK-SEPARATED MNEMONICS IN STR (FORMER
C                MUST BE AT LEAST AS LARGE AS LATTER)
C     I2       - INTEGER: LENGTH OF SECOND DIMENSION OF USR
C     STR      - CHARACTER*(*): STRING OF BLANK-SEPARATED TABLE B
C                MNEMONICS IN ONE-TO-ONE CORRESPONDENCE WITH FIRST
C                DIMENSION OF USR {THIS CAN ALSO BE A SINGLE TABLE D
C                (SEQUENCE) MNEMONIC WITH EITHER 8- OR 16-BIT DELAYED
C                REPLICATION (SEE REMARKS 1 IN UFBINT DOCBLOCK)}
C
C   OUTPUT ARGUMENT LIST:
C     USR      - REAL*8: (I1,I2) STARTING ADDRESS OF DATA VALUES READ
C                FROM DATA SUBSET
C     IRET     - INTEGER: NUMBER OF "LEVELS" OF DATA VALUES READ FROM
C                DATA SUBSET (MUST BE NO LARGER THAN I2)
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    NOTE THAT UFBMEM IS CALLED PRIOR TO THIS TO STORE THE BUFR
C    MESSAGES INTO INTERNAL MEMORY.
C
C    THIS ROUTINE CALLS:        BORT     RDMEMM   RDMEMS   STATUS
C                               UFBINT
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXMSG=200000,MAXMEM=16000000)
      PARAMETER (NFILES=32)

      COMMON /MSGMEM/ MUNIT,MLAST,MSGP(0:MAXMSG),MSGS(MAXMEM)
      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /QUIET / IPRT

      CHARACTER*(*) STR
      CHARACTER*128 BORT_STR
      CHARACTER*8   SUBSET
      REAL*8        USR(I1,I2)

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IRET = 0
      IF(I1.LE.0) THEN
         IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
         PRINT*,'BUFRLIB: UFBRMS - FOURTH ARGUMENT (INPUT) IS .LE. 0',
     .    ' -  RETURN WITH SIXTH ARGUMENT (IRET) = 0'
         PRINT*,'STR = ',STR
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
         GOTO 100
      ELSEIF(I2.LE.0) THEN
         IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
         PRINT*,'BUFRLIB: UFBRMS - FIFTH ARGUMENT (INPUT) IS .LE. 0',
     .    ' -  RETURN WITH SIXTH ARGUMENT (IRET) = 0'
         PRINT*,'STR = ',STR
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
         GOTO 100
      ENDIF

C  UFBINT SUBSET #ISUB FROM MEMORY MESSAGE #IMSG
C  ---------------------------------------------

      CALL RDMEMM(IMSG,SUBSET,JDATE,IRET)
      IF(IRET.NE.0) GOTO 900
      CALL RDMEMS(ISUB,IRET)
      IF(IRET.NE.0) GOTO 901

      CALL UFBINT(MUNIT,USR,I1,I2,IRET,STR)

C  EXITS
C  -----

100   RETURN
900   IF(IMSG.GT.0)  THEN
      WRITE(BORT_STR,'("BUFRLIB: UFBRMS - REQUESTED MEMORY MESSAGE '//
     . 'NUMBER TO READ IN (",I5,") EXCEEDS THE NUMBER OF MESSAGES IN '//
     . 'MEMORY (",I5,")")') IMSG,MSGP(0)
      ELSE
      WRITE(BORT_STR,'("BUFRLIB: UFBRMS - REQUESTED MEMORY MESSAGE '//
     . 'NUMBER TO READ IN IS ZERO - THIS IS NOT VALID")')
      ENDIF
      CALL BORT(BORT_STR)
901   CALL STATUS(MUNIT,LUN,IL,IM)
      WRITE(BORT_STR,'("BUFRLIB: UFBRMS - REQ. SUBSET NUMBER TO READ '//
     . 'IN (",I3,") EXCEEDS THE NUMBER OF SUBSETS (",I3,") IN THE '//
     . 'REQ. MEMORY MESSAGE (",I5,")")') ISUB,MSUB(LUN),IMSG
      CALL BORT(BORT_STR)
      END
      SUBROUTINE UFBRP(LUN,USR,I1,I2,IO,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBRP
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE WRITES OR READS SPECIFIED VALUES TO OR
C   FROM THE CURRENT BUFR DATA SUBSET WITHIN INTERNAL ARRAYS, WITH THE
C   DIRECTION OF THE DATA TRANSFER DETERMINED BY THE CONTEXT OF IO
C   (I.E., IF IO INDICATES LUN POINTS TO A BUFR FILE THAT IS OPEN FOR
C   INPUT, THEN DATA VALUES ARE READ FROM THE INTERNAL DATA SUBSET;
C   OTHERWISE, DATA VALUES ARE WRITTEN TO THE INTERNAL DATA SUBSET.
C   THE DATA VALUES CORRESPOND TO INTERNAL ARRAYS REPRESENTING PARSED
C   STRINGS OF MNEMONICS WHICH ARE PART OF A REGULAR (I.E., NON-
C   DELAYED) REPLICATION SEQUENCE OR FOR THOSE WHICH ARE REPLICATED
C   VIA BEING DIRECTLY LISTED MORE THAN ONCE WITHIN AN OVERALL SUBSET
C   DEFINITION RATHER THAN BY BEING INCLUDED WITHIN A REPLICATION
C   SEQUENCE.  THIS ROUTINE IS ONLY CALLED BY BUFR ARCHIVE LIBRARY
C   SUBROUTINE UFBREP AND SHOULD NEVER BE CALLED BY ANY APPLICATION
C   PROGRAM (APPLICATION PROGRAMS SHOULD ALWAYS CALL UFBREP TO PERFORM
C   THESE FUNCTIONS).
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- IMPROVED MACHINE PORTABILITY
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY)
C
C USAGE:    CALL UFBRP (LUN, USR, I1, I2, IO, IRET)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     USR      - ONLY IF BUFR FILE OPEN FOR OUTPUT:
C                   REAL*8: (I1,I2) STARTING ADDRESS OF DATA VALUES
C                   WRITTEN TO DATA SUBSET
C     I1       - INTEGER: LENGTH OF FIRST DIMENSION OF USR
C     I2       - INTEGER: LENGTH OF SECOND DIMENSION OF USR
C     IO       - INTEGER: STATUS INDICATOR FOR BUFR FILE ASSOCIATED
C                WITH LUN:
C                       0 = input file
C                       1 = output file
C
C   OUTPUT ARGUMENT LIST:
C     USR      - ONLY IF BUFR FILE OPEN FOR INPUT:
C                   REAL*8: (I1,I2) STARTING ADDRESS OF DATA VALUES
C                   READ FROM DATA SUBSET
C     IRET     - INTEGER:
C                  - IF BUFR FILE OPEN FOR INPUT: NUMBER OF "LEVELS" OF
C                    DATA VALUES READ FROM DATA SUBSET (MUST BE NO
C                    LARGER THAN I2)
C                  - IF BUFR FILE OPEN FOR OUTPUT: NUMBER OF "LEVELS"
C                    OF DATA VALUES WRITTEN TO DATA SUBSET (SHOULD BE
C                    SAME AS I2)
C
C REMARKS:
C    THIS ROUTINE CALLS:        INVTAG
C    THIS ROUTINE IS CALLED BY: UFBREP
C                               Normally not called by any application
C                               programs (they should call UFBREP).
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /USRSTR/ NNOD,NCON,NODS(20),NODC(10),IVLS(10),KONS(10)

      REAL*8 USR(I1,I2),VAL

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      IRET = 0
      INS1 = 0
      INS2 = 0

C  FIND FIRST NON-ZERO NODE IN STRING
C  ----------------------------------

      DO NZ=1,NNOD
      IF(NODS(NZ).GT.0) GOTO 1
      ENDDO
      GOTO 100

C  FRAME A SECTION OF THE BUFFER - RETURN WHEN NO FRAME
C  ----------------------------------------------------

1     IF(INS1+1.GT.NVAL(LUN)) GOTO 100
      IF(IO.EQ.1 .AND. IRET.EQ.I2) GOTO 100
      INS1 = INVTAG(NODS(NZ),LUN,INS1+1,NVAL(LUN))
      IF(INS1.EQ.0) GOTO 100

      INS2 = INVTAG(NODS(NZ),LUN,INS1+1,NVAL(LUN))
      IF(INS2.EQ.0) INS2 = NVAL(LUN)
      IRET = IRET+1

C  READ USER VALUES
C  ----------------

      IF(IO.EQ.0 .AND. IRET.LE.I2) THEN
         DO I=1,NNOD
         IF(NODS(I).GT.0) THEN
            INVN = INVTAG(NODS(I),LUN,INS1,INS2)
            IF(INVN.GT.0) USR(I,IRET) = VAL(INVN,LUN)
         ENDIF
         ENDDO
      ENDIF

C  WRITE USER VALUES
C  -----------------

      IF(IO.EQ.1 .AND. IRET.LE.I2) THEN
         DO I=1,NNOD
         IF(NODS(I).GT.0) THEN
            INVN = INVTAG(NODS(I),LUN,INS1,INS2)
            IF(INVN.GT.0) VAL(INVN,LUN) = USR(I,IRET)
         ENDIF
         ENDDO
      ENDIF

C  GO FOR NEXT FRAME
C  -----------------

      GOTO 1

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE UFBRW(LUN,USR,I1,I2,IO,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBRW (docblock incomplete)
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE WRITES OR READS SPECIFIED VALUES TO OR FROM
C   THE CURRENT BUFR DATA SUBSET WITHIN INTERNAL ARRAYS, WITH THE
C   DIRECTION OF THE DATA TRANSFER DETERMINED BY THE CONTEXT OF IO
C   (I.E., IF IO INDICATES LUN POINTS TO A BUFR FILE THAT IS OPEN FOR
C   INPUT, THEN DATA VALUES ARE READ FROM THE INTERNAL DATA SUBSET;
C   OTHERWISE, DATA VALUES ARE WRITTEN TO THE INTERNAL DATA SUBSET.
C   THE DATA VALUES CORRESPOND TO INTERNAL ARRAYS REPRESENTING PARSED
C   STRINGS OF MNEMONICS WHICH ARE PART OF A DELAYED-REPLICATION
C   SEQUENCE, OR FOR WHICH THERE IS NO REPLICATION AT ALL.  THIS
C   ROUTINE SHOULD NEVER BE CALLED BY ANY APPLICATION PROGRAM
C   (APPLICATION PROGRAMS SHOULD ALWAYS CALL BUFR ARCHIVE LIBRARY
C   SUBROUTINE UFBINT TO PERFORM THESE FUNCTIONS).
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1996-12-11  J. WOOLLEN -- REMOVED A HARD ABORT FOR USERS WHO TRY TO
C                           WRITE NON-EXISTING MNEMONICS
C 1998-07-08  J. WOOLLEN -- IMPROVED MACHINE PORTABILITY
C 1998-10-27  J. WOOLLEN -- MODIFIED TO CORRECT PROBLEMS CAUSED BY IN-
C                           LINING CODE WITH FPP DIRECTIVES
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2002-05-14  J. WOOLLEN -- REMOVED OLD CRAY COMPILER DIRECTIVES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY) (INCOMPLETE)
C
C USAGE:    CALL UFBRW (LUN, USR, I1, I2, IO, IRET)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     USR      - ONLY IF BUFR FILE OPEN FOR OUTPUT:
C                   REAL*8: (I1,I2) STARTING ADDRESS OF DATA VALUES
C                   WRITTEN TO DATA SUBSET
C     I1       - INTEGER: LENGTH OF FIRST DIMENSION OF USR
C     I2       - INTEGER: LENGTH OF SECOND DIMENSION OF USR
C     IO       - INTEGER: STATUS INDICATOR FOR BUFR FILE ASSOCIATED
C                WITH LUN:
C                       0 = input file
C                       1 = output file
C
C   OUTPUT ARGUMENT LIST:
C     USR      - ONLY IF BUFR FILE OPEN FOR INPUT:
C                   REAL*8: (I1,I2) STARTING ADDRESS OF DATA VALUES
C                   READ FROM DATA SUBSET
C     IRET     - INTEGER:
C                  - IF BUFR FILE OPEN FOR INPUT: NUMBER OF "LEVELS" OF
C                    DATA VALUES READ FROM DATA SUBSET (MUST BE NO
C                    LARGER THAN I2)
C                      -1 = ....
C                  - IF BUFR FILE OPEN FOR OUTPUT: NUMBER OF "LEVELS"
C                    OF DATA VALUES WRITTEN TO DATA SUBSET (SHOULD BE
C                    SAME AS I2)
C                      -1 = ....
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        CONWIN   DRSTPL   GETWIN   INVWIN
C                               LSTRPS   NEWWIN   NXTWIN
C    THIS ROUTINE IS CALLED BY: TRYBUMP  UFBINT
C                               Normally not called by any application
C                               programs (they should call UFBINT).
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /USRSTR/ NNOD,NCON,NODS(20),NODC(10),IVLS(10),KONS(10)
      COMMON /QUIET / IPRT

      CHARACTER*10 TAG
      CHARACTER*3  TYP
      REAL*8       USR(I1,I2),VAL,BMISS

      DATA BMISS/10E10/

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      IRET = 0

C  LOOP OVER COND WINDOWS
C  ----------------------

      INC1 = 1
      INC2 = 1

1     CALL CONWIN(LUN,INC1,INC2,I2)
      IF(NNOD.EQ.0) THEN
         IRET = I2
         GOTO 100
      ELSEIF(INC1.EQ.0) THEN
         GOTO 100
      ELSE
         DO I=1,NNOD
         IF(NODS(I).GT.0) THEN
            INS2 = INC1
            CALL GETWIN(NODS(I),LUN,INS1,INS2)
            IF(INS1.EQ.0) GOTO 100
            GOTO 2
         ENDIF
         ENDDO
         IRET = -1
         GOTO 100
      ENDIF

C  LOOP OVER STORE NODES
C  ---------------------

2     IRET = IRET+1

      IF(IPRT.GE.2)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
         PRINT*,'BUFRLIB: UFBRW -  IRET:INS1:INS2:INC1:INC2 = ',IRET,
     .    ':',INS1,':',INS2,':',INC1,':',INC2
         PRINT'(5A10)',(TAG(INV(I,LUN)),I=INS1,INS2)
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT*
      ENDIF

C  WRITE USER VALUES
C  -----------------

      IF(IO.EQ.1 .AND. IRET.LE.I2) THEN
         DO I=1,NNOD
         IF(NODS(I).GT.0) THEN
            IF(USR(I,IRET).NE.BMISS) THEN
               INVN = INVWIN(NODS(I),LUN,INS1,INS2)
               IF(INVN.EQ.0) THEN
                  CALL DRSTPL(NODS(I),LUN,INS1,INS2,INVN)
                  IF(INVN.EQ.0) THEN
                     IRET = 0
                     GOTO 100
                  ENDIF
                  CALL NEWWIN(LUN,INC1,INC2)
                  VAL(INVN,LUN) = USR(I,IRET)
               ELSEIF(LSTRPS(NODS(I),LUN).EQ.0) THEN
                  VAL(INVN,LUN) = USR(I,IRET)
               ELSEIF(VAL(INVN,LUN).EQ.BMISS) THEN
                  VAL(INVN,LUN) = USR(I,IRET)
               ELSE
                  CALL DRSTPL(NODS(I),LUN,INS1,INS2,INVN)
                  IF(INVN.EQ.0) THEN
                     IRET = 0
                     GOTO 100
                  ENDIF
                  CALL NEWWIN(LUN,INC1,INC2)
                  VAL(INVN,LUN) = USR(I,IRET)
               ENDIF
            ENDIF
         ENDIF
         ENDDO
      ENDIF

C  READ USER VALUES
C  ----------------

      IF(IO.EQ.0 .AND. IRET.LE.I2) THEN
         DO I=1,NNOD
         USR(I,IRET) = BMISS
         IF(NODS(I).GT.0) THEN
            INVN = INVWIN(NODS(I),LUN,INS1,INS2)
            IF(INVN.GT.0) USR(I,IRET) = VAL(INVN,LUN)
         ENDIF
         ENDDO
      ENDIF

C  DECIDE WHAT TO DO NEXT
C  ----------------------

      IF(IO.EQ.1.AND.IRET.EQ.I2) GOTO 100
      CALL NXTWIN(LUN,INS1,INS2)
      IF(INS1.GT.0 .AND. INS1.LT.INC2) GOTO 2
      IF(NCON.GT.0) GOTO 1

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE UFBSEQ(LUNIN,USR,I1,I2,IRET,STR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBSEQ
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2000-09-19
C
C ABSTRACT: THIS SUBROUTINE WRITES OR READS SPECIFIED VALUES TO OR
C   FROM THE CURRENT BUFR DATA SUBSET WITHIN INTERNAL ARRAYS, WITH THE
C   DIRECTION OF THE DATA TRANSFER DETERMINED BY THE CONTEXT OF
C   ABS(LUNIN) (I.E., IF ABS(LUNIN) POINTS TO A BUFR FILE THAT IS OPEN
C   FOR INPUT, THEN DATA VALUES ARE READ FROM THE INTERNAL DATA SUBSET;
C   OTHERWISE, DATA VALUES ARE WRITTEN TO THE INTERNAL DATA SUBSET.
C   THE DATA VALUES CORRESPOND TO A SEQUENCE OF TABLE B MNEMONICS ARE
C   REPRESENTED BY A SINGLE TABLE A OR TABLE D SEQUENCE MNEMONIC (WITH
C   EITHER DELAYED-REPLICATION OR NO REPLICATION AT ALL).  IF UFBSEQ
C   IS READING VALUES, THEN EITHER BUFR ARCHIVE LIBRARY SUBROUTINE
C   READSB, READERS OR READNS MUST HAVE BEEN PREVIOUSLY CALLED TO READ
C   THE SUBSET FROM UNIT ABS(LUNIN) INTO INTERNAL MEMORY.  IF IT IS
C   WRITING VALUES, THEN EITHER BUFR ARCHIVE LIBRARY SUBROUTINE OPENMG
C   OR OPENMB MUST HAVE BEEN PREVIOUSLY CALLED TO OPEN AND INITIALIZE A
C   BUFR MESSAGE WITHIN MEMORY FOR THIS ABS(LUNIN).
C
C PROGRAM HISTORY LOG:
C 2000-09-19  J. WOOLLEN -- ORIGINAL AUTHOR
C 2002-05-14  J. WOOLLEN -- IMPROVED GENERALITY, PREVIOUSLY UFBSEQ
C                           WOULD NOT RECOGNIZE COMPRESSED DELAYED
C                           REPLICATION AS A LEGITIMATE DATA STRUCTURE
C 2003-05-19  J. WOOLLEN -- CORRECTED THE LOGIC ARRAY OF EXIT
C                           CONDITIONS FOR THE SUBROUTINE, PREVIOUSLY,
C                           IN SOME CASES, PROPER EXITS WERE MISSED,
C                           GENERATING BOGUS ERROR MESSAGES, BECAUSE OF
C                           SEVERAL MISCELLANEOUS BUGS WHICH ARE NOW
C                           REMOVED
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY); OUTPUTS MORE COMPLETE DIAGNOSTIC
C                           INFO WHEN ROUTINE TERMINATES ABNORMALLY OR
C                           UNUSUAL THINGS HAPPEN
C
C USAGE:    CALL UFBSEQ (LUNIN, USR, I1, I2, IRET, STR)
C   INPUT ARGUMENT LIST:
C     LUNIN    - INTEGER: ABSOLUTE VALUE IS FORTRAN LOGICAL UNIT
C                NUMBER FOR BUFR FILE
C                  - IF BUFR FILE OPEN FOR OUTPUT AND LUNIN IS LESS
C                    THAN ZERO, UFBSEQ TREATS THE BUFR FILE AS THOUGH
C                    IT WERE OPEN FOR INPUT
C     USR      - ONLY IF BUFR FILE OPEN FOR OUTPUT:
C                   REAL*8: (I1,I2) STARTING ADDRESS OF DATA VALUES
C                   WRITTEN TO DATA SUBSET
C     I1       - INTEGER: LENGTH OF FIRST DIMENSION OF USR OR THE
C                NUMBER OF UNIQUE TABLE B MNEMONICS REPRESENTED BY THE
C                SINGLE TABLE A OR TABLE D SEQUENCE MNEMONIC IN STR
C                (FORMER MUST BE AT LEAST AS LARGE AS LATTER)
C     I2       - INTEGER:
C                  - IF BUFR FILE OPEN FOR INPUT:  LENGTH OF SECOND
C                    DIMENSION OF USR
C                  - IF BUFR FILE OPEN FOR OUTPUT: NUMBER OF "LEVELS"
C                    OF DATA VALUES TO BE WRITTEN TO DATA SUBSET
C                    (MAXIMUM VALUE IS 255)
C     STR      - CHARACTER*(*): STRING CONTAINING A SINGLE TABLE A OR
C                TABLE D SEQUENCE MNEMONIC WHOSE SEQUENCE OF TABLE B
C                MNEMONICS ARE IN ONE-TO-ONE CORRESPONDENCE WITH FIRST
C                DIMENSION OF USR
C
C   OUTPUT ARGUMENT LIST:
C     USR      - ONLY IF BUFR FILE OPEN FOR INPUT:
C                   REAL*8: (I1,I2) STARTING ADDRESS OF DATA VALUES
C                   READ FROM DATA SUBSET
C     IRET     - INTEGER:
C                  - IF BUFR FILE OPEN FOR INPUT: NUMBER OF "LEVELS" OF
C                    DATA VALUES READ FROM DATA SUBSET (MUST BE NO
C                    LARGER THAN I2)
C                  - IF BUFR FILE OPEN FOR OUTPUT: NUMBER OF "LEVELS"
C                    OF DATA VALUES WRITTEN TO DATA SUBSET (SHOULD BE
C                    SAME AS I2)
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     INVTAG   INVWIN   PARSEQ
C                               STATUS
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MTAG=10)
      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /QUIET / IPRT

      CHARACTER*(*) STR
      CHARACTER*128 BORT_STR
      CHARACTER*10  TAG,TAGS(MTAG)
      CHARACTER*3   TYP
      REAL*8        USR(I1,I2),VAL,BMISS

      DATA BMISS /10E10/,IFIRST1/0/,IFIRST2/0/

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      IRET = 0

C  CHECK THE FILE STATUS AND I-NODE
C  --------------------------------

      LUNIT = ABS(LUNIN)
      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IM.EQ.0) GOTO 901

      IO = MIN(MAX(0,IL),1)
      IF(LUNIT.NE.LUNIN) IO = 0

      IF(I1.LE.0) THEN
         IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
         PRINT*,'BUFRLIB: UFBSEQ - THIRD ARGUMENT (INPUT) IS .LE. 0',
     .    ' -  RETURN WITH FIFTH ARGUMENT (IRET) = 0'
         PRINT*,'STR = ',STR
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
         GOTO 100
      ELSEIF(I2.LE.0) THEN
         IF(IPRT.EQ.-1)  IFIRST1 = 1
         IF(IO.EQ.0 .OR. IFIRST1.EQ.0 .OR. IPRT.GE.1)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
            PRINT*,'BUFRLIB: UFBSEQ - FOURTH ARGUMENT (INPUT) IS .LE.',
     .       ' 0 -  RETURN WITH FIFTH ARGUMENT (IRET) = 0'
            PRINT*,'STR = ',STR
            IF(IPRT.EQ.0 .AND. IO.EQ.1)  PRINT 101
101   FORMAT('Note: Only the first occurrence of this WARNING message ',
     . 'is printed, there may be more.  To output'/6X,'ALL WARNING ',
     . 'messages, modify your application program to add ',
     . '"CALL OPENBF(0,''QUIET'',1)" prior'/6X,'to the first call to a',
     . ' BUFRLIB routine.')
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
            IFIRST1 = 1
         ENDIF
         GOTO 100
      ENDIF

C  CHECK FOR VALID SEQUENCE AND SEQUENCE LENGTH ARGUMENTS
C  ------------------------------------------------------

      CALL PARSEQ(STR,TAGS,MTAG,NTAG)
      IF(NTAG.LT.1) GOTO 902
      IF(NTAG.GT.1) GOTO 903
      IF(I1.LE.0) GOTO 904
      IF(I2.LE.0) GOTO 905
      IF(INODE(LUN).NE.INV(1,LUN)) GOTO 906


C  INITIALIZE USR ARRAY PRECEEDING AN INPUT OPERATION
C  --------------------------------------------------

      IF(IO.EQ.0) THEN
         DO J=1,I2
         DO I=1,I1
         USR(I,J) = BMISS
         ENDDO
         ENDDO
      ENDIF

C  FIND THE PARAMETERS OF THE SPECIFIED SEQUENCE
C  ---------------------------------------------

      DO NODE=INODE(LUN),ISC(INODE(LUN))
      IF(STR.EQ.TAG(NODE)) THEN
         IF(TYP(NODE).EQ.'SEQ'.OR.TYP(NODE).EQ.'RPC') THEN
            INS1 = INVTAG(NODE,LUN,     1,NVAL(LUN))
            INS2 = INVTAG(NODE,LUN,INS1+1,NVAL(LUN))
            IF(INS1.EQ.0) GOTO 200
            IF(INS2.EQ.0) INS2 = 10E5
            NODS = NODE
            DO WHILE(LINK(NODS).EQ.0.AND.JMPB(NODS).GT.0)
            NODS = JMPB(NODS)
            ENDDO
            IF(LINK(NODS).EQ.0) THEN
               INSX = NVAL(LUN)
            ELSEIF(LINK(NODS).GT.0) THEN
               INSX = INVWIN(LINK(NODS),LUN,INS1+1,NVAL(LUN))-1
            ENDIF
            INS2 = MIN(INS2,INSX)
         ELSEIF(TYP(NODE).EQ.'SUB') THEN
            INS1 = 1
            INS2 = NVAL(LUN)
         ELSE
            GOTO 907
         ENDIF
         NSEQ = 0
         DO ISQ=INS1,INS2
         ITYP = ITP(INV(ISQ,LUN))
         IF(ITYP.GT.1) NSEQ = NSEQ+1
         ENDDO
         IF(NSEQ.GT.I1) GOTO 908
         GOTO 1
      ENDIF
      ENDDO

      GOTO 200

C  FRAME A SECTION OF THE BUFFER - RETURN WHEN NO FRAME
C  ----------------------------------------------------

1     INS1 = INVTAG(NODE,LUN,INS1,NVAL(LUN))
c  .... previous SP version of BUFR ARCHIVE LIBRARY has line below
c       (note ".gt.")
      IF(INS1.GT.NVAL(LUN)) GOTO 200
      IF(INS1.GT.0) THEN
c  .... previous decoder version of BUFR ARCHIVE LIBRARY has line below
c       (note ".ge.")
ccccc    IF(INS1.GE.NVAL(LUN)) GOTO 200
         IF(TYP(NODE).EQ.'RPC'.AND.VAL(INS1,LUN).EQ.0.) THEN
            INS1 = INS1+1
            GOTO 1
         ELSEIF(IO.EQ.0.AND.IRET+1.GT.I2) THEN
            GOTO 909
         ENDIF
      ELSEIF(INS1.EQ.0) THEN
         IF(IO.EQ.1.AND.IRET.LT.I2) GOTO 910
      ELSE
         GOTO 911
      ENDIF

      IF(INS1.EQ. 0) GOTO 200
      IF(IRET.EQ.I2) GOTO 200

      IRET = IRET+1
      INS1 = INS1+1

C  READ/WRITE USER VALUES
C  ----------------------

      J = INS1
      DO I=1,NSEQ
      DO WHILE(ITP(INV(J,LUN)).LT.2)
      J = J+1
      ENDDO
      IF(IO.EQ.0) USR(I,IRET) = VAL(J,LUN )
      IF(IO.EQ.1) VAL(J,LUN ) = USR(I,IRET)
      J = J+1
      ENDDO

C  CHECK FOR NEXT FRAME
C  --------------------

      GOTO 1

200   CONTINUE

      IF(IRET.EQ.0)  THEN
         IF(IO.EQ.0) THEN
            IF(IPRT.GE.1)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
               PRINT*,'BUFRLIB: UFBSEQ - NO SPECIFIED VALUES READ IN',
     .          ' -  RETURN WITH FIFTH ARGUMENT (IRET) = 0'
               PRINT*,'STR = ',STR
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
            ENDIF
         ELSE
            IF(IPRT.EQ.-1)  IFIRST2 = 1
            IF(IFIRST2.EQ.0 .OR. IPRT.GE.1)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
               PRINT*,'BUFRLIB: UFBSEQ - NO SPECIFIED VALUES WRITTEN ',
     .          'OUT -  RETURN WITH FIFTH ARGUMENT (IRET) = 0'
               PRINT*,'STR = ',STR,' MAY NOT BE IN THE BUFR TABLE(?)'
               IF(IPRT.EQ.0)  PRINT 101
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
               IFIRST2 = 1
            ENDIF
         ENDIF
      ENDIF

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: UFBSEQ - BUFR FILE IS CLOSED, IT MUST BE'//
     . ' OPEN')
901   CALL BORT('BUFRLIB: UFBSEQ - A MESSAGE MUST BE OPEN IN BUFR '//
     . 'FILE, NONE ARE')
902   WRITE(BORT_STR,'("BUFRLIB: UFBSEQ - THE INPUT STRING (",A,") '//
     . 'DOES NOT CONTAIN ANY MNEMONICS!!")') STR
      CALL BORT(BORT_STR)
903   WRITE(BORT_STR,'("BUFRLIB: UFBSEQ - THERE CANNOT BE MORE THAN '//
     . 'ONE MNEMONIC IN THE INPUT STRING (",A,") (HERE THERE ARE ",I3'//
     . ',")")') STR,NTAG
      CALL BORT(BORT_STR)
904   WRITE(BORT_STR,'("BUFRLIB: UFBSEQ - THIRD ARGUMENT (INPUT) MUST'//
     . ' BE .GT. ZERO (HERE IT IS",I4,") - INPUT MNEMONIC IS ",A)')
     . I1,TAGS(1)
      CALL BORT(BORT_STR)
905   WRITE(BORT_STR,'("BUFRLIB: UFBSEQ - FOURTH ARGUMENT (INPUT) '//
     . 'MUST BE .GT. ZERO (HERE IT IS",I4,") - INPUT MNEMONIC IS ",A)')
     . I2,TAGS(1)
      CALL BORT(BORT_STR)
906   CALL BORT('BUFRLIB: UFBSEQ - LOCATION OF INTERNAL TABLE FOR '//
     . 'BUFR FILE DOES NOT AGREE WITH EXPECTED LOCATION IN INTERNAL '//
     . 'SUBSET ARRAY')
907   WRITE(BORT_STR,'("BUFRLIB: UFBSEQ - INPUT MNEMONIC ",A," MUST '//
     . 'BE A SEQUENCE (HERE IT IS TYPE """,A,""")")') TAGS(1),TYP(NODE)
      CALL BORT(BORT_STR)
908   WRITE(BORT_STR,'("BUFRLIB: UFBSEQ - INPUT SEQ. MNEM. ",A,'//
     . '" CONSISTS OF",I4," TABLE B MNEM., .GT. THE MAX. SPECIFIED IN'//
     . ' (INPUT) ARGUMENT 3 (",I3,")")') TAGS(1),NSEQ,I1
      CALL BORT(BORT_STR)
909   WRITE(BORT_STR,'("BUFRLIB: UFBSEQ - NO. OF ''LEVELS'' READ > '//
     . 'LIMIT OF",I4," IN THE 4-TH ARG. (INPUT) - INCOMPLETE READ '//
     . '(INPUT MNEMONIC IS ",A,")")') I2,TAGS(1)
      CALL BORT(BORT_STR)
910   WRITE(BORT_STR,'("BUFRLIB: UFBSEQ - NO. OF ''LEVELS'' WRITTEN '//
     . '(",I3,") .LT. NO. REQUESTED (",I3,") - INCOMPLETE WRITE '//
     . '(INPUT MNEMONIC IS ",A,")")')  IRET,I2,TAGS(1)
      CALL BORT(BORT_STR)
911   WRITE(BORT_STR,'("BUFRLIB: UFBSEQ - VARIABLE INS1 MUST BE .GE. '//
     . 'ZERO, HERE IT IS",I4," - INPUT MNEMONIC IS ",A)') INS1,TAGS(1)
      CALL BORT(BORT_STR)
      END
      SUBROUTINE UFBSP(LUN,USR,I1,I2,IO,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBSP (docblock incomplete)
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1999-11-18
C
C ABSTRACT: THIS SUBROUTINE WRITES OR READS
C  ....
C  THIS ROUTINE IS ONLY CALLED BY UFBSTP AND SHOULD NEVER BE CALLED BY
C  ANY APPLICATION PROGRAM (APPLICATION PROGRAMS SHOULD ALWAYS CALL
C  BUFR ARCHIVE LIBRARY SUBROUTINE UFBSTP TO PERFORM THESE FUNCTIONS).
C
C PROGRAM HISTORY LOG:
C 1999-11-18  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY) (INCOMPLETE)
C
C USAGE:    CALL UFBSP (LUN, USR, I1, I2, IO, IRET)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     USR      - ONLY IF BUFR FILE OPEN FOR OUTPUT:
C                   REAL*8: (I1,I2) STARTING ADDRESS OF DATA VALUES
C                   WRITTEN TO DATA SUBSET
C     I1       - INTEGER: LENGTH OF FIRST DIMENSION OF USR
C     I2       - INTEGER: LENGTH OF SECOND DIMENSION OF USR
C     IO       - INTEGER: STATUS INDICATOR FOR BUFR FILE ASSOCIATED
C                WITH LUN:
C                       0 = input file
C                       1 = output file
C
C   OUTPUT ARGUMENT LIST:
C     USR      - ONLY IF BUFR FILE OPEN FOR INPUT:
C                   REAL*8: (I1,I2) STARTING ADDRESS OF DATA VALUES
C                   READ FROM DATA SUBSET
C     IRET     - INTEGER:
C                  - IF BUFR FILE OPEN FOR INPUT: NUMBER OF "LEVELS" OF
C                    DATA VALUES READ FROM DATA SUBSET (MUST BE NO
C                    LARGER THAN I2)
C                  - IF BUFR FILE OPEN FOR OUTPUT: NUMBER OF "LEVELS"
C                    OF DATA VALUES WRITTEN TO DATA SUBSET (SHOULD BE
C                    SAME AS I2)
C
C REMARKS:
C    THIS ROUTINE CALLS:        INVTAG
C    THIS ROUTINE IS CALLED BY: UFBSTP
C                               Normally not called by any application
C                               programs (they should call UFBSTP).
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /USRSTR/ NNOD,NCON,NODS(20),NODC(10),IVLS(10),KONS(10)

      REAL*8  USR(I1,I2),VAL

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      IRET = 0
      INS1 = 0
      INS2 = 0

C  FRAME A SECTION OF THE BUFFER - RETURN WHEN NO FRAME
C  ----------------------------------------------------

1     IF(INS1+1.GT.NVAL(LUN)) GOTO 100
      INS1 = INVTAG(NODS(1),LUN,INS1+1,NVAL(LUN))
      IF(INS1.EQ.0) GOTO 100

      INS2 = INVTAG(NODS(1),LUN,INS1+1,NVAL(LUN))
      IF(INS2.EQ.0) INS2 = NVAL(LUN)
      IRET = IRET+1

C  READ USER VALUES
C  ----------------

      IF(IO.EQ.0 .AND. IRET.LE.I2) THEN
         INVM = INS1
         DO I=1,NNOD
         IF(NODS(I).GT.0) THEN
            INVN = INVTAG(NODS(I),LUN,INVM,INS2)
            IF(INVN.GT.0) USR(I,IRET) = VAL(INVN,LUN)
            INVM = MAX(INVN,INVM)
         ENDIF
         ENDDO
      ENDIF

C  WRITE USER VALUES
C  -----------------

      IF(IO.EQ.1 .AND. IRET.LE.I2) THEN
         INVM = INS1
         DO I=1,NNOD
         IF(NODS(I).GT.0) THEN
            INVN = INVTAG(NODS(I),LUN,INVM,INS2)
            IF(INVN.GT.0) VAL(INVN,LUN) = USR(I,IRET)
            INVM = MAX(INVN,INVM)
         ENDIF
         ENDDO
      ENDIF

C  GO FOR NEXT FRAME
C  -----------------

      GOTO 1

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE UFBSTP(LUNIO,USR,I1,I2,IRET,STR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBSTP (docblock incomplete)
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1999-11-18
C
C ABSTRACT: THIS SUBROUTINE WRITES OR READS SPECIFIED VALUES TO OR FROM
C   THE CURRENT BUFR DATA SUBSET WITHIN INTERNAL ARRAYS, WITH THE
C   DIRECTION OF THE DATA TRANSFER DETERMINED BY THE CONTEXT OF
C   ABS(LUNIO) (I.E., IF ABS(LUNIO) POINTS TO A BUFR FILE THAT IS OPEN
C   FOR INPUT, THEN DATA VALUES ARE READ FROM THE INTERNAL DATA SUBSET;
C   OTHERWISE, DATA VALUES ARE WRITTEN TO THE INTERNAL DATA SUBSET.
C   THE DATA VALUES CORRESPOND TO MNEMONICS WHICH ARE
C   ....
C   IF UFBSTP IS READING VALUES, THEN EITHER BUFR ARCHIVE LIBRARY
C   SUBROUTINE READSB, READERS OR READNS MUST HAVE BEEN PREVIOUSLY
C   CALLED TO READ THE SUBSET FROM UNIT ABS(LUNIO) INTO INTERNAL
C   MEMORY.  IF IT IS WRITING VALUES, THEN EITHER BUFR ARCHIVE LIBRARY
C   SUBROUTINE OPENMG OR OPENMB MUST HAVE BEEN PREVIOUSLY CALLED TO
C   OPEN AND INITIALIZE A BUFR MESSAGE WITHIN MEMORY FOR THIS ABS(LUNIO).
C
C PROGRAM HISTORY LOG:
C 1999-11-18  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY) (INCOMPLETE); OUTPUTS MORE
C                           COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY OR UNUSUAL THINGS
C                           HAPPEN; CHANGED CALL FROM BORT TO BORT2 IN
C                           SOME CASES
C
C USAGE:    CALL UFBSTP (LUNIO, USR, I1, I2, IRET, STR)
C   INPUT ARGUMENT LIST:
C     LUNIO    - INTEGER: ABSOLUTE VALUE IS FORTRAN LOGICAL UNIT
C                NUMBER FOR BUFR FILE
C                  - IF BUFR FILE OPEN FOR OUTPUT AND LUNIO IS LESS
C                    THAN ZERO, UFBSTP TREATS THE BUFR FILE AS THOUGH
C                    IT WERE OPEN FOR INPUT
C     USR      - ONLY IF BUFR FILE OPEN FOR OUTPUT:
C                   REAL*8: (I1,I2) STARTING ADDRESS OF DATA VALUES
C                   WRITTEN TO DATA SUBSET
C     I1       - INTEGER: LENGTH OF FIRST DIMENSION OF USR OR THE
C                NUMBER OF BLANK-SEPARATED MNEMONICS IN STR (FORMER
C                MUST BE AT LEAST AS LARGE AS LATTER)
C     I2       - INTEGER:
C                  - IF BUFR FILE OPEN FOR INPUT:  LENGTH OF SECOND
C                    DIMENSION OF USR
C                  - IF BUFR FILE OPEN FOR OUTPUT: NUMBER OF "LEVELS
C                    OF DATA VALUES TO BE WRITTEN TO DATA SUBSET
C                    (MAXIMUM VALUE IS 255)
C     STR      - CHARACTER*(*): STRING ....
C
C   OUTPUT ARGUMENT LIST:
C     USR      - ONLY IF BUFR FILE OPEN FOR INPUT:
C                   REAL*8: (I1,I2) STARTING ADDRESS OF DATA VALUES
C                   READ FROM DATA SUBSET
C     IRET     - INTEGER:
C                  - IF BUFR FILE OPEN FOR INPUT: NUMBER OF "LEVELS" OF
C                    DATA VALUES READ FROM DATA SUBSET (MUST BE NO
C                    LARGER THAN I2)
C                  - IF BUFR FILE OPEN FOR OUTPUT: NUMBER OF "LEVELS"
C                    OF DATA VALUES WRITTEN TO DATA SUBSET (SHOULD BE
C                    SAME AS I2)
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     BORT2    STATUS   STRING
C                               UFBSP
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /QUIET / IPRT

      CHARACTER*(*) STR
      CHARACTER*128 BORT_STR1,BORT_STR2
      REAL*8        USR(I1,I2),VAL,BMISS

      DATA BMISS /10E10/,IFIRST1/0/,IFIRST2/0/

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      IRET = 0

C  CHECK THE FILE STATUS AND I-NODE
C  --------------------------------

      LUNIT = ABS(LUNIO)
      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IM.EQ.0) GOTO 901
      IF(INODE(LUN).NE.INV(1,LUN)) GOTO 902

      IO = MIN(MAX(0,IL),1)
      IF(LUNIO.NE.LUNIT) IO = 0

      IF(I1.LE.0) THEN
         IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
         PRINT*,'BUFRLIB: UFBSTP - THIRD ARGUMENT (INPUT) IS .LE. 0',
     .    ' -  RETURN WITH FIFTH ARGUMENT (IRET) = 0'
         PRINT*,'STR = ',STR
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
         GOTO 100
      ELSEIF(I2.LE.0) THEN
         IF(IPRT.EQ.-1)  IFIRST1 = 1
         IF(IO.EQ.0 .OR. IFIRST1.EQ.0 .OR. IPRT.GE.1)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
            PRINT*,'BUFRLIB: UFBSTP - FOURTH ARGUMENT (INPUT) IS .LE. ',
     .       '0 -  RETURN WITH FIFTH ARGUMENT (IRET) = 0'
            PRINT*,'STR = ',STR
            IF(IPRT.EQ.0 .AND. IO.EQ.1)  PRINT 101
101   FORMAT('Note: Only the first occurrence of this WARNING message ',
     . 'is printed, there may be more.  To output'/6X,'ALL WARNING ',
     . 'messages, modify your application program to add ',
     . '"CALL OPENBF(0,''QUIET'',1)" prior'/6X,'to the first call to a',
     . ' BUFRLIB routine.')
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
            IFIRST1 = 1
         ENDIF
         GOTO 100
      ENDIF

C  INITIALIZE USR ARRAY PRECEEDING AN INPUT OPERATION
C  --------------------------------------------------

      IF(IO.EQ.0) THEN
         DO J=1,I2
         DO I=1,I1
         USR(I,J) = BMISS
         ENDDO
         ENDDO
      ENDIF

C  PARSE OR RECALL THE INPUT STRING - READ/WRITE VALUES
C  ----------------------------------------------------

      CALL STRING(STR,LUN,I1,IO)

C  CALL THE MNEMONIC READER/WRITER
C  -------------------------------

      CALL UFBSP(LUN,USR,I1,I2,IO,IRET)

      IF(IO.EQ.1 .AND. IRET.NE.I2) GOTO 903

      IF(IRET.EQ.0)  THEN
         IF(IO.EQ.0) THEN
            IF(IPRT.GE.1)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
               PRINT*,'BUFRLIB: UFBSTP - NO SPECIFIED VALUES READ IN',
     .          ' -  RETURN WITH FIFTH ARGUMENT (IRET) = 0'
               PRINT*,'STR = ',STR
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
            ENDIF
         ELSE
            IF(IPRT.EQ.-1)  IFIRST2 = 1
            IF(IFIRST2.EQ.0 .OR. IPRT.GE.1)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
               PRINT*,'BUFRLIB: UFBSTP - NO SPECIFIED VALUES WRITTEN ',
     .          'OUT -  RETURN WITH FIFTH ARGUMENT (IRET) = 0'
               PRINT*,'STR = ',STR,' MAY NOT BE IN THE BUFR TABLE(?)'
               IF(IPRT.EQ.0)  PRINT 101
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
               IFIRST2 = 1
            ENDIF
         ENDIF
      ENDIF

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: UFBSTP - BUFR FILE IS CLOSED, IT MUST BE'//
     . ' OPEN')
901   CALL BORT('BUFRLIB: UFBSTP - A MESSAGE MUST BE OPEN IN BUFR '//
     . 'FILE, NONE ARE')
902   CALL BORT('BUFRLIB: UFBSTP - LOCATION OF INTERNAL TABLE FOR '//
     . 'BUFR FILE DOES NOT AGREE WITH EXPECTED LOCATION IN INTERNAL '//
     . 'SUBSET ARRAY')
903   WRITE(BORT_STR1,'("BUFRLIB: UFBSTP - MNEMONIC STRING READ IN IS'//
     . ': ",A)') STR
      WRITE(BORT_STR2,'(18X,"THE NUMBER OF ''LEVELS'' ACTUALLY '//
     . 'WRITTEN (",I3,") DOES NOT EQUAL THE NUMBER REQUESTED (",I3,")'//
     . ' - INCOMPLETE WRITE")')  IRET,I2
      CALL BORT2(BORT_STR1,BORT_STR2)
      END
      SUBROUTINE UFBTAB(LUNIT,TAB,I1,I2,IRET,STR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBTAB
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE EITHER OPENS A BUFR FILE CONNECTED TO
C   LUNIT FOR INPUT OPERATIONS (IF IT IS NOT ALREADY OPENED AS SUCH),
C   OR SAVES ITS POSITION AND REWINDS IT TO THE FIRST DATA MESSAGE (IF
C   BUFR FILE ALREADY OPENED), THEN READS SPECIFIED VALUES FROM ALL
C   DATA SUBSETS IN THE BUFR FILE INTO INTERNAL ARRAYS.  FINALLY, THIS
C   SUBROUTINE EITHER CLOSES THE BUFR FILE IN LUNIT (IF IS WAS OPENED
C   HERE) OR RESTORES IT TO ITS PREVIOUS READ/WRITE STATUS AND
C   POSITION (IF IS WAS NOT OPENED HERE).  THE DATA VALUES CORRESPOND
C   TO MNEMONICS, NORMALLY WHERE THERE IS NO REPLICATION (THERE CAN BE
C   REGULAR OR DELAYED REPLICATION, BUT THIS SUBROUTINE WILL ONLY READ
C   THE FIRST OCCURRENCE OF THE MNEMONIC IN EACH SUBSET).  UFBTAB
C   PROVIDES A MECHANISM WHEREBY A USER CAN DO A QUICK SCAN OF THE
C   RANGE OF VALUES CORRESPONDING TO ONE OR MORE MNEMNONICS AMONGST ALL
C   DATA SUBSETS FOR AN ENTIRE BUFR FILE, NO OTHER BUFR ARCHIVE LIBRARY
C   ROUTINES HAVE TO BE CALLED.  THIS SUBROUTINE IS SIMILAR TO BUFR
C   ARCHIVE LIBRARY SUBROUTINE UFBTAM EXCEPT UFBTAM READS SUBSETS FROM
C   MESSAGES STORED IN INTERNAL MEMORY.  UFBTAB CURRENTLY CANNOT READ
C   DATA FROM COMPRESSED BUFR MESSAGES.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- IMPROVED MACHINE PORTABILITY
C 1998-10-27  J. WOOLLEN -- MODIFIED TO CORRECT PROBLEMS CAUSED BY IN-
C                           LINING CODE WITH FPP DIRECTIVES
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2002-05-14  J. WOOLLEN -- REMOVED OLD CRAY COMPILER DIRECTIVES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MODIFIED TO NOT ABORT WHEN THERE ARE TOO
C                           MANY SUBSETS COMING IN (I.E., .GT. "I2"),
C                           BUT RATHER JUST PROCESS "I2" REPORTS AND
C                           PRINT A DIAGNOSTIC; MAXJL (MAXIMUM NUMBER
C                           OF JUMP/LINK ENTRIES) INCREASED FROM 15000
C                           TO 16000 (WAS IN VERIFICATION VERSION); 
C                           MODIFIED TO CALL ROUTINE REWNBF WHEN THE
C                           BUFR FILE IS ALREADY OPENED, ALLOWS
C                           SPECIFIC SUBSET INFORMATION TO BE READ FROM
C                           A FILE IN THE MIDST OF ITS BEING READ FROM
C                           OR WRITTEN TO), BEFORE OPENBF WAS ALWAYS
C                           CALLED AND THIS WOULD HAVE LED TO AN ABORT
C                           OF THE APPLICATION PROGRAM (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY)
C
C USAGE:    CALL UFBTAB (LUNIT, TAB, I1, I2, IRET, STR)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     I1       - INTEGER: LENGTH OF FIRST DIMENSION OF TAB OR THE
C                NUMBER OF BLANK-SEPARATED MNEMONICS IN STR (FORMER
C                MUST BE .GE. LATTER)
C     I2       - INTEGER: LENGTH OF SECOND DIMENSION OF TAB
C     STR      - CHARACTER*(*): STRING OF BLANK-SEPARATED TABLE B
C                MNEMONICS IN ONE-TO-ONE CORRESPONDENCE WITH FIRST
C                DIMENSION OF TAB
C
C   OUTPUT ARGUMENT LIST:
C     TAB      - REAL*8: (I1,I2) STARTING ADDRESS OF DATA VALUES READ
C                FROM BUFR FILE
C     IRET     - INTEGER: NUMBER OF DATA SUBSETS IN BUFR FILE (MUST BE
C                NO LARGER THAN I2)
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    NOTE THAT UFBMEM CAN BE CALLED PRIOR TO THIS TO STORE THE BUFR
C    MESSAGES INTO INTERNAL MEMORY.
C
C    THIS ROUTINE CALLS:        CLOSBF   IREADMG  IREADSB  NMSUB
C                               OPENBF   PARSEQ   READMG   REWNBF
C                               STATUS   STRING   UPB      UPBB
C                               UPC      USRTPL
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /USRSTR/ NNOD,NCON,NODS(20),NODC(10),IVLS(10),KONS(10)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)
      COMMON /ACMODE/ IAC
      COMMON /QUIET / IPRT

      CHARACTER*(*) STR
      CHARACTER*10  TAG,TGS(100)
      CHARACTER*8   SUBSET,CVAL
      CHARACTER*3   TYP
      EQUIVALENCE   (CVAL,RVAL)
      LOGICAL       OPENIT
      REAL*8        VAL,TAB(I1,I2),RVAL,BMISS,UPS,TEN

      DATA BMISS /10E10/
      DATA MAXTG /100/
      DATA TEN   /10/

C-----------------------------------------------------------------------
      MPS(NODE) = 2**(IBT(NODE))-1
      UPS(NODE) = (IVAL+IRF(NODE))*TEN**(-ISC(NODE))
C-----------------------------------------------------------------------

      IRET = 0
      IREC = 0
      ISUB = 0
      IACC = IAC

      DO J=1,I2
      DO I=1,I1
      TAB(I,J) = BMISS
      ENDDO
      ENDDO

      CALL STATUS(LUNIT,LUN,IL,IM)
      OPENIT = IL.EQ.0

      IF(OPENIT) THEN

C  OPEN BUFR FILE CONNECTED TO UNIT LUNIT IF IT IS NOT ALREADY OPEN
C  ----------------------------------------------------------------

         CALL OPENBF(LUNIT,'IN',LUNIT)
      ELSE

C  IF BUFR FILE ALREADY OPENED, SAVE POSITION & REWIND TO FIRST DATA MSG
C  ---------------------------------------------------------------------

         CALL REWNBF(LUNIT,0)
      ENDIF

      IAC = 1

C  CHECK FOR SPECIAL TAGS IN STRING
C  --------------------------------

      CALL PARSEQ(STR,TGS,MAXTG,NTG)
      DO I=1,NTG
      IF(TGS(I).EQ.'IREC') IREC = I
      IF(TGS(I).EQ.'ISUB') ISUB = I
      ENDDO

C  READ A MESSAGE AND PARSE A STRING
C  ---------------------------------

10    CALL READMG(LUNIT,SUBSET,JDATE,MRET)
      IF(MRET.NE.0) GOTO 25
      CALL STRING(STR,LUN,I1,0)
      IF(IREC.GT.0) NODS(IREC) = 0
      IF(ISUB.GT.0) NODS(ISUB) = 0

C  SEE IF THERE IS ANOTHER SUBSET IN THE MESSAGE
C  ---------------------------------------------

15    IF(NSUB(LUN).EQ.MSUB(LUN)) GOTO 10
      IF(IRET+1.GT.I2) GOTO 99
      IRET = IRET+1

      DO I=1,NNOD
      NODS(I) = ABS(NODS(I))
      ENDDO

C  PARSE THE STRING NODES FROM A SUBSET
C  ------------------------------------

      MBIT = MBYT(LUN)*8 + 16
      NBIT = 0
      N = 1
      CALL USRTPL(LUN,N,N)
20    IF(N+1.LE.NVAL(LUN)) THEN
         N = N+1
         NODE = INV(N,LUN)
         MBIT = MBIT+NBIT
         NBIT = IBT(NODE)
         IF(ITP(NODE).EQ.1) THEN
            CALL UPBB(IVAL,NBIT,MBIT,MBAY(1,LUN))
            CALL USRTPL(LUN,N,IVAL)
         ENDIF
         DO I=1,NNOD
         IF(NODS(I).EQ.NODE) THEN
            IF(ITP(NODE).EQ.1) THEN
               CALL UPBB(IVAL,NBIT,MBIT,MBAY(1,LUN))
               TAB(I,IRET) = IVAL
            ELSEIF(ITP(NODE).EQ.2) THEN
               CALL UPBB(IVAL,NBIT,MBIT,MBAY(1,LUN))
               IF(IVAL.LT.MPS(NODE)) TAB(I,IRET) = UPS(NODE)
            ELSEIF(ITP(NODE).EQ.3) THEN
               CVAL = ' '
               KBIT = MBIT
               CALL UPC(CVAL,NBIT/8,MBAY(1,LUN),KBIT)
               TAB(I,IRET) = RVAL
            ENDIF
            NODS(I) = -NODS(I)
            GOTO 20
         ENDIF
         ENDDO
         DO I=1,NNOD
         IF(NODS(I).GT.0) GOTO 20
         ENDDO
      ENDIF

C  UPDATE THE SUBSET POINTERS BEFORE NEXT READ
C  -------------------------------------------

      IBIT = MBYT(LUN)*8
      CALL UPB(NBYT,16,MBAY(1,LUN),IBIT)
      MBYT(LUN) = MBYT(LUN) + NBYT
      NSUB(LUN) = NSUB(LUN) + 1
      IF(IREC.GT.0) TAB(IREC,IRET) = NMSG(LUN)
      IF(ISUB.GT.0) TAB(ISUB,IRET) = NSUB(LUN)
      GOTO 15

C  EMERGENCY ROOM TREATMENT FOR ARRAY OVERFLOW
C  -------------------------------------------

99    NREP = IRET
      DO WHILE(IREADSB(LUNIT).EQ.0)
      NREP = NREP+1
      ENDDO
      DO WHILE(IREADMG(LUNIT,SUBSET,JDATE).EQ.0)
      NREP = NREP+NMSUB(LUNIT)
      ENDDO
      IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*,'BUFRLIB: UFBTAB - THE NO. OF DATA SUBSETS IN THE BUFR',
     . ' FILE IS .GT. LIMIT OF ',I2,' IN THE 4-TH ARG. (INPUT) - ',
     . 'INCOMPLETE READ'
      PRINT*,'>>>UFBTAB STORED ',IRET,' REPORTS OUT OF ',NREP,'<<<'
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
      ENDIF

25    IF(OPENIT) THEN

C  CLOSE BUFR FILE IF IT WAS OPENED HERE
C  -------------------------------------

         CALL CLOSBF(LUNIT)
      ELSE

C  RESTORE BUFR FILE TO PREV. STATUS & POSITION IF NOT ORIG. OPENED HERE
C  ---------------------------------------------------------------------

         CALL REWNBF(LUNIT,1)
      ENDIF

      IAC = IACC

      RETURN
      END
      SUBROUTINE UFBTAM(TAB,I1,I2,IRET,STR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFBTAM
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE READS SPECIFIED VALUES INTO INTERNAL ARRAYS
C   FROM ALL DATA SUBSETS IN BUFR MESSAGES STORED IN INTERNAL MEMORY.
C   THE DATA VALUES CORRESPOND TO MNEMONICS, NORMALLY WHERE THERE IS NO
C   REPLICATION (THERE CAN BE REGULAR OR DELAYED REPLICATION, BUT THIS
C   SUBROUTINE WILL ONLY READ THE FIRST OCCURRENCE OF THE MNEMONIC IN
C   EACH SUBSET).  UFBTAM PROVIDES A MECHANISM WHEREBY A USER CAN DO A
C   QUICK SCAN OF THE RANGE OF VALUES CORRESPONDING TO ONE OR MORE
C   MNEMNONICS AMONGST ALL DATA SUBSETS FOR A GROUP OF BUFR MESSAGES
C   STORED IN INTERNAL MEMORY, NO OTHER BUFR ARCHIVE LIBRARY ROUTINES
C   HAVE TO BE CALLED.  THIS SUBROUTINE IS SIMILAR TO BUFR ARCHIVE
C   LIBRARY SUBROUTINE UFBTAB EXCEPT UFBTAB READS SUBSETS FROM MESSAGES
C   IN A PHYSICAL BUFR FILE.  UFBTAM CURRENTLY CANNOT READ DATA FROM
C   COMPRESSED BUFR MESSAGES.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1998-10-27  J. WOOLLEN -- MODIFIED TO CORRECT PROBLEMS CAUSED BY IN-
C                           LINING CODE WITH FPP DIRECTIVES
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2001-08-15  D. KEYSER  -- PARAMETER MAXMEM (THE MAXIMUM NUMBER OF
C                           BYTES REQUIRED TO STORE ALL MESSAGES
C                           INTERNALLY) WAS INCREASED FROM 8 MBYTES TO
C                           16 MBYTES; MODIFIED TO NOT ABORT WHEN THERE
C                           ARE TOO MANY SUBSETS COMING IN (I.E., .GT.
C                           I2), BUT RATHER JUST PROCESS I2 REPORTS AND
C                           PRINT A DIAGNOSTIC
C 2002-05-14  J. WOOLLEN -- REMOVED OLD CRAY COMPILER DIRECTIVES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- PARAMETER MAXMSG (THE MAXIMUM NUMBER OF
C                           BUFR MESSAGES WHICH CAN BE STORED
C                           INTERNALLY) INCREASED FROM 50000 TO 200000;
C                           MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY); OUTPUTS MORE COMPLETE DIAGNOSTIC
C                           INFO WHEN ROUTINE TERMINATES ABNORMALLY
C
C USAGE:    CALL UFBTAM (TAB, I1, I2, IRET, STR)
C   INPUT ARGUMENT LIST:
C     I1       - INTEGER: LENGTH OF FIRST DIMENSION OF TAB OR THE
C                NUMBER OF BLANK-SEPARATED MNEMONICS IN STR (FORMER
C                MUST BE .GE. LATTER)
C     I2       - INTEGER: LENGTH OF SECOND DIMENSION OF TAB
C     STR      - CHARACTER*(*): STRING OF BLANK-SEPARATED TABLE B
C                MNEMONICS IN ONE-TO-ONE CORRESPONDENCE WITH FIRST
C                DIMENSION OF TAB
C
C   OUTPUT ARGUMENT LIST:
C     TAB      - REAL*8: (I1,I2) STARTING ADDRESS OF DATA VALUES READ
C                FROM BUFR FILE
C     IRET     - INTEGER: NUMBER OF DATA SUBSETS IN BUFR FILE (MUST BE
C                NO LARGER THAN I2)
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    NOTE THAT UFBMEM IS CALLED PRIOR TO THIS TO STORE THE BUFR
C    MESSAGES INTO INTERNAL MEMORY.
C
C    THIS ROUTINE CALLS:        BORT     NMSUB    PARSEQ   RDMEMM
C                               STATUS   STRING   UPB      UPBB
C                               UPC      USRTPL
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXMSG=200000,MAXMEM=16000000)
      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /MSGMEM/ MUNIT,MLAST,MSGP(0:MAXMSG),MSGS(MAXMEM)
      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /USRSTR/ NNOD,NCON,NODS(20),NODC(10),VALS(10),KONS(10)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)
      COMMON /QUIET / IPRT

      CHARACTER*(*) STR
      CHARACTER*128 BORT_STR
      CHARACTER*10  TAG,TGS(100)
      CHARACTER*8   SUBSET,CVAL
      CHARACTER*3   TYP
      EQUIVALENCE   (CVAL,RVAL)
      REAL*8        TAB(I1,I2),VAL,RVAL,BMISS,UPS,TEN

      DATA BMISS /10E10/
      DATA MAXTG /100/
      DATA TEN   /10/

C-----------------------------------------------------------------------
      MPS(NODE) = 2**(IBT(NODE))-1
      UPS(NODE) = (IVAL+IRF(NODE))*TEN**(-ISC(NODE))
C-----------------------------------------------------------------------

      IRET = 0

      IF(MSGP(0).EQ.0) GOTO 100

      DO J=1,I2
      DO I=1,I1
      TAB(I,J) = BMISS
      ENDDO
      ENDDO

C  CHECK FOR SPECIAL TAGS IN STRING
C  --------------------------------

      CALL PARSEQ(STR,TGS,MAXTG,NTG)
      IREC = 0
      ISUB = 0
      DO I=1,NTG
      IF(TGS(I).EQ.'IREC') IREC = I
      IF(TGS(I).EQ.'ISUB') ISUB = I
      ENDDO

C  READ A MESSAGE AND PARSE A STRING
C  ---------------------------------

      CALL STATUS(MUNIT,LUN,IL,IM)

      DO IMSG=1,MSGP(0)
      CALL RDMEMM(IMSG,SUBSET,JDATE,MRET)
      IF(MRET.NE.0) GOTO 900

      CALL STRING(STR,LUN,I1,0)
      IF(IREC.GT.0) NODS(IREC) = 0
      IF(ISUB.GT.0) NODS(ISUB) = 0

C  PROCESS ALL THE SUBSETS IN THE MEMORY MESSAGE
C  ---------------------------------------------

      DO WHILE (NSUB(LUN).LT.MSUB(LUN))
         IF(IRET+1.GT.I2) GOTO 99
         IRET = IRET+1

         DO I=1,NNOD
         NODS(I) = ABS(NODS(I))
         ENDDO

         CALL USRTPL(LUN,1,1)
         MBIT = MBYT(LUN)*8+16
         NBIT = 0
         N = 1

20       IF(N+1.LE.NVAL(LUN)) THEN
            N = N+1
            NODE = INV(N,LUN)
            MBIT = MBIT+NBIT
            NBIT = IBT(NODE)
            IF(ITP(NODE).EQ.1) THEN
               CALL UPBB(IVAL,NBIT,MBIT,MBAY(1,LUN))
               CALL USRTPL(LUN,N,IVAL)
            ENDIF
            DO I=1,NNOD
            IF(NODS(I).EQ.NODE) THEN
               IF(ITP(NODE).EQ.1) THEN
                  CALL UPBB(IVAL,NBIT,MBIT,MBAY(1,LUN))
                  TAB(I,IRET) = IVAL
               ELSEIF(ITP(NODE).EQ.2) THEN
                  CALL UPBB(IVAL,NBIT,MBIT,MBAY(1,LUN))
                  IF(IVAL.LT.MPS(NODE)) TAB(I,IRET) = UPS(NODE)
               ELSEIF(ITP(NODE).EQ.3) THEN
                  CVAL = ' '
                  KBIT = MBIT
                  CALL UPC(CVAL,NBIT/8,MBAY(1,LUN),KBIT)
                  TAB(I,IRET) = RVAL
               ENDIF
               NODS(I) = -NODS(I)
               GOTO 20
            ENDIF
            ENDDO
            DO I=1,NNOD
            IF(NODS(I).GT.0) GOTO 20
            ENDDO
         ENDIF

C  UPDATE THE SUBSET POINTERS BEFORE NEXT READ
C  -------------------------------------------

         IBIT = MBYT(LUN)*8
         CALL UPB(NBYT,16,MBAY(1,LUN),IBIT)
         MBYT(LUN) = MBYT(LUN) + NBYT
         NSUB(LUN) = NSUB(LUN) + 1
         IF(IREC.GT.0) TAB(IREC,IRET) = NMSG(LUN)
         IF(ISUB.GT.0) TAB(ISUB,IRET) = NSUB(LUN)
      ENDDO

      ENDDO

      GOTO 200

C  EMERGENCY ROOM TREATMENT FOR ARRAY OVERFLOW
C  -------------------------------------------

99    CALL RDMEMM(0,SUBSET,JDATE,MRET)
      NREP = 0
      DO IMSG=1,MSGP(0)
      CALL RDMEMM(IMSG,SUBSET,JDATE,MRET)
      IF(MRET.NE.0) GOTO 900
      NREP = NREP+NMSUB(MUNIT)
      ENDDO
      IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*,'BUFRLIB: UFBTAM - THE NO. OF DATA SUBSETS IN MEMORY IS ',
     . '.GT. LIMIT OF ',I2,' IN THE 3-RD ARG. (INPUT) - INCOMPLETE READ'
      PRINT*,'>>>UFBTAM STORED ',IRET,' REPORTS OUT OF ',NREP,'<<<'
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
      ENDIF

C  RESET THE MEMORY FILE
C  ---------------------

200   CALL RDMEMM(0,SUBSET,JDATE,MRET)

C  EXITS
C  -----

100   RETURN
900   WRITE(BORT_STR,'("BUFRLIB: UFBTAM - HIT END-OF-FILE READING '//
     . 'MESSAGE NUMBER",I5," IN INTERNAL MEMORY")') IMSG
      CALL BORT(BORT_STR)
      END
      SUBROUTINE UFDUMP(LUNIT,LUPRT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UFDUMP
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2002-05-14
C
C ABSTRACT: THIS SUBROUTINE DUMPS A DETAILED PRINT LISTING OF THE
C   CONTENTS OF THE UNPACKED DATA SUBSET CURRENTLY RESIDING IN THE
C   INTERNAL SUBSET ARRAYS ASSOCIATED WITH A BUFR FILE IN LOGICAL UNIT
C   LUNIT OPENED FOR INPUT VIA A PREVIOUS CALL TO BUFR ARCHIVE LIBRARY
C   SUBROUTINE OPENBF.  THE DATA SUBSET MUST HAVE SUBSEQUENTLY BEEN
C   READ INTO THE INTERNAL BUFR ARCHIVE LIBRARY ARRAYS VIA CALLS TO
C   BUFR ARCHIVE LIBRARY SUBROUTINE READMG OR READERME FOLLOWED BY A
C   CALL TO BUFR ARCHIVE LIBRARY SUBROUTINE READSB OR READERS (OR VIA A
C   SINGLE CALL TO BUFR ARCHIVE LIBRARY SUBROUTINE READNS).  FOR A
C   PARTICULAR SUBSET, THIS LISTING CONTAINS EACH MNEMONIC ACCOMPANIED
C   BY ITS CORRESPONDING DATA VALUE AND OTHER POTENTIALLY USEFUL
C   INFORMATION SUCH AS WHICH OTHER MNEMONIC(S) THAT MNEMONIC WAS A
C   CONSTITUENT OF WITHIN THE OVERALL DATA SUBSET.  IT IS SIMILAR TO
C   BUFR ARCHIVE LIBRARY SUBROUTINE UFBDMP EXCEPT IT DOES NOT PRINT
C   POINTERS, COUNTERS AND OTHER, MORE ESOTERIC INFORMATION DESCRIBING
C   THE INTERNAL SUBSET STRUCTURES.  IN ADDITION, UFBDMP HAS THE
C   ABILITY TO SCROLL THROUGH A SUBSET, TWENTY ELEMENTS AT A TIME.
C   UFDUMP DOES NOT HAVE THIS CAPABILITY.  EACH SUBROUTINE, UFBDMP AND
C   UFDUMP, IS USEFUL FOR DIFFERENT DIAGNOSTIC PURPOSES, BUT IN GENERAL
C   UFDUMP IS MORE USEFUL FOR JUST LOOKING AT THE DATA ELEMENTS.
C
C PROGRAM HISTORY LOG:
C 2002-05-14  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  J. WOOLLEN -- MODIFIED TO HANDLE PRINT OF CHARACTER
C                           VALUES GREATER THAN EIGHT BYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY); OUTPUTS MORE COMPLETE DIAGNOSTIC
C                           INFO WHEN ROUTINE TERMINATES ABNORMALLY
C
C USAGE:    CALL UFDUMP (LUNIT, LUPRT)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     LUPRT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR PRINT OUTPUT
C                FILE
C                       0 = LUPRT is set to 06
C
C   OUTPUT FILES:
C     IF LUPRT > 0: UNIT "LUPRT" - PRINT (IF LUPRT=6, STANDARD OUTPUT)
C     IF LUPRT = 0: UNIT 06      - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     NEMTAB   READLC   RJUST
C                               STATUS
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)
      PARAMETER (MAXTBA=50)
      PARAMETER (MAXTBB=250)
      PARAMETER (MAXTBD=250)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /TABABD/ NTBA(0:NFILES),NTBB(0:NFILES),NTBD(0:NFILES),
     .                MTAB(MAXTBA,NFILES),IDNA(MAXTBA,NFILES,2),
     .                IDNB(MAXTBB,NFILES),IDND(MAXTBD,NFILES),
     .                TABA(MAXTBA,NFILES),TABB(MAXTBB,NFILES),
     .                TABD(MAXTBD,NFILES)

      CHARACTER*600 TABD
      CHARACTER*128 TABB
      CHARACTER*128 TABA

      CHARACTER*80 FMT
      CHARACTER*64 DESC
      CHARACTER*24 UNIT
      CHARACTER*20 LCHR
      CHARACTER*10 TAG,NEMO
      CHARACTER*6  NUMB
      CHARACTER*8  CVAL,PMISS
      CHARACTER*3  TYP
      CHARACTER*1  TAB
      EQUIVALENCE  (RVAL,CVAL)
      REAL*8       VAL,RVAL,BMISS

      DATA BMISS /   10E10  /
      DATA PMISS /' MISSING'/

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      IF(LUPRT.EQ.0) LUOUT = 6
      IF(LUPRT.NE.0) LUOUT = LUPRT

C  CHECK THE FILE STATUS AND I-NODE
C  --------------------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.GT.0) GOTO 901
      IF(IM.EQ.0) GOTO 902
      IF(INODE(LUN).NE.INV(1,LUN)) GOTO 903

      WRITE(LUOUT,*)
      WRITE(LUOUT,*) 'MESSAGE TYPE ',TAG(INODE(LUN))
      WRITE(LUOUT,*)

C  DUMP THE CONTENTS OF COMMON /USRINT/ FOR UNIT LUNIT
C  ---------------------------------------------------

      DO NV=1,NVAL(LUN)
      NODE = INV (NV,LUN)
      NEMO = TAG (NODE)
      ITYP = ITP (NODE)
      IF(ITYP.GE.1.AND.ITYP.LE.3) THEN
         CALL NEMTAB(LUN,NEMO,IDN,TAB,N)
         NUMB = TABB(N,LUN)(1:6)
         DESC = TABB(N,LUN)(16:70)
         UNIT = TABB(N,LUN)(71:94)
         RVAL = VAL(NV,LUN)
      ENDIF
      IF(ITYP.EQ.1.OR.ITYP.EQ.2) THEN
         IF(RVAL.LT.BMISS) THEN
            FMT = '(A6,2X,A10,2X,F20.00,2X,A24,6X,A55)'
            WRITE(FMT(19:20),'(I2)') MAX(1,ISC(NODE))
            WRITE(LUOUT,FMT) NUMB,NEMO,RVAL,UNIT,DESC
         ELSE
            FMT = '(A6,2X,A10,2X,A20,2X,A24,6X,A55)'
            WRITE(LUOUT,FMT) NUMB,NEMO,PMISS,UNIT,DESC
         ENDIF
      ELSEIF(ITYP.EQ.3) THEN
         NCHR = IBT(NODE)/8
         IF(NCHR.GT.8.AND.IL.LT.0) THEN
            CALL READLC(LUNIT,LCHR,NEMO)
         ELSE
            LCHR = CVAL
         ENDIF
         IF(RVAL.EQ.BMISS) LCHR = PMISS
         IRET = RJUST(LCHR)
         FMT = '(A6,2X,A10,2X,A20,2X,"(",I2,")",A24,2X,A55)'
         WRITE(LUOUT,FMT) NUMB,NEMO,LCHR,NCHR,UNIT,DESC
      ENDIF
      ENDDO

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: UFDUMP - INPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR INPUT')
901   CALL BORT('BUFRLIB: UFDUMP - INPUT BUFR FILE IS OPEN FOR '//
     . 'OUTPUT, IT MUST BE OPEN FOR INPUT')
902   CALL BORT('BUFRLIB: UFDUMP - A MESSAGE MUST BE OPEN IN INPUT '//
     . 'BUFR FILE, NONE ARE')
903   CALL BORT('BUFRLIB: UFDUMP - LOCATION OF INTERNAL TABLE FOR '//
     . 'INPUT BUFR FILE DOES NOT AGREE WITH EXPECTED LOCATION IN '//
     . 'INTERNAL SUBSET ARRAY')
      END
      SUBROUTINE UPB(NVAL,NBITS,IBAY,IBIT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UPB
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE UNPACKS AND RETURNS A BINARY INTEGER
C   CONTAINED WITHIN NBITS BITS OF IBAY, STARTING WITH BIT (IBIT+1).
C   ON OUTPUT, IBIT IS UPDATED TO POINT TO THE LAST BIT THAT WAS
C   UNPACKED.  THIS IS SIMILAR TO BUFR ARCHIVE LIBRARY SUBROUTINE UPBB,
C   EXCEPT IN UPBB IBIT IS NOT UPDATED UPON OUTPUT (AND THE ORDER OF
C   ARGUMENTS IS DIFFERENT).
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-05-19  J. ATOR    -- ADDED CHECK FOR NBITS EQUAL TO ZERO
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  J. WOOLLEN -- BIG-ENDIAN/LITTLE-ENDIAN INDEPENDENT (WAS
C                           IN DECODER VERSION)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION
C
C USAGE:    CALL UPB (NVAL, NBITS, IBAY, IBIT)
C   INPUT ARGUMENT LIST:
C     NBITS    - INTEGER: NUMBER OF BITS OF IBAY WITHIN WHICH TO UNPACK
C                NVAL
C     IBAY     - INTEGER: *-WORD PACKED BINARY ARRAY CONTAINING PACKED
C                NVAL
C     IBIT     - INTEGER: BIT POINTER WITHIN IBAY TO START UNPACKING
C                FROM
C
C   OUTPUT ARGUMENT LIST:
C     NVAL     - INTEGER: UNPACKED INTEGER
C     IBIT     - INTEGER: BIT POINTER WITHIN IBAY INDICATING LAST BIT
C                THAT WAS UNPACKED
C
C REMARKS:
C    THIS SUBROUTINE IS THE INVERSE OF BUFR ARCHIVE LIBRARY ROUTINE
C    PKB.
C
C    THIS ROUTINE CALLS:        IREV
C    THIS ROUTINE IS CALLED BY: COPYSB   IUPB     MVB      RDCMPS
C                               RDMGSB   READ2C   READSB   STANDARD
C                               UFBINX   UFBTAB   UFBTAM   UPC
C                               WRCMPS   WRITLC
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)

      DIMENSION IBAY(*)

C----------------------------------------------------------------------
C----------------------------------------------------------------------

C  IF NBITS=0, THEN JUST SET NVAL=0 AND RETURN
C  -------------------------------------------

      IF(NBITS.EQ.0)THEN
        NVAL=0
        GOTO 100
      ENDIF

      NWD = IBIT/NBITW + 1
      NBT = MOD(IBIT,NBITW)
      INT = ISHFT(IREV(IBAY(NWD)),NBT)
c  .... big-endian only form commented out
ccccc INT = ISHFT(IBAY(NWD),NBT)
      INT = ISHFT(INT,NBITS-NBITW)
      LBT = NBT+NBITS
      IF(LBT.GT.NBITW) THEN
         JNT = IREV(IBAY(NWD+1))
c  .... big-endian only form commented out
ccccc    JNT = IBAY(NWD+1)
         INT = IOR(INT,ISHFT(JNT,LBT-2*NBITW))
      ENDIF
      IBIT = IBIT+NBITS
      NVAL = INT

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE UPBB(NVAL,NBITS,IBIT,IBAY)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UPBB
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE UNPACKS AND RETURNS A BINARY INTEGER
C   CONTAINED WITHIN NBITS BITS OF IBAY, STARTING WITH BIT (IBIT+1).
C   THIS IS SIMILAR TO BUFR ARCHIVE LIBRARY SUBROUTINE UPB, EXCEPT IN
C   UPBB IBIT IS NOT UPDATED UPON OUTPUT (AND THE ORDER OF ARGUMENTS IS
C   DIFFERENT).
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-10-27  J. WOOLLEN -- MODIFIED TO CORRECT PROBLEMS CAUSED BY IN-
C                           LINING CODE WITH FPP DIRECTIVES
C 2003-11-04  J. WOOLLEN -- BIG-ENDIAN/LITTLE-ENDIAN INDEPENDENT (WAS
C                           IN DECODER VERSION)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- ADDED CHECK FOR NBITS EQUAL TO ZERO;
C                           MODIFIED LOGIC TO MAKE IT CONSISTENT WITH
C                           LOGIC IN UPB; UNIFIED/PORTABLE FOR WRF;
C                           ADDED DOCUMENTATION (INCLUDING HISTORY)
C
C USAGE:    CALL UPBB (NVAL, NBITS, IBIT, IBAY)
C   INPUT ARGUMENT LIST:
C     NBITS    - INTEGER: NUMBER OF BITS OF IBAY WITHIN WHICH TO UNPACK
C                NVAL
C     IBIT     - INTEGER: BIT POINTER WITHIN IBAY TO START UNPACKING
C                FROM
C     IBAY     - INTEGER: *-WORD PACKED BINARY ARRAY CONTAINING PACKED
C                NVAL
C
C   OUTPUT ARGUMENT LIST:
C     NVAL     - INTEGER: UNPACKED INTEGER
C
C REMARKS:
C    THIS ROUTINE CALLS:        IREV
C    THIS ROUTINE IS CALLED BY: RCSTPL   RDTREE   UFBGET   UFBTAB
C                               UFBTAM   WRITLC
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)

      DIMENSION IBAY(*)

C----------------------------------------------------------------------
C----------------------------------------------------------------------

C  IF NBITS=0, THEN JUST SET NVAL=0 AND RETURN
C  -------------------------------------------

      IF(NBITS.EQ.0)THEN
        NVAL=0
        GOTO 100
      ENDIF

      NWD = IBIT/NBITW + 1
      NBT = MOD(IBIT,NBITW)
      INT = ISHFT(IREV(IBAY(NWD)),NBT)
c  .... big-endian only form commented out
ccccc INT = ISHFT(IBAY(NWD),NBT)
      INT = ISHFT(INT,NBITS-NBITW)
      LBT = NBT+NBITS
      IF(LBT.GT.NBITW) THEN
         JNT = IREV(IBAY(NWD+1))
c  .... big-endian only form commented out
ccccc    JNT = IBAY(NWD+1)
         INT = IOR(INT,ISHFT(JNT,LBT-2*NBITW))
      ENDIF
      NVAL = INT

C  EXIT
C  ----

100   RETURN
      END
      SUBROUTINE UPC(CHR,NCHR,IBAY,IBIT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UPC
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE UNPACKS AND RETURNS A CHARACTER STRING OF
C   LENGTH NCHR CONTAINED WITHIN NCHR BYTES OF IBAY, STARTING WITH BIT
C   (IBIT+1).  ON OUTPUT, IBIT IS UPDATED TO POINT TO THE LAST BIT THAT
C   WAS UNPACKED.  NOTE THAT THE STRING TO BE UNPACKED DOES NOT
C   NECESSARILY NEED TO BE ALIGNED ON A BYTE BOUNDARY WITHIN IBAY.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION
C
C USAGE:    CALL UPC (CHR, NCHR, IBAY, IBIT)
C   INPUT ARGUMENT LIST:
C     NCHR     - INTEGER: NUMBER OF BYTES OF IBAY WITHIN WHICH TO
C                UNPACK CHR (I,E, THE NUMBER OF CHARACTERS IN CHR)
C     IBAY     - INTEGER: *-WORD PACKED BINARY ARRAY CONTAINING PACKED
C                CHR
C     IBIT     - INTEGER: BIT POINTER WITHIN IBAY TO START UNPACKING
C                FROM
C
C   OUTPUT ARGUMENT LIST:
C     CHR      - CHARACTER*(*): UNPACKED CHARACTER STRING OF LENGTH
C                NCHR
C     IBIT     - INTEGER: BIT POINTER WITHIN IBAY INDICATING LAST BIT
C                THAT WAS UNPACKED
C
C REMARKS:
C    THIS SUBROUTINE IS THE INVERSE OF BUFR ARCHIVE LIBRARY ROUTINE
C    PKC.
C
C    THIS ROUTINE CALLS:        IPKM     IUPM     UPB
C    THIS ROUTINE IS CALLED BY: OPENBF   RDCMPS   RDTREE   READ2C
C                               READLC   STANDARD UFBGET   UFBTAB
C                               UFBTAM   WRCMPS
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /CHARAC/ IASCII,IATOE(0:255),IETOA(0:255)
      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)

      CHARACTER*(*) CHR
      CHARACTER*8   CVAL
      DIMENSION     IBAY(*),IVAL(2)
      EQUIVALENCE   (CVAL,IVAL)

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      LB = IORD(NBYTW)
      DO I=1,NCHR
      CALL UPB(IVAL(1),8,IBAY,IBIT)
      CHR(I:I) = CVAL(LB:LB)
      IF(IASCII.EQ.0) CALL IPKM(CHR(I:I),1,IATOE(IUPM(CHR(I:I),8)))
      ENDDO

      RETURN
      END
      SUBROUTINE UPDS3(MBAY,CDS3,NDS3)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UPDS3
C   PRGMMR: ATOR             ORG: NP12       DATE: 2003-11-04
C
C ABSTRACT: THIS SUBROUTINE UNPACKS AND RETURNS THE DESCRIPTORS
C   CONTAINED WITHIN SECTION 3 OF A BUFR MESSAGE STORED IN ARRAY MBAY.
C   THE START OF THE BUFR MESSAGE (I.E., THE STRING "BUFR") MUST BE
C   ALIGNED ON THE FIRST FOUR BYTES OF MBAY.  NOTE ALSO THAT THIS
C   SUBROUTINE DOES NOT RECURSIVELY RESOLVE SEQUENCE DESCRIPTORS THAT
C   APPEAR WITHIN SECTION 3; RATHER, WHAT IS RETURNED IS THE EXACT LIST
C   OF DESCRIPTORS AS IT APPEARS WITHIN SECTION 3.
C
C PROGRAM HISTORY LOG:
C 2003-11-04  J. ATOR    -- ORIGINAL AUTHOR (WAS IN DECODER VERSION)
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF
C
C USAGE:    CALL UPDS3 (MBAY, CDS3, NDS3)
C   INPUT ARGUMENT LIST:
C     MBAY     - INTEGER: *-WORD PACKED BINARY ARRAY CONTAINING BUFR
C                MESSAGE
C
C   OUTPUT ARGUMENT LIST:
C     CDS3     - CHARACTER*6: *-WORD ARRAY CONTAINING UNPACKED LIST OF
C                DESCRIPTORS (FIRST NDS3 WORDS FILLED)
C     NDS3     - INTEGER: NUMBER OF DESCRIPTORS RETURNED
C
C REMARKS:
C    THIS ROUTINE CALLS:        ADN30    IUPB     WRDLEN
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      DIMENSION MBAY(*)

      CHARACTER*6 CDS3(*), ADN30

      DATA IFIRST / 0 /

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C     If this is the first call to this subroutine, then call subroutine
C     WRDLEN to initialize some important information about the local
C     machine, just in case subroutine OPENBF hasn't been called yet.

      IF ( IFIRST .EQ. 0 ) THEN
         CALL WRDLEN
         IFIRST = 1
      ENDIF

C     Skip Section 0.
C     ---------------

      IPT = 8

C     Skip Section 1, but check for existence of Section 2.
C     -----------------------------------------------------

      ISC2 = IUPB ( MBAY, IPT + 8,  1 )

      IPT = IPT + IUPB ( MBAY, IPT + 1, 24 )

C     Skip Section 2 if it exists.
C     ----------------------------

      IPT = IPT + ( IUPB ( MBAY, IPT + 1, 24 ) * ISC2 )

C     Get the length of Section 3.
C     ----------------------------

      LEN3 = IUPB ( MBAY, IPT + 1 , 24 )

C     Unpack the Section 3 descriptors.
C     ---------------------------------

      NDS3 = 0
      DO JJ = 8, ( LEN3 - 1 ), 2
         NDS3 = NDS3 + 1
         CDS3 (NDS3) = ADN30 ( IUPB ( MBAY, IPT + JJ, 16 ), 6 )
      ENDDO

      RETURN
      END
      SUBROUTINE UPTDD(ID,LUN,IENT,IRET)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    UPTDD
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE RETURNS THE BIT-WISE REPRESENTATION OF THE
C   FXY VALUE CORRESPONDING TO, SEQUENTIALLY, A PARTICULAR (IENT'th)
C   "CHILD" MNEMONIC OF A TABLE D SEQUENCE ("PARENT") MNEMONIC.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1995-06-28  J. WOOLLEN -- INCREASED THE SIZE OF INTERNAL BUFR TABLE
C                           ARRAYS IN ORDER TO HANDLE BIGGER FILES
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL UPTDD (ID, LUN, IENT, IRET)
C   INPUT ARGUMENT LIST:
C     ID       - INTEGER: POSITIONAL INDEX OF PARENT MNEMONIC WITHIN
C                INTERNAL BUFR TABLE D ARRAY TABD
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     IENT     - INTEGER: ORDINAL INDICATOR OF CHILD MNEMONIC TO RETURN
C                FROM WITHIN TABD(ID,LUN) SEQUENCE:
C                       0 = return a count of the total number of child
C                           mnemonics within TABD(ID,LUN)
C
C   OUTPUT ARGUMENT LIST:
C     IRET     - INTEGER: RETURN VALUE (SEE REMARKS)
C
C REMARKS:
C    THE INTERPRETATION OF THE RETURN VALUE IRET DEPENDS UPON THE INPUT
C    VALUE IENT, AS FOLLOWS:
C
C    IF ( IENT = 0 ) THEN
C       IRET = a count of the total number of child mnemonics within
C              TABD(ID,LUN)
C    ELSE
C       IRET = the bit-wise representation of the FXY value
C              corresponding to the IENT'th child mnemonic of
C              TABD(ID,LUN)
C    END IF
C
C
C    THIS ROUTINE CALLS:        BORT     IUPM
C    THIS ROUTINE IS CALLED BY: NEMTBD   STANDARD XMSGINI
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MAXTBA=50)
      PARAMETER (MAXTBB=250)
      PARAMETER (MAXTBD=250)

      COMMON /TABABD/ NTBA(0:NFILES),NTBB(0:NFILES),NTBD(0:NFILES),
     .                MTAB(MAXTBA,NFILES),IDNA(MAXTBA,NFILES,2),
     .                IDNB(MAXTBB,NFILES),IDND(MAXTBD,NFILES),
     .                TABA(MAXTBA,NFILES),TABB(MAXTBB,NFILES),
     .                TABD(MAXTBD,NFILES)
      COMMON /DXTAB / MAXDX,IDXV,NXSTR(10),LDXA(10),LDXB(10),LDXD(10),
     .                LD30(10),DXSTR(10)

      CHARACTER*600 TABD
      CHARACTER*128 BORT_STR
      CHARACTER*128 TABB
      CHARACTER*128 TABA
      CHARACTER*56  DXSTR

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      LDD = LDXD(IDXV+1)+1

C  CHECK IF IENT IS IN BOUNDS
C  --------------------------

      NDSC = IUPM(TABD(ID,LUN)(LDD:LDD),8)

      IF(IENT.EQ.0) THEN
         IRET = NDSC
         GOTO 100
      ELSEIF(IENT.LT.0 .OR. IENT.GT.NDSC) THEN
         GOTO 900
      ENDIF

C  RETURN THE DESCRIPTOR INDICATED BY IENT
C  ---------------------------------------

      IDSC = LDD+1 + (IENT-1)*2
      IRET = IUPM(TABD(ID,LUN)(IDSC:IDSC),16)

C  EXITS
C  -----

100   RETURN
900   WRITE(BORT_STR,'("BUFRLIB: UPTDD - VALUE OF THIRD ARGUMENT IENT'//
     . ' (INPUT) IS OUT OF RANGE (IENT =",I4,")")') IENT
      CALL BORT(BORT_STR)
      END
      SUBROUTINE USRTPL(LUN,INVN,NBMP)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    USRTPL (docblock incomplete)
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE STORES THE SUBSET TEMPLATE INTO INTERNAL
C   SUBSET ARRAYS IN COMMON BLOCK /USRINT/ FOR CASES OF NODE EXPANSION
C   (I.E., NODE IS EITHER A TABLE A MNEMONIC OR A DELAYED REPLICATION
C   FACTOR).
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2002-05-14  J. WOOLLEN -- REMOVED OLD CRAY COMPILER DIRECTIVES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY) (INCOMPLETE); OUTPUTS MORE
C                           COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY OR UNUSUAL THINGS
C                           HAPPEN; COMMENTED OUT HARDWIRE OF VTMP TO
C                           "BMISS" (10E10) WHEN IT IS > 10E9 (CAUSED
C                           PROBLEMS ON SOME FOREIGN MACHINES)
C
C USAGE:    CALL USRTPL (LUN, INVN, NBMP)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     INVN     - INTEGER: INVENTORY INDEX FOR ELEMENTS
C     NBMP     - INTEGER  ....
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT
C    THIS ROUTINE IS CALLED BY: CONWIN   DRFINI   DRSTPL   MSGUPD
C                               OPENMB   OPENMG   RDCMPS   SUBUPD
C                               TRYBUMP  UFBGET   UFBTAB   UFBTAM
C                               WRCMPS   WRITLC
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)

      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /QUIET / IPRT

      CHARACTER*128 BORT_STR
      CHARACTER*10  TAG
      CHARACTER*3   TYP
      DIMENSION     ITMP(MAXJL)
      LOGICAL       DRP,DRS,DRB,DRX
      REAL*8        VAL,VTMP(MAXJL)
ccccccREAL*8        BMISS

ccccccDATA BMISS /10E10/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      IF(IPRT.GE.2)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
         PRINT*,'BUFRLIB: USRTPL - LUN:INVN:NBMP:TAG(INODE(LUN)) = ',
     .    LUN,':',INVN,':',NBMP,':',TAG(INODE(LUN))
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT*
      ENDIF

      IF(NBMP.LE.0) THEN
         IF(IPRT.GE.1)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
            PRINT*,'BUFRLIB: USRTPL - NBMP .LE. 0 - IMMEDIATE RETURN'
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
         ENDIF
         GOTO 100
      ENDIF

      DRP = .FALSE.
      DRS = .FALSE.
      DRX = .FALSE.

C  SET UP A NODE EXPANSION
C  -----------------------

      IF(INVN.EQ.1) THEN
c  .... case where node is a Table A mnemonic (nodi is positional index)
         NODI = INODE(LUN)
         INV(1,LUN) = NODI
         NVAL(LUN)  = 1
         IF(NBMP.NE.1) GOTO 900
      ELSEIF(INVN.GT.0 .AND. INVN.LE.NVAL(LUN)) THEN
c  .... case where node is (hopefully) a delayed replication factor
         NODI = INV(INVN,LUN)
         DRP  = TYP(NODI) .EQ. 'DRP'
         DRS  = TYP(NODI) .EQ. 'DRS'
         DRB  = TYP(NODI) .EQ. 'DRB'
         DRX  = DRP .OR. DRS .OR. DRB
         IVAL = VAL(INVN,LUN)
         JVAL = 2**IBT(NODI)-1
         VAL(INVN,LUN) = IVAL+NBMP
         IF(DRB.AND.NBMP.NE.1) GOTO 901
         IF(.NOT.DRX         ) GOTO 902
         IF(IVAL.LT.0.       ) GOTO 903
         IF(IVAL+NBMP.GT.JVAL) GOTO 904
      ELSE
         GOTO 905
      ENDIF

C  RECALL A PRE-FAB NODE EXPANSION SEGMENT
C  ---------------------------------------

      NEWN = 0
      N1 = ISEQ(NODI,1)
      N2 = ISEQ(NODI,2)

      IF(N1.EQ.0          ) GOTO 906
      IF(N2-N1+1.GT.MAXJL)  GOTO 907

      DO N=N1,N2
      NEWN = NEWN+1
      ITMP(NEWN) = JSEQ(N)
      VTMP(NEWN) = VALI(JSEQ(N))
ccccccIF(VTMP(NEWN).GT.10E9) VTMP(NEWN) = BMISS
      ENDDO

C  MOVE OLD NODES - STORE NEW ONES
C  -------------------------------

      IF(NVAL(LUN)+NEWN*NBMP.GT.MAXJL) GOTO 908

      DO J=NVAL(LUN),INVN+1,-1
      INV(J+NEWN*NBMP,LUN) = INV(J,LUN)
      VAL(J+NEWN*NBMP,LUN) = VAL(J,LUN)
      ENDDO

      IF(DRP.OR.DRS) VTMP(1) = NEWN
      KNVN = INVN

      DO I=1,NBMP
      DO J=1,NEWN
      KNVN = KNVN+1
      INV(KNVN,LUN) = ITMP(J)
      VAL(KNVN,LUN) = VTMP(J)
      ENDDO
      ENDDO

C  RESET POINTERS AND COUNTERS
C  ---------------------------

      NVAL(LUN) = NVAL(LUN) + NEWN*NBMP

      IF(IPRT.GE.2)  THEN
      PRINT*
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
         PRINT*,'BUFRLIB: USRTPL - TAG(INV(INVN,LUN)):NEWN:NBMP:',
     .    'NVAL(LUN) = ',TAG(INV(INVN,LUN)),':',NEWN,':',NBMP,':',
     .    NVAL(LUN)
         DO I=1,NEWN
            PRINT*,'For I = ',I,', ITMP(I) = ',ITMP(I),
     .       ', TAG(ITMP(I)) = ',TAG(ITMP(I))
         ENDDO
      PRINT*,'+++++++++++++++++BUFR ARCHIVE LIBRARY++++++++++++++++++++'
      PRINT*
      ENDIF

      IF(DRX) THEN
         NODE = NODI
         INVR = INVN
4        NODE = JMPB(NODE)
         IF(NODE.GT.0) THEN
            IF(ITP(NODE).EQ.0) THEN
               DO INVR=INVR-1,1,-1
               IF(INV(INVR,LUN).EQ.NODE) THEN
                  VAL(INVR,LUN) = VAL(INVR,LUN)+NEWN*NBMP
                  GOTO 4
               ENDIF
               ENDDO
               GOTO 909
            ELSE
               GOTO 4
            ENDIF
         ENDIF
      ENDIF

C  EXITS
C  -----

100   RETURN
900   WRITE(BORT_STR,'("BUFRLIB: USRTPL - THIRD ARGUMENT (INPUT) = ",'//
     . 'I4,", MUST BE 1 WHEN SECOND ARGUMENT (INPUT) IS 1 (SUBSET '//
     . 'NODE) (",A,")")') NBMP,TAG(NODI)
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: USRTPL - THIRD ARGUMENT (INPUT) = ",'//
     . 'I4,", MUST BE 1 WHEN NODE IS DRB (1-BIT DELAYED REPL. FACTOR)'//
     . ' (",A,")")') NBMP,TAG(NODI)
      CALL BORT(BORT_STR)
902   WRITE(BORT_STR,'("BUFRLIB: USRTPL - NODE IS OF TYPE ",A," - IT '//
     . 'MUST BE EITHER A SUBSET OR DELAYED REPL. FACTOR (",A,")")')
     .  TYP(NODI),TAG(NODI)
      CALL BORT(BORT_STR)
903   WRITE(BORT_STR,'("BUFRLIB: USRTPL - REPLICATION FACTOR IS '//
     . 'NEGATIVE (=",I5,") (",A,")")') IVAL,TAG(NODI)
      CALL BORT(BORT_STR)
904   WRITE(BORT_STR,'("BUFRLIB: USRTPL - REPLICATION FACTOR OVERFLOW'//
     . ' (EXCEEDS MAXIMUM OF",I6," (",A,")")') JVAL,TAG(NODI)
      CALL BORT(BORT_STR)
905   WRITE(BORT_STR,'("BUFRLIB: USRTPL - INVENTORY INDEX {FIRST '//
     . 'ARGUMENT (INPUT)} OUT OF BOUNDS (=",I5,", RANGE IS 1 TO",I6,"'//
     . ') (",A,")")') INVN,NVAL(LUN),TAG(NODI)
      CALL BORT(BORT_STR)
906   WRITE(BORT_STR,'("BUFRLIB: USRTPL - UNSET EXPANSION SEGMENT (",'//
     . 'A,")")') TAG(NODI)
      CALL BORT(BORT_STR)
907   WRITE(BORT_STR,'("BUFRLIB: UCSTPL - TEMPLATE ARRAY OVERFLOW, '//
     . 'EXCEEDS THE LIMIT (",I6,") (",A,")")') MAXJL,TAG(NODI)
      CALL BORT(BORT_STR)
908   WRITE(BORT_STR,'("BUFRLIB: UCSTPL - INVENTORY OVERFLOW (",I6,")'//
     . ', EXCEEDS THE LIMIT (",I6,") (",A,")")')
     . NVAL(LUN)+NEWN*NBMP,MAXJL,TAG(NODI)
      CALL BORT(BORT_STR)
909   WRITE(BORT_STR,'("BUFRLIB: USRTPL - BAD BACKUP STRATEGY (",A,'//
     . '")")') TAG(NODI)
      CALL BORT(BORT_STR)
      END
      FUNCTION VALX(STR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    VALX
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS FUNCTION DECODES A REAL NUMBER FROM A CHARACTER
C   STRING.  IF THE DECODE FAILS, THEN THE VALUE BMISS (10E10) IS
C   RETURNED.  NOTE THAT, UNLIKE FOR SUBROUTINE STRNUM, THE INPUT
C   STRING MAY CONTAIN A LEADING SIGN CHARACTER (E.G. '+', '-').
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- RENAMED THIS FUNCTION FROM "VAL$" TO "VALX"
C                           TO REMOVE THE POSSIBILITY OF THE "$" SYMBOL
C                           CAUSING PROBLEMS ON OTHER PLATFORMS
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY; CHANGED CALL FROM BORT TO BORT2
C
C USAGE:    VALX (STR)
C   INPUT ARGUMENT LIST:
C     STR      - CHARACTER*(*): STRING CONTAINING ENCODED REAL VALUE
C
C   OUTPUT ARGUMENT LIST:
C     VALX     - REAL: DECODED VALUE
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT2    RJUST
C    THIS ROUTINE IS CALLED BY: NEMTBB
C                               Normally not called by any application
C                               programs but it could be.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      CHARACTER*(*) STR
      CHARACTER*128 BORT_STR1,BORT_STR2
      CHARACTER*99  BSTR
      CHARACTER*8   FMT
      REAL*8        BMISS

      COMMON /QUIET / IPRT

      DATA BMISS /10E10/

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      LENS = LEN(STR)
      IF(LENS.GT.99) GOTO 900
      BSTR(1:LENS) = STR
      RJ = RJUST(BSTR(1:LENS))
      WRITE(FMT,'(''(F'',I2,''.0)'')') LENS
      VALX = BMISS
      READ(BSTR,FMT,ERR=800) VAL
      VALX = VAL
      GOTO 100
800   IF(IPRT.GE.0) THEN
      PRINT*
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*,'BUFRLIB: VALX - ERROR READING STRING ',BSTR(1:LENS)
      PRINT*,'                RETURN WITH VALX = MISSING (10E10)'
      PRINT*,'+++++++++++++++++++++++WARNING+++++++++++++++++++++++++'
      PRINT*
      ENDIF

C  EXITS
C  -----

100   RETURN
900   WRITE(BORT_STR1,'("STRING IS: ",A)') STR
      WRITE(BORT_STR2,'("BUFRLIB: VALX - STRING LENGTH EXCEEDS LIMIT '//
     . ' OF 99 CHARACTERS")')
      CALL BORT2(BORT_STR1,BORT_STR2)
      END
      SUBROUTINE WRCMPS(LUNIX)
 
C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    WRCMPS
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2002-05-14
C
C ABSTRACT: THIS SUBROUTINE PACKS UP THE CURRENT SUBSET WITHIN MEMORY
C   (ARRAY IBAY IN COMMON BLOCK /BITBUF/), STORING IT FOR COMPRESSION.
C   IT THEN TRIES TO ADD IT TO THE COMPRESSED BUFR MESSAGE THAT IS
C   CURRENTLY OPEN WITHIN MEMORY FOR ABS(LUNIX) (ARRAY MESG).  IF THE
C   SUBSET WILL NOT FIT INTO THE CURRENTLY OPEN MESSAGE, THEN THAT
C   COMPRESSED MESSAGE IS FLUSHED TO LUNIX AND A NEW ONE IS CREATED IN
C   ORDER TO HOLD THE CURRENT SUBSET (STILL STORED FOR COMPRESSION).
C   THIS SUBROUTINE PERFORMS FUNCTIONS SIMILAR TO BUFR ARCHIVE LIBRARY
C   SUBROUTINE MSGUPD EXCEPT THAT IT ACTS ON COMPRESSED BUFR MESSAGES.
C
C PROGRAM HISTORY LOG:
C 2002-05-14  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); LOGICAL VARIABLES
C                           "WRIT1" AND "FLUSH" NOW SAVED IN GLOBAL
C                           MEMORY (IN COMMON BLOCK /COMPRS/), THIS
C                           FIXED A BUG IN THIS ROUTINE WHICH CAN LEAD
C                           TO MESSAGES BEING WRITTEN OUT BEFORE THEY
C                           ARE FULL; UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C 2003-??-??  J. ATOR    -- REMOVE CALL TO XMSGINI (CMSGINI NOW HAS
C                           SAME CAPABILITY); IMPROVE DOCUMENTATION;
C                           CORRECT LOGIC FOR WHEN A CHARACTER VALUE IS
C                           THE SAME FOR ALL SUBSETS IN A MESSAGE
C 2004-03-03  J. WOOLLEN -- 1) ADDED SAVE FOR LOGICAL 'FIRST'
C                           2) ADDED 'KMISS' TO FIX BUG WHICH WOULD
C                              OCCASIONALLY SKIP OVER SUBSETS
C                           3) ADDED LOGIC TO MAKE SURE MISSING VALUES ARE
C                              REPRESENTED BY INCREMENTS WITH ALL BITS ON
C                           4) REMOVED TWO UNECESSARY REFERENCES TO 'WRIT1'
C
C USAGE:    CALL WRCMPS (LUNIX)
C   INPUT ARGUMENT LIST:
C     LUNIX    - INTEGER: ABSOLUTE VALUE IS FORTRAN LOGICAL UNIT NUMBER
C                FOR BUFR FILE (IF LUNIX IS LESS THAN ZERO, THIS IS A
C                "FLUSH" CALL AND THE BUFFER MUST BE CLEARED OUT)
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     CMSGINI  IUPB     MSGWRT
C                               PKB      PKC      STATUS   UPB
C                               UPC      USRTPL
C    THIS ROUTINE IS CALLED BY: CLOSMG   WRITCP   WRITCA
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$
 
      PARAMETER(MROW=2000,MCOL=2000)
      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)
 
      COMMON /MAXCMP/ MAXCMB,MAXROW,MAXCOL,NCMSGS,NCSUBS,NCBYTS
      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)
      COMMON /USRBIT/ NBIT(MAXJL),MBIT(MAXJL)
      COMMON /COMPRS/ MATX(MROW,MCOL),CATX(MROW,MCOL),KMIN(MROW),
     .                KMAX(MROW),KMIS(MROW),KBIT(MROW),ITYP(MROW),
     .                IWID(MROW),NROW,NCOL,LUNC,KBYT,WRIT1,FLUSH,
     .                CSTR(MROW)
 
      CHARACTER*128 BORT_STR
      CHARACTER*10  TAG
      CHARACTER*8   CATX,SUBSET,CSTR
      CHARACTER*3   TYP
      DIMENSION     MESG(MXMSGL/4)
 
C     NOTE THE FOLLOWING FLAGS:
C         FIRST - KEEPS TRACK OF WHETHER THE CURRENT SUBSET IS THE
C                 FIRST SUBSET OF A NEW MESSAGE
C         FLUSH - KEEPS TRACK OF WHETHER THIS SUBROUTINE WAS CALLED
C                 WITH LUNIX < 0 IN ORDER TO FORCIBLY FLUSH ANY
C                 PARTIALLY-COMPLETED MESSAGE WITHIN MEMORY (PRESUMABLY
C                 IMMEDIATELY PRIOR TO EXITING THE CALLING PROGRAM!)
C         WRIT1 - KEEPS TRACK OF WHETHER THE CURRENT MESSAGE NEEDS
C                 TO BE WRITTEN OUT
                 
      LOGICAL       FIRST,FLUSH,WRIT1,KMIS,KMISS
      REAL*8        VAL
 
      DATA FIRST/.TRUE./

      SAVE FIRST
 
C-----------------------------------------------------------------------
      RLN2 = 1./LOG(2.)
C-----------------------------------------------------------------------
 
C  GET THE UNIT AND SUBSET TAG
C  ---------------------------
 
      LUNIT = ABS(LUNIX)
      CALL STATUS(LUNIT,LUN,IL,IM)
      SUBSET = TAG(INODE(LUN))
 
 
C  IF THIS IS A "FIRST" CALL, THEN INITIALIZE SOME VALUES IN
C  ORDER TO PREPARE FOR THE CREATION OF A NEW COMPRESSED BUFR
C  MESSAGE FOR OUTPUT.
 
  1   IF(FIRST) THEN
         KBYT = 0
         NCOL = 0
         LUNC = LUN
         NROW = NVAL(LUN)
         FIRST = .FALSE.
         FLUSH = .FALSE.
         WRIT1 = .FALSE.
 
C        THIS CALL TO CMSGINI IS DONE SOLELY IN ORDER TO DETERMINE
C        HOW MANY BYTES (KBYT) WILL BE TAKEN UP IN A MESSAGE BY
C        THE INFORMATION IN SECTIONS 0, 1, 2 AND 3.  THIS WILL
C        ALLOW US TO KNOW HOW MANY COMPRESSED DATA SUBSETS WILL
C        FIT INTO SECTION 4 WITHOUT OVERFLOWING MAXCMB.  LATER ON,
C        A SEPARATE CALL TO CMSGINI WILL BE DONE TO ACTUALLY
C        INITIALIZE SECTIONS 0, 1, 2 AND 3 OF THE FINAL COMPRESSED
C        BUFR MESSAGE THAT WILL BE WRITTEN OUT.
 
         CALL CMSGINI(LUN,MESG,SUBSET,IDATE(LUN),NCOL,KBYT)
      ENDIF
 
      IF(LUN.NE.LUNC) GOTO 900
 
C  IF THIS IS A "FLUSH" CALL, THEN CLEAR OUT THE BUFFER (NOTE THAT
C  THERE IS NO CURRENT SUBSET TO BE STORED!) AND PREPARE TO WRITE
C  THE FINAL COMPRESSED BUFR MESSAGE.
 
      IF(LUNIX.LT.0) THEN
         IF(NCOL.EQ.0) GOTO 100
         IF(NCOL.GT.0) THEN
            FLUSH = .TRUE.
            WRIT1 = .TRUE.
            ICOL = 1
            GOTO 20
         ENDIF
      ENDIF
 
C  CHECK ON SOME OTHER POSSIBLY PROBLEMATIC SITUATIONS
C  ---------------------------------------------------
 
      IF(NCOL+1.GT.MCOL) THEN
         GOTO 50
      ELSEIF(NVAL(LUN).NE.NROW) THEN
         GOTO 50
      ELSEIF(NVAL(LUN).GT.MROW) THEN
         GOTO 901
      ENDIF
 
C  STORE THE NEXT SUBSET FOR COMPRESSION
C  -------------------------------------
 
C     WILL THE CURRENT SUBSET FIT INTO THE CURRENT MESSAGE?
C     (UNFORTUNATELY, THE ONLY WAY TO FIND OUT IS TO ACTUALLY
C     RE-DO THE COMPRESSION BY RE-COMPUTING ALL OF THE LOCAL
C     REFERENCE VALUES, INCREMENTS, ETC.)
 
 
 10   NCOL = NCOL+1
      ICOL = NCOL
      IBIT = 16
      DO I=1,NVAL(LUN)
      NODE = INV(I,LUN)
      ITYP(I) = ITP(NODE)
      IWID(I) = IBT(NODE)
      IF(ITYP(I).EQ.1.OR.ITYP(I).EQ.2) THEN
         CALL UPB(MATX(I,NCOL),IBT(NODE),IBAY,IBIT)
      ELSEIF(ITYP(I).EQ.3) THEN
         CALL UPC(CATX(I,NCOL),IBT(NODE)/8,IBAY,IBIT)
      ENDIF
      ENDDO
 
C  COMPUTE THE MIN,MAX,WIDTH FOR EACH ROW - ACCUMULATE LENGTH
C  ----------------------------------------------------------
 
C     LDATA WILL HOLD THE LENGTH IN BITS OF THE COMPRESSED DATA
C     (I.E. THE SUM TOTAL FOR ALL DATA VALUES FOR ALL SUBSETS
C     IN THE MESSAGE)
 
 20   LDATA = 32
      IF(NCOL.LE.0) GOTO 902
      DO I=1,NROW
      IF(ITYP(I).EQ.1 .OR. ITYP(I).EQ.2) THEN
 
C        ROW I OF THE COMPRESSION MATRIX CONTAINS NUMERIC VALUES,
C        SO KMIS(I) WILL STORE:
C          .FALSE. IF ALL SUCH VALUES ARE NON-"MISSING"
C          .TRUE. OTHERWISE 
 
         IMISS = 2**IWID(I)-1
         IF(ICOL.EQ.1) THEN
            KMIN(I) = IMISS
            KMAX(I) = 0
            KMIS(I) = .FALSE.
         ENDIF
         DO J=ICOL,NCOL
         IF(MATX(I,J).LT.IMISS) THEN
            KMIN(I) = MIN(KMIN(I),MATX(I,J))
            KMAX(I) = MAX(KMAX(I),MATX(I,J))
         ELSE
            KMIS(I) = .TRUE.
         ENDIF
         ENDDO
         KMISS = KMIS(I).AND.KMIN(I).LT.IMISS
         RANGE = MAX(1,KMAX(I)-KMIN(I)+1)
         IF(ITYP(I).EQ.1.AND.RANGE.GT.1) THEN
 
C           THE DATA VALUES IN ROW I OF THE COMPRESSION MATRIX
C           ARE DELAYED DESCRIPTOR REPLICATION FACTORS AND ARE
C           NOT ALL IDENTICAL (I.E. RANGE.GT.1), SO WE CANNOT
C           COMPRESS ALL OF THESE SUBSETS INTO THE SAME MESSAGE.
C           ASSUMING THAT NONE OF THE VALUES ARE "MISSING",
C           EXCLUDE THE LAST SUBSET (I.E. THE LAST COLUMN
C           OF THE MATRIX) AND TRY RE-COMPRESSING AGAIN.
 
            IF(KMISS) GOTO 903
            WRIT1 = .TRUE.
            NCOL = NCOL-1
            ICOL = 1
            GOTO 20
         ELSEIF(ITYP(I).EQ.2.AND.(RANGE.GT.1..OR.KMISS)) THEN
 
C           THE DATA VALUES IN ROW I OF THE COMPRESSION MATRIX
C           ARE NUMERIC VALUES THAT ARE NOT ALL IDENTICAL.
C           COMPUTE THE NUMBER OF BITS NEEDED TO HOLD THE
C           LARGEST OF THE INCREMENTS.
 
            KBIT(I) = NINT(LOG(RANGE)*RLN2)
            IF(2**KBIT(I)-1.LE.RANGE) KBIT(I) = KBIT(I)+1
         ELSE
 
C           THE DATA VALUES IN ROW I OF THE COMPRESSION MATRIX
C           ARE NUMERIC VALUES THAT ARE ALL IDENTICAL, SO THE
C           INCREMENTS WILL BE OMITTED FROM THE MESSAGE.
          
            KBIT(I) = 0
         ENDIF
         LDATA = LDATA + IWID(I) + 6 + NCOL*KBIT(I)
      ELSEIF(ITYP(I).EQ.3) THEN
 
C        ROW I OF THE COMPRESSION MATRIX CONTAINS CHARACTER VALUES,
C        SO KMIS(I) WILL STORE:
C          .FALSE. IF ALL SUCH VALUES ARE IDENTICAL
C          .TRUE. OTHERWISE
 
         IF(ICOL.EQ.1) THEN
            CSTR(I) = CATX(I,1)
            KMIS(I) = .FALSE.
         ENDIF
         DO J=ICOL,NCOL
            IF ( (.NOT.KMIS(I)) .AND. (CSTR(I).NE.CATX(I,J)) ) THEN
               KMIS(I) = .TRUE.
            ENDIF
         ENDDO
         IF (KMIS(I)) THEN
 
C           THE DATA VALUES IN ROW I OF THE COMPRESSION MATRIX
C           ARE CHARACTER VALUES THAT ARE NOT ALL IDENTICAL.
 
            KBIT(I) = IWID(I)
         ELSE
 
C           THE DATA VALUES IN ROW I OF THE COMPRESSION MATRIX
C           ARE CHARACTER VALUES THAT ARE ALL IDENTICAL, SO THE
C           INCREMENTS WILL BE OMITTED FROM THE MESSAGE.
 
            KBIT(I) = 0
         ENDIF
         LDATA = LDATA + IWID(I) + 6 + NCOL*KBIT(I)
      ENDIF
      ENDDO
 
C  ROUND DATA LENGTH UP TO A WHOLE EVEN BYTE COUNT
C  -----------------------------------------------
 
      IBYT = (LDATA+8-MOD(LDATA,8))/8
      IF(MOD(IBYT,2).NE.0) IBYT = IBYT+1
      JBIT = IBYT*8-LDATA
 
C  CHECK ON COMPRESSED MESSAGE LENGTH, EITHER WRITE/RESTORE OR RETURN
C  ------------------------------------------------------------------
 
      IF(IBYT+KBYT+8.GT.MAXCMB) THEN
 
C        THE CURRENT SUBSET WILL NOT FIT INTO THE CURRENT MESSAGE.
C        SET THE FLAG TO INDICATE THAT A MESSAGE WRITE IS NEEDED,
C        THEN GO BACK AND RE-COMPRESS THE SECTION 4 DATA FOR THIS
C        MESSAGE WHILE *EXCLUDING* THE DATA FOR THE CURRENT SUBSET
C        (WHICH WILL BE HELD AND STORED AS THE FIRST SUBSET OF A
C        NEW MESSAGE AFTER WRITING THE CURRENT MESSAGE!).
 
         WRIT1 = .TRUE.
         NCOL = NCOL-1
         ICOL = 1
         GOTO 20
      ELSEIF(.NOT.WRIT1) THEN
 
C        ADD THE CURRENT SUBSET TO THE CURRENT MESSAGE AND RETURN.
 
         CALL USRTPL(LUN,1,1)
         NSUB(LUN) = -NCOL
         GOTO 100
      ENDIF
 
C  WRITE THE COMPLETE COMPRESSED MESSAGE
C  -------------------------------------
 
C     NOW IT IS TIME TO DO THE "REAL" CALL TO CMSGINI TO ACTUALLY
C     INITIALIZE SECTIONS 0, 1, 2 AND 3 OF THE FINAL COMPRESSED
C     BUFR MESSAGE THAT WILL BE WRITTEN OUT.
 
 50   CALL CMSGINI(LUN,MESG,SUBSET,IDATE(LUN),NCOL,IBYT)
 
C     NOW ADD THE SECTION 4 DATA.
 
      IBIT = IBYT*8
      DO I=1,NROW
      IF(ITYP(I).EQ.1.OR.ITYP(I).EQ.2) THEN
         CALL PKB(KMIN(I),IWID(I),MESG,IBIT)
         CALL PKB(KBIT(I),      6,MESG,IBIT)
         IF(KBIT(I).GT.0) THEN
            DO J=1,NCOL
            IF(MATX(I,J).LT.2**IWID(I)-1) THEN
               INCR = MATX(I,J)-KMIN(I) 
            ELSE 
               INCR = 2**KBIT(I)-1
            ENDIF
            CALL PKB(INCR,KBIT(I),MESG,IBIT)
            ENDDO
         ENDIF
      ELSEIF(ITYP(I).EQ.3) THEN
         NCHR = IWID(I)/8
         IF(KBIT(I).GT.0) THEN
            CALL PKB(   0,IWID(I),MESG,IBIT)
            CALL PKB(NCHR,      6,MESG,IBIT)
            DO J=1,NCOL
               CALL PKC(CATX(I,J),NCHR,MESG,IBIT)
            ENDDO
         ELSE
            CALL PKC(CSTR(I),NCHR,MESG,IBIT)
            CALL PKB(      0,   6,MESG,IBIT)
         ENDIF
      ENDIF
      ENDDO
 
C  FILL IN THE END OF THE MESSAGE
C  ------------------------------
 
C     PAD THE END OF SECTION 4 WITH ZEROES UP TO THE NEXT EVEN
C     BYTE COUNT.
 
      CALL PKB(     0,JBIT,MESG,IBIT)
 
C     ADD SECTION 5.
 
      CALL PKC('7777',   4,MESG,IBIT)
 
C  SEE THAT THE MESSAGE BYTE COUNTERS AGREE THEN WRITE A MESSAGE
C  -------------------------------------------------------------
 
      IF(MOD(IBIT,8).NE.0) GOTO 904
      LBYT = IUPB(MESG,5,24)
      NBYT = IBIT/8
      IF(NBYT.NE.LBYT) GOTO 905
 
      CALL MSGWRT(LUNIT,MESG,NBYT)
 
      MAXROW = MAX(MAXROW,NROW)
      MAXCOL = MAX(MAXCOL,NCOL)
      NCMSGS = NCMSGS+1
      NCSUBS = NCSUBS+NCOL
      NCBYTS = NCBYTS+NBYT
 
C  RESET
C  -----
    
C     NOW, UNLESS THIS WAS A "FLUSH" CALL TO THIS SUBROUTINE, GO BACK
C     AND INITIALIZE A NEW MESSAGE TO HOLD THE CURRENT SUBSET THAT WE
C     WERE NOT ABLE TO FIT INTO THE MESSAGE THAT WAS JUST WRITTEN OUT. 
 
      FIRST = .TRUE.
      IF(.NOT.FLUSH) GOTO 1
 
C  EXITS
C  -----
 
100   RETURN
900   WRITE(BORT_STR,'("BUFRLIB: WRCMPS - I/O STREAM INDEX FOR THIS '//
     . 'CALL (",I3,") .NE. I/O STREAM INDEX FOR INITIAL CALL (",I3,")'//
     . ' - UNIT NUMBER NOW IS",I4)') LUN,LUNC,LUNIX
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: WRCMPS - NO. OF ELEMENTS IN THE '//
     . 'SUBSET (",I6,") .GT. THE NO. OF ROWS ALLOCATED FOR THE '//
     . 'COMPRESSION MATRIX (",I6,")")') NVAL(LUN),MROW
      CALL BORT(BORT_STR)
902   WRITE(BORT_STR,'("BUFRLIB: WRCMPS - NO. OF COLUMNS CALCULATED '//
     . 'FOR COMPRESSION MAXRIX IS .LE. 0 (=",I6,")")') NCOL
      CALL BORT(BORT_STR)
903   CALL BORT('BUFRLIB: WRCMPS - MISSING DELAYED REPLICATION FACTOR')
904   CALL BORT('BUFRLIB: WRCMPS - THE NUMBER OF BITS IN THE '//
     . 'COMPRESSED BUFR MSG IS NOT A MULTIPLE OF 8 - MSG MUST END ON '//
     . ' A BYTE BOUNDARY')
905   WRITE(BORT_STR,'("BUFRLIB: WRCMPS - OUTPUT MESSAGE LENGTH FROM '//
     . 'SECTION 0",I6," DOES NOT EQUAL FINAL PACKED MESSAGE LENGTH ("'//
     .',I6,")")') LBYT,NBYT
      CALL BORT(BORT_STR)
      END
      SUBROUTINE WRDLEN

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    WRDLEN
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE FIGURES OUT SOME IMPORTANT INFORMATION
C   ABOUT THE LOCAL MACHINE ON WHICH THE BUFR ARCHIVE LIBRARY SOFTWARE
C   IS BEING RUN AND STORES THIS INTO COMMON BLOCK /HRDWRD/.  SUCH
C   INFORMATION INCLUDES DETERMINING THE NUMBER OF BITS AND THE NUMBER
C   OF BYTES IN A MACHINE WORD AS WELL AS DETERMINING WHETHER THE
C   MACHINE USES THE ASCII OR EBCDIC CHARACTER SET AND WHETHER IT USES
C   THE "BIG-ENDIAN" OR "LITTLE-ENDIAN" SCHEME FOR NUMBERING THE BYTES
C   WITHIN A MACHINE WORD.  IT IS NORMALLY CALLED ONLY ONE TIME (E.G.,
C   DURING THE FIRST CALL TO BUFR ARCHIVE LIBRARY SUBROUTINE OPENBF).
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY OR FOR INFORMATIONAL PURPOSES;
C                           NBYTW INITIALIZED AS ZERO THE FIRST TIME
C                           THIS ROUTINE IS CALLED (BEFORE WAS
C                           UNDEFINED WHEN FIRST REFERENCED)
C
C USAGE:    CALL WRDLEN
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     IUPM
C    THIS ROUTINE IS CALLED BY: IUPBS1   MESGBC   MESGBF   OPENBF
C                               OVRBS1   UPDS3
C                               Normally not called by any application
C                               programs but it could be with COMMON
C                               block /HRDWRD/.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      COMMON /HRDWRD/ NBYTW,NBITW,NREV,IORD(8)
      COMMON /CHARAC/ IASCII,IATOE(0:255),IETOA(0:255)
      COMMON /QUIET / IPRT

      CHARACTER*128 BORT_STR
      CHARACTER*8   CINT,DINT
      CHARACTER*6   CNDIAN,CLANG
      EQUIVALENCE   (CINT,INT)
      EQUIVALENCE   (DINT,JNT)
      LOGICAL       PRINT

      DATA          IFIRST/0/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C     If this is the first call to this subroutine, then initialize
C     COMMON block /HRDWRD/ variable NBYTW as ZERO to satisfy one of
C     the requirements to print diagnostic information ONLY the first
C     time this subroutine is called.

      IF ( IFIRST .EQ. 0 ) THEN
         NBYTW = 0
         IFIRST = 1
      ENDIF

      PRINT = NBYTW.EQ.0 .AND. IPRT.GE.1

C  COUNT THE BITS IN A WORD - MAX 64 ALLOWED
C  -----------------------------------------

      INT = 1
      DO I=1,65
      INT = ISHFT(INT,1)
      IF(INT.EQ.0) GOTO 10
      ENDDO
c  .... DK: Can the below ever happen since upper loop bounds is 65?
10    IF(I.GE.65)       GOTO 900
      IF(MOD(I,8).NE.0) GOTO 901

C  NBITW is no. of bits in a word, NBYTW is no. of bytes in a word
C  ---------------------------------------------------------------

      NBITW = I
      NBYTW = I/8

C  INDEX THE BYTE STORAGE ORDER -  HIGH BYTE TO LOW BYTE
C  -----------------------------------------------------

      JNT = 0

C  Initialize IORD to 9999
C  -----------------------

      DO I = 1,8
         IORD(I) = 9999
      ENDDO

      DO I=1,NBYTW
         INT = ISHFT(1,(NBYTW-I)*8)
         DO J=1,NBYTW
            IF(CINT(J:J).NE.DINT(J:J)) GOTO 20
         ENDDO
c  .... DK: Can the below ever happen since upper loop bounds is NBYTW?
20       IF(J.GT.NBYTW) GOTO 902
         IORD(I) = J
      ENDDO

C  SET THE NOREVERSE FLAG - 0=NOREVERSE;1=REVERSE
C  ----------------------------------------------

C     i.e. set NREV = 0 if the machine is "big-endian"
C          set NREV = 1 if the machine is "little-endian"

      NREV = 0
      CNDIAN = '  BIG '
      DO I=1,NBYTW
      IF(IORD(I).NE.I) THEN
         NREV = 1
         CNDIAN = 'LITTLE'
      ENDIF
      ENDDO

C  SETUP AN ASCII/EBCDIC TRANSALTOR AND DETERMINE WHICH IS NATIVE
C  --------------------------------------------------------------

      IA = IUPM('A',8)
      IF(IA.EQ. 65) THEN
         IASCII = 1
         CLANG  = 'ASCII '
      ELSEIF(IA.EQ.193) THEN
         IASCII = 0
         CLANG  = 'EBCDIC'
      ELSE
         GOTO 903
      ENDIF

      DO I=0,255
      IETOA(I) = 0
      IATOE(I) = 0
      ENDDO

      IETOA(  1) =   1
      IATOE(  1) =   1
      IETOA(  2) =   2
      IATOE(  2) =   2
      IETOA(  3) =   3
      IATOE(  3) =   3
      IETOA(  5) =   9
      IATOE(  9) =   5
      IETOA(  7) = 127
      IATOE(127) =   7
      IETOA( 11) =  11
      IATOE( 11) =  11
      IETOA( 12) =  12
      IATOE( 12) =  12
      IETOA( 13) =  13
      IATOE( 13) =  13
      IETOA( 14) =  14
      IATOE( 14) =  14
      IETOA( 15) =  15
      IATOE( 15) =  15
      IETOA( 16) =  16
      IATOE( 16) =  16
      IETOA( 17) =  17
      IATOE( 17) =  17
      IETOA( 18) =  18
      IATOE( 18) =  18
      IETOA( 19) =  19
      IATOE( 19) =  19
      IETOA( 22) =   8
      IATOE(  8) =  22
      IETOA( 24) =  24
      IATOE( 24) =  24
      IETOA( 25) =  25
      IATOE( 25) =  25
      IETOA( 29) =  29
      IATOE( 29) =  29
      IETOA( 31) =  31
      IATOE( 31) =  31
      IETOA( 34) =  28
      IATOE( 28) =  34
      IETOA( 37) =  10
      IATOE( 10) =  37
      IETOA( 38) =  23
      IATOE( 23) =  38
      IETOA( 39) =  27
      IATOE( 27) =  39
      IETOA( 45) =   5
      IATOE(  5) =  45
      IETOA( 46) =   6
      IATOE(  6) =  46
      IETOA( 47) =   7
      IATOE(  7) =  47
      IETOA( 50) =  22
      IATOE( 22) =  50
      IETOA( 53) =  30
      IATOE( 30) =  53
      IETOA( 55) =   4
      IATOE(  4) =  55
      IETOA( 60) =  20
      IATOE( 20) =  60
      IETOA( 61) =  21
      IATOE( 21) =  61
      IETOA( 63) =  26
      IATOE( 26) =  63
      IETOA( 64) =  32
      IATOE( 32) =  64
      IETOA( 74) =  91
      IATOE( 91) =  74
      IETOA( 75) =  46
      IATOE( 46) =  75
      IETOA( 76) =  60
      IATOE( 60) =  76
      IETOA( 77) =  40
      IATOE( 40) =  77
      IETOA( 78) =  43
      IATOE( 43) =  78
      IETOA( 79) =  33
      IATOE( 33) =  79
      IETOA( 80) =  38
      IATOE( 38) =  80
      IETOA( 90) =  93
      IATOE( 93) =  90
      IETOA( 91) =  36
      IATOE( 36) =  91
      IETOA( 92) =  42
      IATOE( 42) =  92
      IETOA( 93) =  41
      IATOE( 41) =  93
      IETOA( 94) =  59
      IATOE( 59) =  94
      IETOA( 95) =  94
      IATOE( 94) =  95
      IETOA( 96) =  45
      IATOE( 45) =  96
      IETOA( 97) =  47
      IATOE( 47) =  97
      IETOA(106) = 124
      IATOE(124) = 106
      IETOA(107) =  44
      IATOE( 44) = 107
      IETOA(108) =  37
      IATOE( 37) = 108
      IETOA(109) =  95
      IATOE( 95) = 109
      IETOA(110) =  62
      IATOE( 62) = 110
      IETOA(111) =  63
      IATOE( 63) = 111
      IETOA(121) =  96
      IATOE( 96) = 121
      IETOA(122) =  58
      IATOE( 58) = 122
      IETOA(123) =  35
      IATOE( 35) = 123
      IETOA(124) =  64
      IATOE( 64) = 124
      IETOA(125) =  39
      IATOE( 39) = 125
      IETOA(126) =  61
      IATOE( 61) = 126
      IETOA(127) =  34
      IATOE( 34) = 127
      IETOA(129) =  97
      IATOE( 97) = 129
      IETOA(130) =  98
      IATOE( 98) = 130
      IETOA(131) =  99
      IATOE( 99) = 131
      IETOA(132) = 100
      IATOE(100) = 132
      IETOA(133) = 101
      IATOE(101) = 133
      IETOA(134) = 102
      IATOE(102) = 134
      IETOA(135) = 103
      IATOE(103) = 135
      IETOA(136) = 104
      IATOE(104) = 136
      IETOA(137) = 105
      IATOE(105) = 137
      IETOA(145) = 106
      IATOE(106) = 145
      IETOA(146) = 107
      IATOE(107) = 146
      IETOA(147) = 108
      IATOE(108) = 147
      IETOA(148) = 109
      IATOE(109) = 148
      IETOA(149) = 110
      IATOE(110) = 149
      IETOA(150) = 111
      IATOE(111) = 150
      IETOA(151) = 112
      IATOE(112) = 151
      IETOA(152) = 113
      IATOE(113) = 152
      IETOA(153) = 114
      IATOE(114) = 153
      IETOA(161) = 126
      IATOE(126) = 161
      IETOA(162) = 115
      IATOE(115) = 162
      IETOA(163) = 116
      IATOE(116) = 163
      IETOA(164) = 117
      IATOE(117) = 164
      IETOA(165) = 118
      IATOE(118) = 165
      IETOA(166) = 119
      IATOE(119) = 166
      IETOA(167) = 120
      IATOE(120) = 167
      IETOA(168) = 121
      IATOE(121) = 168
      IETOA(169) = 122
      IATOE(122) = 169
      IETOA(173) =  91
      IATOE( 91) = 173
      IETOA(176) =  48
      IATOE( 48) = 176
      IETOA(177) =  49
      IATOE( 49) = 177
      IETOA(178) =  50
      IATOE( 50) = 178
      IETOA(179) =  51
      IATOE( 51) = 179
      IETOA(180) =  52
      IATOE( 52) = 180
      IETOA(181) =  53
      IATOE( 53) = 181
      IETOA(182) =  54
      IATOE( 54) = 182
      IETOA(183) =  55
      IATOE( 55) = 183
      IETOA(184) =  56
      IATOE( 56) = 184
      IETOA(185) =  57
      IATOE( 57) = 185
      IETOA(189) =  93
      IATOE( 93) = 189
      IETOA(192) = 123
      IATOE(123) = 192
      IETOA(193) =  65
      IATOE( 65) = 193
      IETOA(194) =  66
      IATOE( 66) = 194
      IETOA(195) =  67
      IATOE( 67) = 195
      IETOA(196) =  68
      IATOE( 68) = 196
      IETOA(197) =  69
      IATOE( 69) = 197
      IETOA(198) =  70
      IATOE( 70) = 198
      IETOA(199) =  71
      IATOE( 71) = 199
      IETOA(200) =  72
      IATOE( 72) = 200
      IETOA(201) =  73
      IATOE( 73) = 201
      IETOA(208) = 125
      IATOE(125) = 208
      IETOA(209) =  74
      IATOE( 74) = 209
      IETOA(210) =  75
      IATOE( 75) = 210
      IETOA(211) =  76
      IATOE( 76) = 211
      IETOA(212) =  77
      IATOE( 77) = 212
      IETOA(213) =  78
      IATOE( 78) = 213
      IETOA(214) =  79
      IATOE( 79) = 214
      IETOA(215) =  80
      IATOE( 80) = 215
      IETOA(216) =  81
      IATOE( 81) = 216
      IETOA(217) =  82
      IATOE( 82) = 217
      IETOA(224) =  92
      IATOE( 92) = 224
      IETOA(226) =  83
      IATOE( 83) = 226
      IETOA(227) =  84
      IATOE( 84) = 227
      IETOA(228) =  85
      IATOE( 85) = 228
      IETOA(229) =  86
      IATOE( 86) = 229
      IETOA(230) =  87
      IATOE( 87) = 230
      IETOA(231) =  88
      IATOE( 88) = 231
      IETOA(232) =  89
      IATOE( 89) = 232
      IETOA(233) =  90
      IATOE( 90) = 233
      IETOA(240) =  48
      IATOE( 48) = 240
      IETOA(241) =  49
      IATOE( 49) = 241
      IETOA(242) =  50
      IATOE( 50) = 242
      IETOA(243) =  51
      IATOE( 51) = 243
      IETOA(244) =  52
      IATOE( 52) = 244
      IETOA(245) =  53
      IATOE( 53) = 245
      IETOA(246) =  54
      IATOE( 54) = 246
      IETOA(247) =  55
      IATOE( 55) = 247
      IETOA(248) =  56
      IATOE( 56) = 248
      IETOA(249) =  57
      IATOE( 57) = 249

C  SHOW SOME RESULTS
C  -----------------

      IF(PRINT) THEN
         PRINT 100, NBYTW,NBITW,CNDIAN,NREV,IORD,CLANG
100   FORMAT(/15('='),' WELCOME TO BUFR ARCHIVE LIBRARY ',15('=')/
     . 'MACHINE CHARACTERISTICS: NUMBER OF BYTES PER WORD =',I2,
     . ', NUMBER OF BITS PER WORD =',I3,','/25X,'BIT ORDER IS ',A6,
     . ' ENDIAN (NREV=',I2,', IORD=',8I1,'), '/25X,A6,' IS THE NATIVE ',
     . 'LANGUAGE'/14('='),' "UNIFIED" VERSION: 11-04-2003 ',
     . 14('=')/)
      ENDIF

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: WRDLEN - MACHINE WORD LENGTH IS '//
     . 'LIMITED TO 64 BITS (THIS MACHINE APPARENTLY HAS",I4," BIT '//
     . 'WORDS!)")') I
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: WRDLEN - MACHINE WORD LENGTH (",I4,"'//
     . ') IS NOT A MULTIPLE OF 8 (THIS MACHINE HAS WORDS NOT ON WHOLE'//
     . ' BYTE BOUNDARIES!)")') I
      CALL BORT(BORT_STR)
902   WRITE(BORT_STR,'("BUFRLIB: WRDLEN - BYTE ORDER CHECKING MISTAKE'//
     . ', LOOP INDEX J (HERE =",I3,") IS .GT. NO. OF BYTES PER WORD '//
     . 'ON THIS MACHINE (",I3,")")') J,NBYTW
      CALL BORT(BORT_STR)
903   WRITE(BORT_STR,'("BUFRLIB: WRDLEN - CAN''T DETERMINE MACHINE '//
     . 'NATIVE LANGUAGE (CHAR. A UNPACKS TO INT.",I4," NEITHER ASCII '//
     . ' (65) NOR EBCDIC (193)")') IA
      CALL BORT(BORT_STR)
      END
      SUBROUTINE WRITCP(LUNIT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    WRITCP
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2002-05-14
C
C ABSTRACT: THIS SUBROUTINE SHOULD ONLY BE CALLED WHEN LOGICAL UNIT
C   LUNIT HAS BEEN OPENED FOR OUTPUT OPERATIONS.  IT PACKS UP THE
C   CURRENT SUBSET WITHIN MEMORY, COMPRESSES IT, AND THEN TRIES TO ADD
C   IT TO THE COMPRESSED BUFR MESSAGE THAT IS CURRENTLY OPEN WITHIN
C   MEMORY FOR THIS LUNIT.  IF THE SUBSET WILL NOT FIT INTO THE
C   CURRENTLY OPEN MESSAGE (AS DETERMINED VIA A CALL TO BUFR ARCHIVE
C   LIBRARY SUBROUTINE WRCMPS), THEN THAT MESSAGE IS FLUSHED TO LUNIT
C   AND A NEW ONE IS CREATED IN ORDER TO HOLD THE CURRENT SUBSET.  THIS
C   SUBROUTINE IS SIMILAR TO BUFR ARCHIVE LIBRARY SUBROUTINE WRITSB,
C   EXCEPT WRITSP WRITES TO UNCOMPRESSED BUFR MESSAGES.
C
C PROGRAM HISTORY LOG:
C 2002-05-14  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL WRITCP (LUNIT)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     STATUS   WRCMPS   WRTREE
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

C  CHECK THE FILE STATUS
C  ---------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.LT.0) GOTO 901
      IF(IM.EQ.0) GOTO 902

C  PACK UP THE SUBSET AND PUT IT INTO THE MESSAGE
C  ----------------------------------------------

      CALL WRTREE(LUN)
      CALL WRCMPS(LUNIT)

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: WRITCP - OUTPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR OUTPUT')
901   CALL BORT('BUFRLIB: WRITCP - OUTPUT BUFR FILE IS OPEN FOR '//
     . 'INPUT, IT MUST BE OPEN FOR OUTPUT')
902   CALL BORT('BUFRLIB: WRITCP - A MESSAGE MUST BE OPEN IN OUTPUT '//
     . 'BUFR FILE, NONE ARE')
      END
      SUBROUTINE WRITDX(LUNIT,LUN,LUNDX)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    WRITDX
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE WRITES BUFR TABLE (DICTIONARY) MESSAGES TO
C   THE BEGINNING OF AN OUTPUT BUFR FILE IN LUNIT.  THE TABLE MESSAGES
C   ARE READ FROM ARRAYS IN INTERNAL MEMORY (COMMON BLOCK /TABABD/).
C   AN INITIAL CALL TO BUFR ARCHIVE LIBRARY SUBROUTINE READDX GENERATES
C   THESE INTERNAL ARRAYS.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1995-06-28  J. WOOLLEN -- INCREASED THE SIZE OF INTERNAL BUFR TABLE
C                           ARRAYS IN ORDER TO HANDLE BIGGER FILES
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL WRITDX (LUNIT, LUN, LUNDX)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C                BEING WRITTEN
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C                (ASSOCIATED WITH FILE CONNECTED TO LOGICAL UNIT LUNIT)
C     LUNDX    - INTEGER: FORTRAN LOGICAL UNIT NUMBER CONTAINING
C                DICTIONARY TABLE INFORMATION TO BE USED (BY READDX) TO
C                CREATE INTERNAL TABLES WRITTEN TO LUNIT (SEE READDX);
C                IF SET EQUAL TO LUNIT, THIS SUBROUTINE CALLS BORT
C
C REMARKS:
C    THIS ROUTINE CALLS:        ADN30    BORT     DXMINI   IPKM
C                               IUPM     MSGWRT   PKB      PKC
C                               READDX
C    THIS ROUTINE IS CALLED BY: OPENBF
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MAXTBA=50)
      PARAMETER (MAXTBB=250)
      PARAMETER (MAXTBD=250)
      PARAMETER (MXMSGL=20000)

      COMMON /TABABD/ NTBA(0:NFILES),NTBB(0:NFILES),NTBD(0:NFILES),
     .                MTAB(MAXTBA,NFILES),IDNA(MAXTBA,NFILES,2),
     .                IDNB(MAXTBB,NFILES),IDND(MAXTBD,NFILES),
     .                TABA(MAXTBA,NFILES),TABB(MAXTBB,NFILES),
     .                TABD(MAXTBD,NFILES)
      COMMON /DXTAB / MAXDX,IDXV,NXSTR(10),LDXA(10),LDXB(10),LDXD(10),
     .                LD30(10),DXSTR(10)

      CHARACTER*600 TABD
      CHARACTER*128 BORT_STR
      CHARACTER*128 TABB
      CHARACTER*128 TABA
      CHARACTER*56  DXSTR
      CHARACTER*6   ADN30
      CHARACTER*1   MOCT(MXMSGL)
      DIMENSION     MBAY(MXMSGL/4)
      EQUIVALENCE   (MOCT(1),MBAY(1))

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  CHECK UNITS, TABLE MUST BE COMING FROM AN INPUT FILE
C  ----------------------------------------------------

      IF(LUNIT.EQ.LUNDX) GOTO 900

C  MUST FIRST CALL READDX TO GENERATE INTERNAL DICTIONARY TABLE
C  ------------------------------------------------------------

      CALL READDX(LUNIT,LUN,LUNDX)

C  NEXT CALL DXMINI TO WRITE PRELIMINARY INFO TO BUFR DICTIONARY MESSAGE
C  ---------------------------------------------------------------------

      CALL DXMINI(LUN,MBAY,MBYT,MBY4,MBYA,MBYB,MBYD)

      LDA = LDXA(IDXV+1)
      LDB = LDXB(IDXV+1)
      LDD = LDXD(IDXV+1)
      L30 = LD30(IDXV+1)

C  COPY TABLE A CONTENTS TO A BUFR DICTIONARY MESSAGE
C  --------------------------------------------------

      DO I=1,NTBA(LUN)
      IF(MBYT+LDA+8.GT.MAXDX) THEN
         CALL MSGWRT(LUNIT,MBAY,MBYT)
         CALL DXMINI(LUN,MBAY,MBYT,MBY4,MBYA,MBYB,MBYD)
      ENDIF
      CALL IPKM(MOCT(MBY4),3,IUPM(MOCT(MBY4),24)+LDA)
      CALL IPKM(MOCT(MBYA),1,IUPM(MOCT(MBYA), 8)+  1)
      MBIT = 8*(MBYB-1)
      CALL PKC(TABA(I,LUN),LDA,MBAY,MBIT)
      CALL PKB(          0,  8,MBAY,MBIT)
      CALL PKB(          0,  8,MBAY,MBIT)
      MBYT = MBYT+LDA
      MBYB = MBYB+LDA
      MBYD = MBYD+LDA
      ENDDO

C  COPY TABLE B CONTENTS TO A BUFR DICTIONARY MESSAGE
C  --------------------------------------------------

      DO I=1,NTBB(LUN)
      IF(MBYT+LDB+8.GT.MAXDX) THEN
         CALL MSGWRT(LUNIT,MBAY,MBYT)
         CALL DXMINI(LUN,MBAY,MBYT,MBY4,MBYA,MBYB,MBYD)
      ENDIF
      CALL IPKM(MOCT(MBY4),3,IUPM(MOCT(MBY4),24)+LDB)
      CALL IPKM(MOCT(MBYB),1,IUPM(MOCT(MBYB), 8)+  1)
      MBIT = 8*(MBYD-1)
      CALL PKC(TABB(I,LUN),LDB,MBAY,MBIT)
      CALL PKB(          0,  8,MBAY,MBIT)
      MBYT = MBYT+LDB
      MBYD = MBYD+LDB
      ENDDO

C  COPY TABLE D CONTENTS TO A BUFR DICTIONARY MESSAGE
C  --------------------------------------------------

      DO I=1,NTBD(LUN)
      NSEQ = IUPM(TABD(I,LUN)(LDD+1:LDD+1),8)
      LEND = LDD+1 + L30*NSEQ
      IF(MBYT+LEND+8.GT.MAXDX) THEN
         CALL MSGWRT(LUNIT,MBAY,MBYT)
         CALL DXMINI(LUN,MBAY,MBYT,MBY4,MBYA,MBYB,MBYD)
      ENDIF
      CALL IPKM(MOCT(MBY4),3,IUPM(MOCT(MBY4),24)+LEND)
      CALL IPKM(MOCT(MBYD),1,IUPM(MOCT(MBYD), 8)+   1)
      MBIT = 8*(MBYT-4)
      CALL PKC(TABD(I,LUN),LDD,MBAY,MBIT)
      CALL PKB(       NSEQ,  8,MBAY,MBIT)
         DO J=1,NSEQ
         JJ  = LDD+2 + (J-1)*2
         IDN = IUPM(TABD(I,LUN)(JJ:JJ),16)
         CALL PKC(ADN30(IDN,L30),L30,MBAY,MBIT)
         ENDDO
      MBYT = MBYT+LEND
      ENDDO

C  WRITE THE UNWRITTEN MESSAGE
C  ---------------------------

      CALL MSGWRT(LUNIT,MBAY,MBYT)

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: WRITDX - FILES CONTAINING BUFR DATA '//
     . 'AND DICTIONARY TABLE CANNOT BE THE SAME (HERE BOTH SHARE '//
     . 'FORTRAN UNIT NUMBER ",I3,")")') LUNIT
      CALL BORT(BORT_STR)
      END
      SUBROUTINE WRITLC(LUNIT,CHR,STR)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    WRITLC
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2003-11-04
C
C ABSTRACT: THIS SUBROUTINE PACKS A CHARACTER DATA ELEMENT ASSOCIATED
C   WITH A PARTICULAR SUBSET MNEMONIC FROM THE INTERNAL MESSAGE BUFFER
C   (ARRAY MBAY IN COMMON BLOCK /BITBUF/).  IT IS DESIGNED TO BE USED
C   TO STORE CHARACTER ELEMENTS GREATER THAN THE USUAL LENGTH OF EIGHT
C   BYTES.
C
C PROGRAM HISTORY LOG:
C 2003-11-04  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL WRITLC (LUNIT, CHR, STR)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     CHR      - CHARACTER*(*): UNPACKED CHARACTER STRING (I.E.,
C                CHARACTER DATA ELEMENT GREATER THAN EIGHT BYTES)
C     STR      - CHARACTER*(*): STRING (I.E., MNEMONIC)
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     IUPB     PARSEQ   PKC
C                               STATUS   UPB      UPBB     USRTPL
C    THIS ROUTINE IS CALLED BY: None (currently)
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)
      COMMON /MSGCWD/ NMSG(NFILES),NSUB(NFILES),MSUB(NFILES),
     .                INODE(NFILES),IDATE(NFILES)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)

      CHARACTER*(*) CHR,STR
      CHARACTER*128 BORT_STR
      CHARACTER*10  TAG,TGS(100)
      CHARACTER*8   CTAG
      CHARACTER*3   TYP
      REAL*8        VAL

      DATA MAXTG /100/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  CHECK THE FILE STATUS
C  ---------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.LT.0) GOTO 901
      IF(IM.EQ.0) GOTO 902

C  CHECK FOR TAGS (MNEMONICS) IN INPUT STRING (THERE CAN ONLY BE ONE)
C  ------------------------------------------------------------------

      CALL PARSEQ(STR,TGS,MAXTG,NTG)
      IF(NTG.GT.1) GOTO 903
      CTAG = TGS(1)

C  CHECK THAT THE INPUT TAG IS A CHARACTER STRING
C  ----------------------------------------------

      INOD = INODE(LUN)
      DO NOD=INOD,ISC(INOD)
      IF(CTAG.EQ.TAG(NOD)) GOTO 1
      ENDDO
      GOTO 904
1     IF(TYP(NOD).NE.'CHR') GOTO 905

C  LOCATE THE BEGINNING OF THE DATA IN SECTION 4 (MBYTE)
C  -----------------------------------------------------

      IAD1 = 8
      LEN1 = IUPB(MBAY(1,LUN),IAD1+ 1,24)
      LEN2 = IUPB(MBAY(1,LUN),IAD1+ 8, 1)
      IAD2 = IAD1+LEN1
      LEN2 = IUPB(MBAY(1,LUN),IAD2+1,24) * LEN2
      IAD3 = IAD2+LEN2
      LEN3 = IUPB(MBAY(1,LUN),IAD3+1 ,24)
      IAD4 = IAD3+LEN3
      LEN4 = IUPB(MBAY(1,LUN),IAD4+1,24)

      MBYTE = IAD4+4
      NSUBS = 1

C  FIND THE MOST RECENTLY WRITTEN SUBSET IN THE MESSAGE
C  ----------------------------------------------------

      DO WHILE(NSUBS.LT.NSUB(LUN))
         IBIT = MBYTE*8
         CALL UPB(NBYT,16,MBAY(1,LUN),IBIT)
         MBYTE = MBYTE + NBYT
         NSUBS = NSUBS + 1
      ENDDO

      IF(NSUBS.NE.NSUB(LUN)) GOTO 906

C  LOCATE THE STRING ELEMENT TO WRITE
C  ----------------------------------

      MBIT = MBYTE*8 + 16
      NBIT = 0
      N = 1
      CALL USRTPL(LUN,N,N)
20    IF(N+1.LE.NVAL(LUN)) THEN
         N = N+1
         NODE = INV(N,LUN)
         MBIT = MBIT+NBIT
         NBIT = IBT(NODE)
         IF(ITP(NODE).EQ.1) THEN
            CALL UPBB(IVAL,NBIT,MBIT,MBAY(1,LUN))
            CALL USRTPL(LUN,N,IVAL)
            GO TO 20
         ENDIF
         IF(NOD.EQ.NODE) THEN
            IF(ITP(NODE).EQ.3) THEN
               NCHR = NBIT/8
               IBIT = MBIT
               DO N=1,NCHR
               CALL PKC(' ',1,MBAY(1,LUN),IBIT)
               ENDDO
               CALL PKC(CHR,NCHR,MBAY(1,LUN),MBIT)
               CALL USRTPL(LUN,1,1)
               GOTO 100
            ENDIF
         ENDIF
         GOTO 20
      ENDIF
      GOTO 907

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: WRITLC - OUTPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR OUTPUT')
901   CALL BORT('BUFRLIB: WRITLC - OUTPUT BUFR FILE IS OPEN FOR '//
     . 'INPUT, IT MUST BE OPEN FOR OUTPUT')
902   CALL BORT('BUFRLIB: WRITLC - A MESSAGE MUST BE OPEN IN OUTPUT '//
     . 'BUFR FILE, NONE ARE')
903   WRITE(BORT_STR,'("BUFRLIB: WRITLC - THERE CANNOT BE MORE THAN '//
     . ' ONE MNEMONIC IN THE INPUT STRING (",A,") (HERE THERE ARE",I4'//
     . ',")")') STR,NTG
      CALL BORT(BORT_STR)
904   WRITE(BORT_STR,'("BUFRLIB: WRITLC - MNEMONIC ",A," NOT LOCATED '//
     . 'IN REPORT SUBSET")') CTAG
      CALL BORT(BORT_STR)
905   WRITE(BORT_STR,'("BUFRLIB: WRITLC - MNEMONIC ",A," DOES NOT '//
     . 'REPRESENT A CHARACTER ELEMENT (TYP=",A,")")') CTAG,TYP(NOD)
      CALL BORT(BORT_STR)
906   WRITE(BORT_STR,'("BUFRLIB: WRITLC - THE MOST RECENTLY WRITTEN '//
     . ' SUBSET NO. (",I3,") IN MSG .NE. THE STORED VALUE FOR THE NO.'//
     . ' OF SUBSETS (",I3,") IN MSG")') NSUBS,NSUB(LUN)
      CALL BORT(BORT_STR)
907   WRITE(BORT_STR,'("BUFRLB: WRITLC - UNABLE TO FIND ",A," IN '//
     . 'SUBSET")') CTAG
      CALL BORT(BORT_STR)
      END
      SUBROUTINE WRITSA(LUNXX,MSGT,MSGL)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    WRITSA
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE SHOULD ONLY BE CALLED WHEN LOGICAL UNIT
C   ABS(LUNXX) HAS BEEN OPENED FOR OUTPUT OPERATIONS.  WHEN LUNXX IS
C   GREATER THAN ZERO, IT PACKS UP THE CURRENT SUBSET WITHIN MEMORY AND
C   THEN TRIES TO ADD IT TO THE UNCOMPRESSED BUFR MESSAGE THAT IS
C   CURRENTLY OPEN WITHIN MEMORY FOR THIS LUNIT.  IF THE SUBSET WILL
C   NOT FIT INTO THE CURRENTLY OPEN MESSAGE (AS DETERMINED VIA A CALL
C   TO BUFR ARCHIVE LIBRARY SUBROUTINE MSGUPD), THEN THAT MESSAGE IS
C   FLUSHED TO ABS(LUNXX) AND A NEW ONE IS CREATED IN ORDER TO HOLD THE
C   CURRENT SUBSET.  AS LONG AS LUNXX IS GREATER THAN ZERO, WRITSA
C   FUNCTIONS EXACTLY LIKE BUFR ARCHIVE LIBRARY SUBROUTINE WRITSB
C   EXCEPT WRITSA RETURNS A COPY OF EACH COMPLETED BUFR MESSAGE TO THE
C   APPLICATION PROGRAM IN THE FIRST MSGL WORDS OF ARRAY MSGT.  {NOTE
C   THAT MSGT IS NOT FILLED UNTIL THE FIRST CALL TO WRITSA AFTER THE
C   MESSAGE IS ACTUALLY FLUSHED TO ABS(LUNXX), THUS THE LAST MESSAGE IN
C   A BUFR FILE WILL NEVER BE PLACED HERE UNLESS WRITSA IS CALLED ONE
C   FINAL TIME WITH LUNXX LESS THAN ZERO - THIS OPTION FOR LUNXX LESS
C   THAN ZERO IS DISCUSSED NEXT.}  ALSO UNLIKE WRITSB, WRITSA CAN BE
C   CALLED IN AN ALTERNATE CONTEXT WHERE LUNXX CONTAINS THE NEGATIVE OF
C   THE LOGICAL UNIT NUMBER ABS(LUNXX).  THIS IS A SIGNAL TO BOTH FORCE
C   THE CURRENT MESSAGE IN MEMORY (IF THERE IS ONE) TO BE FLUSHED TO
C   ABS(LUNXX) AND TO RETURN A COPY OF THE MESSAGE (AGAIN IF THERE IS
C   ONE) IN MSGT, EVEN THOUGH THE MESSAGE IS PROBABLY NOT FULL.  {NOTE
C   THAT MSGT IS FILLED WITH THE MESSAGE THAT IS FLUSHED TO ABS(LUNXX)
C   IN THE SAME CALL TO WRITSA HERE}.  IN THIS CASE, ANY CURRENT SUBSET
C   IN MEMORY IS IGNORED.  SINCE A NEW MESSAGE IS NOT CREATED IN THIS
C   CASE, THE APPLICATION PROGRAM WILL HAVE TO CALL BUFR ARCHIVE
C   LIBRARY SUBROUTINE OPENMG OR OPENMB TO CREATE ONE PRIOR TO ANY
C   FUTURE CALLS TO WRITSB OR WRITSA.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY
C
C USAGE:    CALL WRITSA (LUNXX, MSGT, MSGL)
C   INPUT ARGUMENT LIST:
C     LUNXX    - INTEGER: ABSOLUTE VALUE IS FORTRAN LOGICAL UNIT NUMBER
C                FOR BUFR FILE {IF LUNXX IS LESS THAN ZERO, THEN ANY
C                CURRENT MESSAGE IN MEMORY WILL BE FORCIBLY FLUSHED TO
C                ABS(LUNXX) AND TO ARRAY MSGT}
C
C   OUTPUT ARGUMENT LIST:
C     MSGT     - INTEGER: *-WORD PACKED BINARY ARRAY CONTAINING BUFR
C                MESSAGE (FIRST MSGL WORDS FILLED)
C     MSGL     - INTEGER: NUMBER OF WORDS FILLED IN MSGT
C                       0 = no message was returned
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     CLOSMG   MSGUPD   STATUS
C                               WRTREE
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MXMSGL=20000)

      COMMON /BUFRMG/ MSGLEN,MSGTXT(MXMSGL/4)

      DIMENSION MSGT(*)

C----------------------------------------------------------------------
C----------------------------------------------------------------------

      LUNIT = ABS(LUNXX)

C  CHECK THE FILE STATUS
C  ---------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.LT.0) GOTO 901
      IF(IM.EQ.0) GOTO 902

C  IF LUNXX < 0, FORCE MEMORY MSG TO BE WRITTEN (W/O ANY CURRENT SUBSET)
C  ---------------------------------------------------------------------

      IF(LUNXX.LT.0) CALL CLOSMG(LUNIT)


C  IF LUNXX < 0, FORCE MEMORY MSG TO BE WRITTEN (W/O ANY CURRENT SUBSET)
C  ---------------------------------------------------------------------

      IF(MSGLEN.GT.0) THEN
         MSGL = MSGLEN
         DO N=1,MSGL
         MSGT(N) = MSGTXT(N)
         ENDDO
         MSGLEN = 0
      ELSE
         MSGL = 0
      ENDIF

      IF(LUNXX.LT.0) GOTO 100

C  PACK UP THE SUBSET AND PUT IT INTO THE MESSAGE
C  ----------------------------------------------

      CALL WRTREE(LUN)
      CALL MSGUPD(LUNIT,LUN)

C  EXITS
C  -----

100   RETURN
900   CALL BORT('BUFRLIB: WRITSA - OUTPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR OUTPUT')
901   CALL BORT('BUFRLIB: WRITSA - OUTPUT BUFR FILE IS OPEN FOR '//
     . 'INPUT, IT MUST BE OPEN FOR OUTPUT')
902   CALL BORT('BUFRLIB: WRITSA - A MESSAGE MUST BE OPEN IN OUTPUT '//
     . 'BUFR FILE, NONE ARE')
      END
      SUBROUTINE WRITSB(LUNIT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    WRITSB
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE SHOULD ONLY BE CALLED WHEN LOGICAL UNIT
C   LUNIT HAS BEEN OPENED FOR OUTPUT OPERATIONS.  IT PACKS UP THE
C   CURRENT SUBSET WITHIN MEMORY AND THEN TRIES TO ADD IT TO THE 
C   UNCOMPRESSED BUFR MESSAGE THAT IS CURRENTLY OPEN WITHIN MEMORY FOR
C   THIS LUNIT.  IF THE SUBSET WILL NOT FIT INTO THE CURRENTLY OPEN
C   MESSAGE (AS DETERMINED VIA A CALL TO BUFR ARCHIVE LIBRARY
C   SUBROUTINE  MSGUPD), THEN THAT MESSAGE IS FLUSHED TO LUNIT AND A
C   NEW ONE IS CREATED IN ORDER TO HOLD THE CURRENT SUBSET.  THIS
C   SUBROUTINE IS SIMILAR TO BUFR ARCHIVE LIBRARY SUBROUTINE WRITCP,
C   EXCEPT WRITCP WRITES TO COMPRESSED BUFR MESSAGES.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 2003-11-04  J. ATOR    -- ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL WRITSB (LUNIT)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     MSGUPD   STATUS   WRTREE
C    THIS ROUTINE IS CALLED BY: None
C                               Normally called only by application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

C  CHECK THE FILE STATUS
C  ---------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.LT.0) GOTO 901
      IF(IM.EQ.0) GOTO 902

C  PACK UP THE SUBSET AND PUT IT INTO THE MESSAGE
C  ----------------------------------------------

      CALL WRTREE(LUN)
      CALL MSGUPD(LUNIT,LUN)

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: WRITSB - OUTPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR OUTPUT')
901   CALL BORT('BUFRLIB: WRITSB - OUTPUT BUFR FILE IS OPEN FOR '//
     . 'INPUT, IT MUST BE OPEN FOR OUTPUT')
902   CALL BORT('BUFRLIB: WRITSB - A MESSAGE MUST BE OPEN IN OUTPUT '//
     . 'BUFR FILE, NONE ARE')
      END
      SUBROUTINE WRITST(LUNIT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    WRITST
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2003-11-04
C
C ABSTRACT: THIS SUBROUTINE SHOULD ONLY BE CALLED WHEN LOGICAL UNIT
C   LUNIT HAS BEEN OPENED FOR OUTPUT OPERATIONS.  IT GENERATES A
C   STANDARDIZED VERSION OF THE CURRENT BUFR MESSAGE IN INTERNAL MEMORY
C   (ARRAY MBAY IN COMMON BLOCK /BITBUF/), PREVIOUSLY OPENED BY EITHER
C   BUFR ARCHIVE LIBRARY SUBROUTINE OPENMG OR OPENMB, AND WRITES IT TO
C   THE UNIT LUNIT.  SEE DOCUMENTATION IN BUFR ARCHIVE LIBRARY ROUTINE
C   STANDARD FOR MORE ON WHAT "STANDARDIZATION" MEANS.
C
C PROGRAM HISTORY LOG:
C 2003-11-04  J. WOOLLEN -- ORIGINAL AUTHOR
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL WRITST (LUNIT)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT     CLOSMG   PKB      PKC
C                               STANDARD STATUS
C    THIS ROUTINE IS CALLED BY: None (currently)
C                               Normally not called by any application
C                               programs but it could be with COMMON
C                               block /BITBUF/.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)

      CHARACTER*4 SEVN
      DIMENSION   MSGTMP(MXMSGL/4)

      DATA SEVN/'7777'/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  LUNIT MUST POINT TO AN OPEN BUFR FILE
C  -------------------------------------

      CALL STATUS(LUNIT,LUN,IL,IM)
      IF(IL.EQ.0) GOTO 900
      IF(IL.LT.0) GOTO 901

C  UPDATE SEC. 0 BYTE COUNT & INSTALL 7777 IN SEC. 5 TO HUMOR STANDARD
C  -------------------------------------------------------------------

      IBIT = 32
      CALL PKB(MBYT(LUN),24,MBAY(1,LUN),IBIT)
      IBIT = (MBYT(LUN)-4)*8
      CALL PKC(SEVN,4,MBAY(1,LUN),IBIT)

C  CALL STANDARD
C  -------------

      CALL STANDARD(LUNIT,MBAY(1,LUN),MSGTMP)

C  TRANSFER STANDARD MESSAGE INTO INTERNAL MESSAGE BUFFER
C  ------------------------------------------------------

      DO N=1,MXMSGL/4
      MBAY(N,LUN) = MSGTMP(N)
      ENDDO

C  CLOSE AND WRITE OUT THE STANDARD MESSAGE
C  ----------------------------------------

      CALL CLOSMG(LUNIT)

C  EXITS
C  -----

      RETURN
900   CALL BORT('BUFRLIB: WRITST - OUTPUT BUFR FILE IS CLOSED, IT '//
     . 'MUST BE OPEN FOR OUTPUT')
901   CALL BORT('BUFRLIB: WRITST - OUTPUT BUFR FILE IS OPEN FOR '//
     . 'INPUT, IT MUST BE OPEN FOR OUTPUT')
      END
      SUBROUTINE WRTREE(LUN)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    WRTREE
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE CONVERTS USER NUMBERS INTO SCALED INTEGERS
C   AND PACKS THE USER ARRAY INTO THE SUBSET BUFFER.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- CORRECTED SOME MINOR ERRORS
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2000-09-19  J. WOOLLEN -- MAXIMUM MESSAGE LENGTH INCREASED FROM
C                           10,000 TO 20,000 BYTES
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- MAXJL (MAXIMUM NUMBER OF JUMP/LINK ENTRIES)
C                           INCREASED FROM 15000 TO 16000 (WAS IN
C                           VERIFICATION VERSION); UNIFIED/PORTABLE FOR
C                           WRF; ADDED DOCUMENTATION (INCLUDING
C                           HISTORY); REPL. "IVAL(N)=ANINT(PKS(NODE))"
C                           WITH "IVAL(N)=NINT(PKS(NODE))" (FORMER
C                           CAUSED PROBLEMS ON SOME FOREIGN MACHINES)
C
C USAGE:    CALL WRTREE (LUN)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C
C REMARKS:
C    THIS ROUTINE CALLS:        PKB      PKC
C    THIS ROUTINE IS CALLED BY: WRITCP   WRITSA   WRITSB
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAXJL=16000)
      PARAMETER (NFILES=32)
      PARAMETER (MXMSGL=20000)

      COMMON /BITBUF/ MAXBYT,IBIT,IBAY(MXMSGL/4),MBYT(NFILES),
     .                MBAY(MXMSGL/4,NFILES)
      COMMON /TABLES/ MAXTAB,NTAB,TAG(MAXJL),TYP(MAXJL),KNT(MAXJL),
     .                JUMP(MAXJL),LINK(MAXJL),JMPB(MAXJL),
     .                IBT(MAXJL),IRF(MAXJL),ISC(MAXJL),
     .                ITP(MAXJL),VALI(MAXJL),KNTI(MAXJL),
     .                ISEQ(MAXJL,2),JSEQ(MAXJL)
      COMMON /USRINT/ NVAL(NFILES),INV(MAXJL,NFILES),VAL(MAXJL,NFILES)

      CHARACTER*10 TAG
      CHARACTER*8  CVAL
      CHARACTER*3  TYP
      DIMENSION    IVAL(MAXJL)
      EQUIVALENCE  (CVAL,RVAL)
      REAL*8       VAL,RVAL,BMISS

      DATA         BMISS/10E10/

C-----------------------------------------------------------------------
      PKS(NODE) = VAL(N,LUN)*10.**ISC(NODE)-IRF(NODE)
C-----------------------------------------------------------------------

C  CONVERT USER NUMBERS INTO SCALED INTEGERS
C  -----------------------------------------

      DO N=1,NVAL(LUN)
      NODE = INV(N,LUN)
      IF(ITP(NODE).EQ.1) THEN
         IVAL(N) = VAL(N,LUN)
      ELSEIF(TYP(NODE).EQ.'NUM') THEN
         IF(VAL(N,LUN).NE.BMISS) THEN
ccccccccccccIVAL(N) = ANINT(PKS(NODE))
            IVAL(N) = NINT(PKS(NODE))
         ELSE
            IVAL(N) = -1
         ENDIF
      ENDIF
      ENDDO

C  PACK THE USER ARRAY INTO THE SUBSET BUFFER
C  ------------------------------------------

      IBIT = 16

      DO N=1,NVAL(LUN)
      NODE = INV(N,LUN)
      IF(ITP(NODE).LT.3) THEN
         CALL PKB(IVAL(N),IBT(NODE),IBAY,IBIT)
      ELSE
         RVAL = VAL(N,LUN)
         CALL PKC(CVAL,IBT(NODE)/8,IBAY,IBIT)
      ENDIF
      ENDDO

      RETURN
      END
      SUBROUTINE WTSTAT(LUNIT,LUN,IL,IM)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    WTSTAT
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 1994-01-06
C
C ABSTRACT: THIS SUBROUTINE EITHER DISCONNECTS THE INPUT LOGICAL UNIT
C   NUMBER LUNIT (AND ITS ASSOCIATED BUFR FILE) FROM THE BUFR ARCHIVE
C   LIBRARY SOFTWARE OR IT CONNECTS IT AS EITHER AN INPUT OR OUPUT FILE
C   AND DEFINES A BUFR MESSAGE AS BEING EITHER OPENED OR CLOSED IN
C   MEMORY FOR THE BUFR FILE IN LUNIT.  THIS INFORMATION IS STORED IN
C   THE INTERNAL ARRAYS IOLUN AND IOMSG IN COMMON BLOCK /STBFR/.
C
C PROGRAM HISTORY LOG:
C 1994-01-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 1998-07-08  J. WOOLLEN -- REPLACED CALL TO CRAY LIBRARY ROUTINE
C                           "ABORT" WITH CALL TO NEW INTERNAL BUFRLIB
C                           ROUTINE "BORT"
C 1999-11-18  J. WOOLLEN -- THE NUMBER OF BUFR FILES WHICH CAN BE
C                           OPENED AT ONE TIME INCREASED FROM 10 TO 32
C                           (NECESSARY IN ORDER TO PROCESS MULTIPLE
C                           BUFR FILES UNDER THE MPI)
C 2003-11-04  J. ATOR    -- CORRECTED A "TYPO" IN TEST FOR VALID VALUE
C                           FOR "IM"; ADDED DOCUMENTATION
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED HISTORY
C                           DOCUMENTATION; OUTPUTS MORE COMPLETE
C                           DIAGNOSTIC INFO WHEN ROUTINE TERMINATES
C                           ABNORMALLY
C
C USAGE:    CALL WTSTAT (LUNIT, LUN, IL, IM)
C   INPUT ARGUMENT LIST:
C     LUNIT    - INTEGER: FORTRAN LOGICAL UNIT NUMBER FOR BUFR FILE
C     LUN      - INTEGER: I/O STREAM INDEX ASSOCIATED WITH LOGICAL UNIT
C                LUNIT
C     IL       - INTEGER: LOGICAL UNIT STATUS INDICATOR:
C                       0 = disconnect LUNIT w.r.t. BUFR Archive
C                           Library software (all information
C                           associated with LUNIT is deleted from
C                           within internal arrays)
C                       1 = connect LUNIT as an output file w.r.t. to
C                           BUFR Archive Library software
C                      -1 = connect LUNIT as an input file w.r.t. to 
C                           BUFR Archive Library software
C     IM       - INTEGER: DEFINES WHETHER THERE IS A BUFR MESSAGE
C                CURRENTLY OPEN WITHIN MEMORY FOR THIS LUNIT (IF IT IS
C                CONNECTED, I.E., IL .NE. ZERO):
C                       0 = no
C                       1 = yes
C
C REMARKS:
C    THIS ROUTINE CALLS:        BORT
C    THIS ROUTINE IS CALLED BY: CLOSBF   CLOSMG   OPENBF   OPENMB
C                               OPENMG   RDMEMM   READERM  READERME
C                               READFT   READIBM  READMG   READMM
C                               REWNBF
C                               Normally not called by any application
C                               programs.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (NFILES=32)

      COMMON /STBFR/ IOLUN(NFILES),IOMSG(NFILES)

      CHARACTER*128 BORT_STR

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  CHECK ON THE ARGUMENTS
C  ----------------------

      IF(LUNIT.LE.0)            GOTO 900
      IF(LUN  .LE.0)            GOTO 901
      IF(IL.LT.-1 .OR. IL.GT.1) GOTO 902
      IF(IM.LT. 0 .OR. IM.GT.1) GOTO 903

C  CHECK ON LUNIT-LUN COMBINATION
C  ------------------------------

      IF(ABS(IOLUN(LUN)).NE.LUNIT) THEN
         IF(IOLUN(LUN).NE.0) GOTO 905
      ENDIF

C  RESET THE FILE STATUSES
C  -----------------------

      IF(IL.NE.0) THEN
         IOLUN(LUN) = SIGN(LUNIT,IL)
         IOMSG(LUN) = IM
      ELSE
         IOLUN(LUN) = 0
         IOMSG(LUN) = 0
      ENDIF

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: WTSTAT - INVALID UNIT NUMBER PASSED '//
     . ' INTO FIRST ARGUMENT (INPUT) (=",I3,")")') LUNIT
      CALL BORT(BORT_STR)
901   WRITE(BORT_STR,'("BUFRLIB: WTSTAT - INVALID I/O STREAM INDEX '//
     . 'PASSED INTO SECOND ARGUMENT (INPUT) (=",I3,")")') LUN
      CALL BORT(BORT_STR)
902   WRITE(BORT_STR,'("BUFRLIB: WTSTAT - INVALID LOGICAL UNIT STATUS'//
     . ' INDICATOR PASSED INTO THIRD ARGUMENT (INPUT) (=",I4,")")') IL
      CALL BORT(BORT_STR)
903   WRITE(BORT_STR,'("BUFRLIB: WTSTAT - INVALID BUFR MESSAGE STATUS'//
     . ' INDICATOR PASSED INTO FOURTH ARGUMENT (INPUT) (=",I4,")")') IM
      CALL BORT(BORT_STR)
905   WRITE(BORT_STR,'("BUFRLIB: WTSTAT - ATTEMPTING TO REDEFINE '//
     . 'EXISTING FILE UNIT (LOGICAL UNIT NUMBER ",I3,")")') IOLUN(LUN)
      CALL BORT(BORT_STR)
      END
      SUBROUTINE XMSGINI(LUN,MESG,SUBSET,IDATE,NSUB,NBYT)

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    XMSGINI
C   PRGMMR: WOOLLEN          ORG: NP20       DATE: 2002-05-14
C
C ABSTRACT: THIS SUBROUTINE HAS THE CAPACITY TO WRITE A FULLY EXPANDED
C   SECTION 3 DESCRIPTOR SET INTO A BUFR MESSAGE.  THIS "CAPACITY" IS
C   NOT FULLY FUNCTIONAL.  IT IS CURRENTLY ACTIVATED BY CHANGING BUFR
C   ARCHIVE LIBRARY SUBROUTINE WRCMPS TO CALL IT RATHER THAN BUFR
C   ARCHIVE LIBRARY SUBROUTINE CMSGINI, WHICH WRITES SECTIONS 0, 1, 2,
C   3 FOR COMPRESSED MESSAGES IN THE USUAL WAY.  XMSGINI IS INCLUDED
C   BECAUSE IT IS USEFUL FOR PARTICULAR SITUATIONS AS IS, AND AT SOME
C   POINT COULD BE INTEGRATED AS A MORE DIRECT FORM OF STANDARDIZING
C   MESSAGES FOR EXPORT OR WHATEVER.
C
C PROGRAM HISTORY LOG:
C 2002-05-14  J. WOOLLEN -- ORIGINAL AUTHOR - CREATED SPECIFICALLY FOR
C                           NESDIS SO THEY CAN SEND FILES OUT WITHOUT
C                           LOCAL SEQUENCE DESCRIPTORS
C 2003-11-04  S. BENDER  -- ADDED REMARKS/BUFRLIB ROUTINE
C                           INTERDEPENDENCIES
C 2003-11-04  D. KEYSER  -- UNIFIED/PORTABLE FOR WRF; ADDED
C                           DOCUMENTATION (INCLUDING HISTORY); OUTPUTS
C                           MORE COMPLETE DIAGNOSTIC INFO WHEN ROUTINE
C                           TERMINATES ABNORMALLY; LEN3 INITIALIZED AS
C                           ZERO (BEFORE WAS UNDEFINED WHEN REFERENCED
C                           FIRST AND SECOND TIMES)
C
C USAGE:    CALL XMSGINI (LUN, MESG, SUBSET, IDATE, NSUB, NBYT)
C   INPUT ARGUMENT LIST:
C     LUN      - INTEGER: I/O STREAM INDEX INTO INTERNAL MEMORY ARRAYS
C     SUBSET   - CHARACTER*8: TABLE A MNEMONIC FOR TYPE OF BUFR MESSAGE
C                BEING WRITTEN
C     IDATE    - INTEGER: DATE-TIME STORED WITHIN SECTION 1 OF BUFR
C                MESSAGE BEING WRITTEN, IN FORMAT OF EITHER YYMMDDHH OR
C                YYYYMMDDHH, DEPENDING ON DATELEN() VALUE
C     NSUB     - INTEGER: NUMBER OF SUBSETS, STORED IN SECTION 3 OF
C                BUFR MESSAGE BEING WRITTEN
C     NBYT     - INTEGER: ACTUAL LENGTH OF SECTION 4 (IN BYTES) BASED
C                ON COMPRESSED DATA
C
C   OUTPUT ARGUMENT LIST:
C     MESG     - INTEGER: *-WORD PACKED BINARY ARRAY CONTAINING BUFR
C                MESSAGE
C     NBYT     - INTEGER: ACTUAL LENGTH OF BUFR MESSAGE (IN BYTES) UP
C                TO THE POINT IN SECTION 4 WHERE COMPRESSED DATA ARE TO
C                BE WRITTEN
C
C REMARKS:
C    THIS ROUTINE CALLS:        ADN30    BORT     I4DY     IFXY
C                               NEMTAB   NEMTBA   NUMTAB   NUMTBD
C                               PKB      PKC      UPTDD
C    THIS ROUTINE IS CALLED BY: WRCMPS
C                               Normally not called by any application
C                               programs.
C       {Note: Call to XMSGINI is commented out in WRCMPS, this is a
C              special case (see XMSGINI docblock).}
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 77
C   MACHINE:  PORTABLE TO ALL PLATFORMS
C
C$$$

      PARAMETER (MAX3=1000)
      PARAMETER (MXMSGL=20000)

      CHARACTER*128 BORT_STR
      CHARACTER*8   SUBSET,NEMO
      CHARACTER*6   ADN30,ADN
      CHARACTER*4   BUFR
      CHARACTER*1   TAB
      DIMENSION     MESG(*),IS3(MAX3)

      DATA BUFR/'BUFR'/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

C  GET THE MESSAGE TAG AND TYPE, AND BREAK UP THE DATE
C  ---------------------------------------------------

c  .... Given SUBSET, NEMTBA returns MTYP,MSBT,INOD
      CALL NEMTBA(LUN,SUBSET,MTYP,MSBT,INOD)
      CALL NEMTAB(LUN,SUBSET,ISUB,TAB,IRET)
      IF(IRET.EQ.0) GOTO 900

C  DATE CAN BE YYMMDDHH OR YYYYMMDDHH
C  ----------------------------------

      JDATE = I4DY(IDATE)
      MCEN = MOD(JDATE/10**8,100)+1
      MEAR = MOD(JDATE/10**6,100)
      MMON = MOD(JDATE/10**4,100)
      MDAY = MOD(JDATE/10**2,100)
      MOUR = MOD(JDATE      ,100)
      MMIN = 0

c  .... DK: Don't think this can happen, because IDATE=0 is returned
c           as 2000000000 by I4DY meaning MCEN would be 21
      IF(MCEN.EQ.1) GOTO 901

      IF(MEAR.EQ.0) MCEN = MCEN-1
      IF(MEAR.EQ.0) MEAR = 100

C  INITIALIZE THE MESSAGE
C  ----------------------

      LEN3 = 0

c  Section    0    1      3      4    5
c  -------   --   --   ----   ----   --
      MBYT =  8 + 18 + LEN3 + NBYT +  4
c  .... Note: MBYT will be recalulated at the end of this subroutine

      MBIT = 0

C  SECTION 0
C  ---------

      CALL PKC(BUFR ,  4 , MESG,MBIT)
      CALL PKB(MBYT , 24 , MESG,MBIT)
      CALL PKB(   3 ,  8 , MESG,MBIT)

C  SECTION 1
C  ---------

      CALL PKB(  18 , 24 , MESG,MBIT)
      CALL PKB(   0 ,  8 , MESG,MBIT)
      CALL PKB(   3 ,  8 , MESG,MBIT)
      CALL PKB(   7 ,  8 , MESG,MBIT)
      CALL PKB(   0 ,  8 , MESG,MBIT)
      CALL PKB(   0 ,  8 , MESG,MBIT)
      CALL PKB(MTYP ,  8 , MESG,MBIT)
      CALL PKB(MSBT ,  8 , MESG,MBIT)
      CALL PKB(   4 ,  8 , MESG,MBIT)
      CALL PKB(   0 ,  8 , MESG,MBIT)
      CALL PKB(MEAR ,  8 , MESG,MBIT)
      CALL PKB(MMON ,  8 , MESG,MBIT)
      CALL PKB(MDAY ,  8 , MESG,MBIT)
      CALL PKB(MOUR ,  8 , MESG,MBIT)
      CALL PKB(MMIN ,  8 , MESG,MBIT)
      CALL PKB(MCEN ,  8 , MESG,MBIT)

C  SECTION 3
C  ---------

      CALL PKB(LEN3 , 24 , MESG,MBIT)
      CALL PKB(   0 ,  8 , MESG,MBIT)
      CALL PKB(NSUB , 16 , MESG,MBIT)
      CALL PKB( 192 ,  8 , MESG,MBIT)

C  PREPARE TO EXPAND THE SUBSET DESCRIPTOR INTO COMPONENTS FOR SECTION 3
C  ---------------------------------------------------------------------

c  .... get SUBSET from ISUB
      CALL NUMTAB(LUN,ISUB,SUBSET,TAB,ITAB)
      IF(ITAB.EQ.0) GOTO 903
      CALL UPTDD(ITAB,LUN,0,NSEQ)
      LEN3 = 0
      DO N=1,NSEQ
      CALL UPTDD(ITAB,LUN,N,IDSC)
      LEN3 = LEN3+1
      IS3(LEN3) = IDSC
      ENDDO

C  EXPAND ALL SEQUENCE DESCRIPTORS IN THE LIST
C  -------------------------------------------

      N = 1
10    DO N=N,LEN3
      IF(IS3(N).GE.IFXY('300000')) THEN
         CALL NUMTBD(LUN,IS3(N),NEMO,TAB,JTAB)
         CALL UPTDD(JTAB,LUN,0,MSEQ)
         IF(LEN3+MSEQ-1.GT.MAX3) GOTO 904
         IF(N.GT.1) THEN
            IF(IS3(N-1).GT.IFXY('101000') .AND.
     .         IS3(N-1).LE.IFXY('101255')) THEN
               ADN = ADN30(IS3(N-1),6)
               WRITE(ADN(2:3),'(I2.2)') MSEQ
               IS3(N-1) = IFXY(ADN)
            ENDIF
         ENDIF
         IF(N.GT.2) THEN
            IF(IS3(N-2).EQ.IFXY('101000')) THEN
               ADN = ADN30(IS3(N-2),6)
               WRITE(ADN(2:3),'(I2.2)') MSEQ
               IS3(N-2) = IFXY(ADN)
            ENDIF
         ENDIF
         DO M=LEN3,N+1,-1
         IS3(M+MSEQ-1) = IS3(M)
         ENDDO
         DO M=1,MSEQ
         CALL UPTDD(JTAB,LUN,M,JDSC)
         IS3(N+M-1) = JDSC
         ENDDO
         LEN3 = LEN3+MSEQ-1
         GOTO 10
      ENDIF
      ENDDO

C  PUT THE EXPANDED LIST INTO SECTION 3, AND UPDATE SECTION LENGTH
C  ---------------------------------------------------------------

      DO L=1,LEN3
      CALL PKB(IS3(L),16,MESG,MBIT)
      ENDDO

      CALL PKB(0,8,MESG,MBIT)
      LEN3 = 8+LEN3*2

C  SECTION 4
C  ---------

      CALL PKB(NBYT , 24 , MESG,MBIT)
      CALL PKB(   0 ,  8 , MESG,MBIT)

C  SECTION 5 - FILLED IN LATER
C  ---------------------------


C  RETURN WITH THE CORRECT NEW MESSAGE BYTE COUNT
C  ----------------------------------------------

      MBYT = MBIT/8+NBYT
      NBYT = MBIT/8
      MBIT = 32
c  .... DK: MBYT doesn't seem to include 4 bytes in Section 5 ?????
      CALL PKB(MBYT,24,MESG,MBIT)
      MBIT = (8+18)*8
      CALL PKB(LEN3,24,MESG,MBIT)

C  EXITS
C  -----

      RETURN
900   WRITE(BORT_STR,'("BUFRLIB: XMSGINI - TABLE A MESSAGE TYPE '//
     . 'MNEMONIC ",A," NOT FOUND IN INTERNAL TABLE D ARRAYS")') SUBSET
      CALL BORT(BORT_STR)
901   CALL BORT
     . ('BUFRLIB: CMSGINI - BUFR MESSAGE DATE (IDATE) is 0000000000')
903   CALL BORT('BUFRLIB: XMSGINI - INPUT MESSAGE TABLE D SUBSET '//
     . 'DESCRIPTOR NOT FOUND IN INTERNAL TABLE D')
904   WRITE(BORT_STR,'("BUFRLIB: XMSGINI - THE LENGTH OF THE EXPANDED'//
     . ' SECTION 3 EXCEEDS THE LIMIT OF",I6," BYTES")') MAX3
      CALL BORT(BORT_STR)
      END
